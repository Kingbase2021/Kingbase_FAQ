%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]


\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=2,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{常见问题}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{5}
\setcounter{secnumdepth}{5}


\title{KingbaseES常见问题手册}
\date{Dec 15, 2021}
\release{ }
\author{ }
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index-manual::doc}}



\chapter{SQL类}
\label{\detokenize{sql:sql}}\label{\detokenize{sql::doc}}

\section{空值问题}
\label{\detokenize{sql:id1}}

\subsection{‘’ 与 null 兼容性}
\label{\detokenize{sql:null}}
适用版本：V8R3 , V8R6

前提条件：数据库必须是oracle 模式

问题分析：参数ora\_input\_emptystr\_isnull=on是为了兼容oracle 对于‘’作为null处理。

以下是oracle环境下，’’ 比较结果：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SQL}\PYG{o}{\PYGZgt{}} \PYG{n}{create} \PYG{n}{table} \PYG{n}{t1} \PYG{p}{(}\PYG{n+nb}{id} \PYG{n}{integer}\PYG{p}{,} \PYG{n}{name} \PYG{n}{char} \PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)} \PYG{p}{)} \PYG{p}{;}
\PYG{n}{Table} \PYG{n}{created}\PYG{o}{.}
\PYG{n}{SQL}\PYG{o}{\PYGZgt{}} \PYG{n}{insert} \PYG{n}{into} \PYG{n}{t1} \PYG{n}{values}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{p}{;}
\PYG{l+m+mi}{1} \PYG{n}{row} \PYG{n}{created}\PYG{o}{.}
\PYG{n}{SQL}\PYG{o}{\PYGZgt{}} \PYG{n}{select} \PYG{o}{*} \PYG{k+kn}{from} \PYG{n+nn}{t1} \PYG{n}{where} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{p}{;}
\PYG{n}{no} \PYG{n}{rows} \PYG{n}{selected}
\PYG{n}{SQL}\PYG{o}{\PYGZgt{}} \PYG{n}{select} \PYG{o}{*} \PYG{k+kn}{from} \PYG{n+nn}{t1} \PYG{n}{where} \PYG{n}{name} \PYG{o+ow}{is} \PYG{n}{null}\PYG{p}{;}
\PYG{n}{ID} \PYG{n}{NAME}
\end{sphinxVerbatim}

同样，开启ora\_input\_emptystr\_isnull参数后，KES结果如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test}\PYG{o}{\PYGZhy{}}\PYG{c+c1}{\PYGZsh{} create table t1 (id integer,name char(9)) ;}
\PYG{n}{CREATE} \PYG{n}{TABLE}
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} insert into t1 values(1, \PYGZsq{}\PYGZsq{}) ;}
\PYG{n}{INSERT} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select * from t1 where name=\PYGZsq{} \PYGZsq{} ;}
\PYG{n+nb}{id} \PYG{o}{|} \PYG{n}{name}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{(}\PYG{l+m+mi}{10} \PYG{n}{rows} \PYG{p}{)}

\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select ★from t1 where name is null;}
\PYG{n+nb}{id} \PYG{o}{|} \PYG{n}{namc}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{l+m+mi}{1}  \PYG{o}{|}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}

\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} show database\PYGZus{}mode;}
\PYG{n}{database\PYGZus{}mode}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{oracle}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{判断值是否为空，要用 is null}
\label{\detokenize{sql:is-null}}
适用版本：V8R3 , V8R6

问题描述：
\begin{quote}

对于空值使用 =‘’ 返回结果与is null返回结果不同

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} show ora\PYGZus{}input\PYGZus{}emptystr\PYGZus{}isnull;}
\PYG{n}{ora\PYGZus{}input\PYGZus{}emptystr\PYGZus{}isnull}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{on}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}

\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} create table t1 (id1 integer ，id2 integer) ;}
\PYG{n}{CREATE} \PYG{n}{TABLE}
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} insert into t1 values (1, nul1) ;}
\PYG{n}{INSERT} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} insert into t1 values(2, \PYGZsq{}\PYGZsq{});}
\PYG{n}{INSERT} \PYG{l+m+mi}{0} \PYG{l+m+mi}{1}
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select * from t1 where id2 is null;}
\PYG{n}{id1} \PYG{o}{|} \PYG{n}{id2}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{l+m+mi}{1}   \PYG{o}{|}
\PYG{l+m+mi}{2}   \PYG{o}{|}
\PYG{p}{(}\PYG{l+m+mi}{2} \PYG{n}{rows}\PYG{p}{)}

\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select * from t1 where id2=\PYGZsq{}\PYGZsq{};}
\PYG{n}{id1}  \PYG{o}{|} \PYG{n}{id2}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{rows}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}

问题分析：当参数ora\_input\_emptystr\_isnull=on时，’’会转换为null，而null表示不确定的值，因此，NULL值比较只能是IS NULL或IS NOT NULL，不可以是= NULL 或<> NULL的的形式判断，无论= NULL 或<> NULL，都是不成立的。


\subsection{PG模式下，‘’ 值问题}
\label{\detokenize{sql:pg}}
适用版本：V8R6

问题分析：PG模式下，需要设置ora\_input\_emptystr\_isnull=off，否则会有很多问题（因为这个参数本身就是为兼容oracle设置的，必须在oracle模式下使用）。

PG模式，‘’ 行为如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} show ora\PYGZus{}input\PYGZus{}emptystr\PYGZus{}isnull;}
\PYG{n}{ora\PYGZus{}input\PYGZus{}emptystr\PYGZus{}isnull}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{off}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{rows}\PYG{p}{)}

\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select * from t1 where name=\PYGZsq{}\PYGZsq{};}
\PYG{n+nb}{id} \PYG{o}{|} \PYG{n}{name}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{l+m+mi}{1}  \PYG{o}{|}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{rows}\PYG{p}{)}

\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select * from t1 where name is null;}
\PYG{n+nb}{id} \PYG{o}{|} \PYG{n}{name}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{rows}\PYG{p}{)}

\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} set ora\PYGZus{}input\PYGZus{}emptystr\PYGZus{}isnull=on;}
\PYG{n}{SET}
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select * from t1 where name=\PYGZsq{}\PYGZsq{};}
\PYG{n+nb}{id} \PYG{o}{|} \PYG{n}{name}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{l+m+mi}{1}  \PYG{o}{|}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{rows}\PYG{p}{)}

\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select * from t1 where name is null;}
\PYG{n+nb}{id} \PYG{o}{|} \PYG{n}{name}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{(}\PYG{l+m+mi}{0} \PYG{n}{rows}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Ora\_input\_emptystr\_isnull对于字符类型空值的影响}
\label{\detokenize{sql:ora-input-emptystr-isnull}}
适用版本：所有版本

注意事项：本测试基于V8R6。该参数可能会因为bug，在不同版本结果可能不同，但理论上应该是本测试结果。

问题描述：当insert数据时，对于空值可以是 ‘’（中间没有空格）或 null，不同参数值结果是不同的，会影响后续的select访问结果。

问题分析：
\begin{quote}

1) ora\_input\_emptystr\_isnull=on 插入的数据，‘’和null都会转为null，之后的select操作不管ora\_input\_emptystr\_isnull为何值，返回结果都相同：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=516\sphinxpxdimen,height=523\sphinxpxdimen]{{FAQ846}.png}
\end{figure}

2) 在ora\_input\_emptystr\_isnull=off时插入的数据，ora\_input\_emptystr\_isnull值不同，返回的结果也不同：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=624\sphinxpxdimen,height=531\sphinxpxdimen]{{FAQ925}.png}
\end{figure}
\end{quote}

测试结论：数据内部对于 ‘’ 与 null值的存储是不同的，当ora\_input\_emptystr\_isnull=on 时，不管的insert ‘’， 还是 where col=’’ ，’’ 都会转为 null ，


\subsection{Ora\_input\_emptystr\_isnull对于数值类型空值的影响}
\label{\detokenize{sql:id2}}
适用版本：V8R6

问题描述：对于integer类型数据，当ora\_input\_emptystr\_isnull=off时，’’对于insert 或 select 都会因为类型转换问题报错。

问题分析：
\begin{quote}

当ora\_input\_emptystr\_isnull=off时，’’当做字符串，无法转换成整型。当ora\_input\_emptystr\_isnull=on 时，’’被转成null，而null 没有类型约束，所以转换没有问题。

1) 当ora\_input\_emptystr\_isnull=on ，insert 与 select 对于 ‘’ 都没问题

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=380\sphinxpxdimen,height=297\sphinxpxdimen]{{FAQ1349}.png}
\end{figure}

2) 当ora\_input\_emptystr\_isnull=off ，insert 与 select 对于 ‘’都有问题

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=457\sphinxpxdimen,height=304\sphinxpxdimen]{{FAQ1410}.png}
\end{figure}
\end{quote}


\section{Core分析}
\label{\detokenize{sql:core}}

\subsection{多线程core分析}
\label{\detokenize{sql:id3}}
适用版本：V7

问题描述：如果现场的数据库core了，利用gdb进行分析时有多个thread，没法确定哪个thread才是真正core的？

问题分析：
\begin{quote}

kingbase 提供了HandleCrash函数，该函数被注册为一个信号处理函数，用来处理：SIGILL，SIGBUS，SIGSEGV等信号，其子函数：StandardHandlerForSigillSigsegvSigbus\_OnMainThread 用来收集堆栈信息，进程信息，并且将他们写入管道中。如果现场中需要gdb重定向，需要以下方法：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{set} \PYG{n}{logging} \PYG{n}{file} \PYG{o}{\PYGZlt{}}\PYG{n}{file} \PYG{n}{name}\PYG{o}{\PYGZgt{}}
\PYG{n+nb}{set} \PYG{n}{logging} \PYG{n}{on}
\PYG{n}{info} \PYG{n}{threads}
\PYG{n}{thread} \PYG{n}{n}
\PYG{n}{info} \PYG{n}{functions}
\PYG{n+nb}{set} \PYG{n}{logging} \PYG{n}{off}
\end{sphinxVerbatim}
\end{quote}

然后将对应的filename拷贝回来


\subsection{如何生成core文件}
\label{\detokenize{sql:id4}}
适用版本：所有版本

问题描述：为什么没有生成core文件？core文件创建在什么位置？

问题解析：
\begin{quote}

没生成core文件，可能是目录权限或limit设置太小。Redhat7采取abrtd服务，core文件在/var/spool/abrt目录。Core文件通常在进程当前工作目录的下创建，或与程序在相同的路径下。但如果程序中调用了chdir函数，则有可能改变了当前工作目录。这时core文件创建在chdir指定的路径下。Redhat7使用abrtd （automatically bug report daemon ）服务，core文件会在/var/spool/abrt/ccpp* 目录下。

以Centos7 为例：

1、 确认针对用户的core文件大小没有限制。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=243\sphinxpxdimen,height=34\sphinxpxdimen]{{FAQ2141}.png}
\end{figure}

2、 修改/etc/abrt/abrt\sphinxhyphen{}action\sphinxhyphen{}save\sphinxhyphen{}package\sphinxhyphen{}data.conf文件，并重启abrtd服务（如果不行，重启服务器）。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{OpenGPGCheck} \PYG{o}{=} \PYG{n}{no}
\PYG{n}{ProcessUnpackaged} \PYG{o}{=} \PYG{n}{yes}
\end{sphinxVerbatim}

3、 确认/var/spool/abrt 目录下有生成ccpp* 之类的文件。
\end{quote}

如何查看core文件
\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}\textasciicircum{}6

适用版本：所有版本

问题描述：如何分析core文件

问题分析：
\begin{quote}

1、 确认core文件是哪个程序生成的

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=650\sphinxpxdimen,height=44\sphinxpxdimen]{{FAQ2359}.png}
\end{figure}

2、 使用gdb分析core文件。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=649\sphinxpxdimen,height=426\sphinxpxdimen]{{FAQ2376}.png}
\end{figure}
\end{quote}


\section{关键字问题}
\label{\detokenize{sql:id5}}

\subsection{如何确认是否系统关键字}
\label{\detokenize{sql:id6}}
适用版本：V8R6

问题描述：RT

问题解答：
\begin{quote}

可以通过函数pg\_get\_keywords取得系统的所有关键字列表。

Keyword分类解释：

1、unreserved，不保留，可以用于任何identity（视图、表、函数、类型、索引、字段、类型等名称）。

2、reserved，保留，不可用于任何identity。

3、reserved (can be function or type name)，保留，但是可用于函数、类型名。

4、unreserved (cannot be function or type name)，不保留，但是不可用于函数、类型名。

\begin{sphinxadmonition}{note}{Note:}
虽然unreserved 的关键字可以用于字段名等，但不能用于列别名。
\end{sphinxadmonition}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=367\sphinxpxdimen,height=140\sphinxpxdimen]{{FAQ2717}.png}
\end{figure}
\end{quote}


\section{乱码或无效字符编码}
\label{\detokenize{sql:id7}}
适用版本：所有版本

问题描述：
\begin{itemize}
\item {} 
问题1：为什么界面有时会显示中文乱码？

\item {} 
问题2：终端查询类似“invalid byte sequence for encoding “utf8”: 0xd0 ” 报错

\item {} 
问题3：应用报错“com.kingbase8.util.KSQLException: 错误: 无效的 "GBK" 编码字节顺序: 0xe8”

\end{itemize}

问题分析：
\begin{quote}

1. client\_encoding与server\_encoding 之间不一致，在存储或读取数据时，会自动进行转换，不会有乱码问题。

2. 问题1、2 主要是显示问题，比如客户端的字符集client\_encoding与工具的字符集（如SecureCRT）不一致。这种情况影响的只是显示，而不影响数据存储。

3. 对于问题3， 可以“看下驱动是否支持连接参数bytestype，指定bytestype=bytea”，或者在插入数据时强制类型转换。
\end{quote}

几种字符编码：
\begin{quote}

1、查看操作系统的编码env | grep LANG

2、show server\_encoding查看数据库编码，一般与环境变量LANG相同，除非手动设置。

3、show client\_encoding 查看客户端编码
\end{quote}


\section{Windows版本安装未注册服务}
\label{\detokenize{sql:windows}}
适用版本：V8R3

问题描述：windows版本安装未注册服务

问题分析：先检查是否安装好了vcredist \_2013(vc 2013的最小化运行环境)。vcredist 2013 x64是windows系统中非常重要的运行库文件，这个文件是保证电脑系统正常运行的必备软件，一般用Visual C++开发的Windows应用程序需要这个运行时库的支持才能在没有安装Visual C++的计算机上正常运行


\section{如何创建一个间隔分区}
\label{\detokenize{sql:id8}}
适用版本：V8R3

问题描述：如何使用SYS\_PATHMAN 创建间隔分区

尤其特别注意红色部分参数设置

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CREATE} \PYG{n}{TABLE} \PYG{n}{range\PYGZus{}rel} \PYG{p}{(}
\PYG{n+nb}{id} \PYG{n}{SERIAL} \PYG{n}{PRIMARY} \PYG{n}{KEY}\PYG{p}{,}
\PYG{n}{dt} \PYG{n}{TIMESTAMP}\PYG{p}{,}
\PYG{n}{txt} \PYG{n}{TEXT}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{INSERT} \PYG{n}{INTO} \PYG{n}{range\PYGZus{}rel} \PYG{p}{(}\PYG{n}{dt}\PYG{p}{,} \PYG{n}{txt}\PYG{p}{)}
\PYG{n}{SELECT} \PYG{n}{g}\PYG{p}{,} \PYG{n}{md5}\PYG{p}{(}\PYG{n}{g}\PYG{p}{:}\PYG{p}{:}\PYG{n}{TEXT}\PYG{p}{)} \PYG{n}{FROM} \PYG{n}{generate\PYGZus{}series}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2015\PYGZhy{}01\PYGZhy{}01}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2015\PYGZhy{}04\PYGZhy{}30}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1 day}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{interval}\PYG{p}{)} \PYG{k}{as} \PYG{n}{g}\PYG{p}{;}
\PYG{n+nb}{set} \PYG{n}{ora\PYGZus{}func\PYGZus{}style} \PYG{o}{=} \PYG{n}{false}\PYG{p}{;}
\PYG{n}{SELECT} \PYG{n}{create\PYGZus{}range\PYGZus{}partitions}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RANGE\PYGZus{}REL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DT}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2015\PYGZhy{}01\PYGZhy{}01}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{DATE}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1 month}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{INTERVAL}\PYG{p}{)}\PYG{p}{;}
 \PYG{n}{CREATE\PYGZus{}RANGE\PYGZus{}PARTITIONS}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
                       \PYG{l+m+mi}{4}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}
\PYG{n}{TEST}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} \PYGZbs{}d+ RANGE\PYGZus{}REL;}
                                                       \PYG{n}{Table} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PUBLIC.RANGE\PYGZus{}REL}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{n}{Column} \PYG{o}{|}            \PYG{n}{Type}             \PYG{o}{|}                       \PYG{n}{Modifiers}                        \PYG{o}{|} \PYG{n}{Storage}  \PYG{o}{|} \PYG{n}{Stats} \PYG{n}{target} \PYG{o}{|} \PYG{n}{Description}

\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{o}{\PYGZhy{}}
 \PYG{n}{ID}     \PYG{o}{|} \PYG{n}{INTEGER}                     \PYG{o}{|} \PYG{o+ow}{not} \PYG{n}{null} \PYG{n}{default} \PYG{n}{NEXTVAL}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RANGE\PYGZus{}REL\PYGZus{}ID\PYGZus{}SEQ}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{:}\PYG{n}{REGCLASS}\PYG{p}{)} \PYG{o}{|} \PYG{n}{plain}    \PYG{o}{|}              \PYG{o}{|}
 \PYG{n}{DT}     \PYG{o}{|} \PYG{n}{TIMESTAMP} \PYG{n}{WITHOUT} \PYG{n}{TIME} \PYG{n}{ZONE} \PYG{o}{|}                                                        \PYG{o}{|} \PYG{n}{plain}    \PYG{o}{|}              \PYG{o}{|}
 \PYG{n}{TXT}    \PYG{o}{|} \PYG{n}{TEXT}                        \PYG{o}{|}                                                        \PYG{o}{|} \PYG{n}{extended} \PYG{o}{|}              \PYG{o}{|}
\PYG{n}{Indexes}\PYG{p}{:}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{RANGE\PYGZus{}REL\PYGZus{}PKEY}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{PRIMARY} \PYG{n}{KEY}\PYG{p}{,} \PYG{n}{BTREE} \PYG{p}{(}\PYG{n}{ID}\PYG{p}{)}
\PYG{n}{Child} \PYG{n}{tables}\PYG{p}{:} \PYG{n}{RANGE\PYGZus{}REL\PYGZus{}1}\PYG{p}{,}
              \PYG{n}{RANGE\PYGZus{}REL\PYGZus{}2}\PYG{p}{,}
              \PYG{n}{RANGE\PYGZus{}REL\PYGZus{}3}\PYG{p}{,}
              \PYG{n}{RANGE\PYGZus{}REL\PYGZus{}4}
\end{sphinxVerbatim}


\section{{[}KESV8R2/3{]} 客服端服务器编码原理说明}
\label{\detokenize{sql:kesv8r2-3}}
服务器存储数据：客户端检查输入的字串是否符合client\_encoding，若符合则发给服务器，否则抛出错误\sphinxhyphen{}\sphinxhyphen{}>服务器接受到客户端发过来的字符串及client\_encoding，字符串通过client\_encoding转server\_encoding，转换成服务器编码风格\sphinxhyphen{}\sphinxhyphen{}>以服务器编码风格存入字符串。

客户端取数据数据：数据通过server\_encoding转client\_encoding，最后发给客户端。

\begin{sphinxadmonition}{note}{Note:}
上面已经说到存是数据通过client\_encoding转server\_encoding，转换成服务器编码风格并写入系统字典，客户端取数据是通过server\_encoding转client\_encoding。然而数据库中存在数据库公有数据字典，这可能导致存取的服务器server\_encoding编码不一致，从而数据出错。所以建议用户不要创建中文名用户、中文名数据库以及中文名的过程语言(如plsql)。数据库登录时server\_encoding并未生效，所以登录时采用的是Unicode编码进行数据库名验证。
\end{sphinxadmonition}


\section{兼容MySQL参数sql\_mode}
\label{\detokenize{sql:mysqlsql-mode}}
适用版本：V8R3 , V8R6

问题描述：KES数据库group by 操作与mysql 结果不同

问题分析：
\begin{quote}

MySQL 的group by : MySQL支持selectlist中非聚集列可以不出现在group by中。sql标准是必须出现在group by中， 如：select col1, col2 from tab group by col1; kingbase 为兼容mysql，设置了个参数ql\_mode参数，目前只支持ONLY\_FULL\_GROUP\_BY选项。如果sql\_mode中不包含ONLY\_FULL\_GROUP\_BY，group by语句可以不符合sql标准。 也就是与mysql结果相同。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=650\sphinxpxdimen,height=268\sphinxpxdimen]{{FAQ5663}.png}
\end{figure}
\end{quote}


\section{MySQL date\_format改写}
\label{\detokenize{sql:mysql-date-format}}
适用版本：V8R3 , V8R6

问题描述：KES 是否有类似MySQL的date\_format日期格式函数

问题解答：
\begin{itemize}
\item {} 
Mysql：select date\_format(CURRENT\_TIMSTAMP,‘\%Y\sphinxhyphen{}\%m\sphinxhyphen{}\%d \%H:\%i:\%s’)

\item {} 
KES：select to\_char (CURRENT\_TIMSTAMP,‘yyyy\sphinxhyphen{}mm\sphinxhyphen{}dd hh24:mi:ss’)

\end{itemize}


\section{共有同义词和私有同义词有什么区别}
\label{\detokenize{sql:id9}}
适用版本：V8R3 , V8R6

问题描述：创建同义词，报错如下：ERROR:  missing or invalid synonym identifier,the current default schema is public

问题解析：KES同义词分为两类：公有同义词，在public模式下；私有同义词，在其他模式下。当创建同义词时，如果是建在public模式下，则必须加public关键字，否则报错。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select current\PYGZus{}user;}
 \PYG{n}{current\PYGZus{}user}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{system}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}

\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} show search\PYGZus{}path;}
   \PYG{n}{search\PYGZus{}path}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdl{}user}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{public}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}

\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} create synonym ps\PYGZus{}t2 for t2;}
\PYG{n}{ERROR}\PYG{p}{:}  \PYG{n}{missing} \PYG{o+ow}{or} \PYG{n}{invalid} \PYG{n}{synonym} \PYG{n}{identifier}\PYG{p}{,}\PYG{n}{the} \PYG{n}{current} \PYG{n}{default} \PYG{n}{schema} \PYG{o+ow}{is} \PYG{n}{public}
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} create public synonym ps\PYGZus{}t2 for t2;}
\PYG{n}{CREATE} \PYG{n}{SYNONYM}
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} drop synonym ps\PYGZus{}t2;}
\PYG{n}{ERROR}\PYG{p}{:}  \PYG{n}{synonym} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ps\PYGZus{}t2}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{does} \PYG{o+ow}{not} \PYG{n}{exist}
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} drop public synonym ps\PYGZus{}t2;}
\PYG{n}{DROP} \PYG{n}{SYNONYM}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
这里是参照oracle模式来的，oracle用户即模式，所以私有同义词在用户名模式下。
\end{sphinxadmonition}


\section{同义词查找规则}
\label{\detokenize{sql:id10}}
适用版本：V8R3 , V8R6

问题描述：用户查找同义词的先后规则

问题分析：
\begin{quote}

KES实际根据Search\_path的先后顺序查找用户模式，可以通过设置search\_path，影响搜索的先后顺序。

Oracle：—>私有同义词—>共有同义词

Kes：—>search\_path

这里为了和oracle查询一致，可以将search\_path改成用户模式，PUBLIC(用户模式在前，PUBLIC在后，一般兼容oracle情况，也是采取的先用户模式再public模式)
\end{quote}


\section{如何查询版本的提交号}
\label{\detokenize{sql:id11}}
适用版本：V8R3 , V8R6

问题描述：RT

问题解决：Select build\_version();

\begin{sphinxadmonition}{note}{Note:}
build\_version 函数实际是kingbase\_version插件生成的
\end{sphinxadmonition}


\section{遇到关键字无法使用作为表名或列名}
\label{\detokenize{sql:id12}}
适用版本：V8R3 大小写敏感版本

问题描述：RT

问题解析：一般出现无法使用作为表名或列名的关键字，我们都采取将表或列名用双引号将其引用。使用双引号(标识符)时，表名和列名区分大小写，这意味着被标识符包起来的对象，写到数据库的原信息就是区分大小写的。

例子如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
不使用标识符“”时候：
TEST=\PYGZsh{} create table tb2(create int);
ERROR:  syntax error at or near \PYGZdq{}create\PYGZdq{}
LINE 1: create table tb2(create int);
                         \PYGZca{}
TEST=\PYGZsh{} create table tb3(col int);
CREATE TABLE
TEST=\PYGZsh{} \PYGZbs{}d+ tb3;
                         Table \PYGZdq{}PUBLIC.TB3\PYGZdq{}
 Column |  Type   | Modifiers | Storage | Stats target | Description
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 COL    | INTEGER |           | plain   |              |

使用标识符时候：
TEST=\PYGZsh{} create table \PYGZdq{}tb4\PYGZdq{}(\PYGZdq{}col\PYGZdq{} int);
CREATE TABLE
TEST=\PYGZsh{} \PYGZbs{}d+ tb4;
Did not find any relation named \PYGZdq{}tb4\PYGZdq{}.
TEST=\PYGZsh{} \PYGZbs{}d+ \PYGZdq{}tb4\PYGZdq{};
                         Table \PYGZdq{}PUBLIC.tb4\PYGZdq{}
 Column |  Type   | Modifiers | Storage | Stats target | Description
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 col    | INTEGER |           | plain   |              |

TEST=\PYGZsh{} create table tb5(\PYGZdq{}create\PYGZdq{} int);
CREATE TABLE
TEST=\PYGZsh{} \PYGZbs{}d+ tb5;
                         Table \PYGZdq{}PUBLIC.TB5\PYGZdq{}
 Column |  Type   | Modifiers | Storage | Stats target | Description
\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}+\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}
 create | INTEGER |           | plain   |              |
\end{sphinxVerbatim}


\section{Nextval在同一条语句中的值}
\label{\detokenize{sql:nextval}}
适用版本：V8R3

问题描述：oracle序列nextval在同一条语句中是一样的值，KES却是增长的值

问题解析：这个和ora\_func\_style参数有关，ora\_func\_style为true的时候兼容oracle序列风格，如下验证：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TEST}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} show ora\PYGZus{}func\PYGZus{}style ;}
 \PYG{n}{ora\PYGZus{}func\PYGZus{}style}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{on}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}

\PYG{n}{TEST}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select serial.nextval, serial.nextval;}
 \PYG{n}{NEXTVAL} \PYG{o}{|} \PYG{n}{NEXTVAL}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
     \PYG{l+m+mi}{116} \PYG{o}{|}     \PYG{l+m+mi}{116}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}

\PYG{n}{TEST}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} set ora\PYGZus{}func\PYGZus{}style = false;}
\PYG{n}{SET}
\PYG{n}{TEST}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select serial.nextval, serial.nextval;}
 \PYG{n}{NEXTVAL} \PYG{o}{|} \PYG{n}{NEXTVAL}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{+}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
     \PYG{l+m+mi}{118} \PYG{o}{|}     \PYG{l+m+mi}{119}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
对于R6版本，没有ora\_func\_style参数，如果database\_mode=oracle，表示兼容oracle模式，在一条SQL内，nextval值也是相同的。
\end{sphinxadmonition}


\section{能为模式指定表空间吗？}
\label{\detokenize{sql:id13}}
适用版本：V8R3 , V8R6

问题描述：RT

问题解答：创建用户或schema时，都不支持指定表空间，一般只有数据库和表能够指定表空间。


\section{丢失了数据库密码，如何恢复？}
\label{\detokenize{sql:id14}}
适用版本：V8R3 , V8R6

问题描述：RT

问题解答：
\begin{quote}

无法恢复密码，但是，你可以将其重置为其他密码。为此，你可以用如下方式重置密码

1. 编辑sys\_hba.conf以暂时允许信任授权(trust)

2. 重新加载配置文件（重新加载sys\_ctl）

3. 连接并通过ALTER ROLE PASSWORD设置新密码

4. 再次编辑sys\_hba.conf并恢复之前的设置

5. 再次重新加载配置文件
\end{quote}


\section{序列的cache}
\label{\detokenize{sql:cache}}
适用版本：V8R3 , V8R6

问题描述：为什么我的序列SERIAL列的编号存在间隙？为什么在事务异常终止时我的序列号没有被重用？为什么不同会话不同会话间nextval差距很大？

问题解答：为了提高并发性，每个会话会按照序列的cache参数大小，在用户的私有内存空间缓存一定数量的序列值。在服务器关闭（stop fast）或会话退出时，会丢弃会话缓存的序列值，因此，序列值会出现跳跃。

\begin{sphinxadmonition}{note}{Note:}
如果要保证序列的取值不出现跳跃，保证不同会话间的取值完全按时间顺序的，可以设置cache 0。但无论如何事务rollback，序列值是不能重用的。
\end{sphinxadmonition}


\section{什么是OID？}
\label{\detokenize{sql:oid}}
适用版本：V8R3

问题描述：RT

问题解析：
\begin{itemize}
\item {} 
如果使用WITHOIDS创建表，则每一行都包含一个OID伪列，该列将在INSERT期间自动填充。OID被顺序分配4字节整数。最初，它们在整个安装过程中都是唯一的。但是，OID计数器大约为40亿个，此后可能会重复OID。

\item {} 
通过在OID列上创建唯一索引，可以防止单个表中的OID重复（但请注意，WITH OIDS子句本身不会创建此类索引）。系统检查索引以查看是否已经存在新生成的OID，如果存在，则生成新的OID。重复该操作，直至满足唯一约束。因此，如果表内的数据已经很多，整个过程是非常低效的。

\item {} 
要对用户表中的行进行唯一编号，最好使用SERIAL而不是OID列，如果期望该表在其整个生命周期中拥有超过20亿个条目，则最好使用bigserial。

\end{itemize}


\section{什么是CTID？}
\label{\detokenize{sql:ctid}}
适用版本：V8R3 , V8R6

问题描述：RT

问题解析：
\begin{itemize}
\item {} 
CTID通过表中的块和偏移位置来标识特定的物理行。

\item {} 
索引条目使用它们来指向物理行。

\item {} 
行的CTID在更新时会更改，因此CTID不能用作长期行标识符。

\item {} 
格式(blockid,itemid)：拿其中(0,1)来说；0表示块id；1表示在这块第一条记录。

\end{itemize}


\section{数据库大小限制}
\label{\detokenize{sql:id15}}
适用版本：V8R3

问题描述：行，表和数据库的最大大小是多少？

问题解答：
\begin{quote}

以下这些是限制：
\begin{itemize}
\item {} 
数据库的最大大小？无限（存在32 TB数据库）

\item {} 
表的最大尺寸？32 TB

\item {} 
一行的最大大小？400 GB

\item {} 
字段的最大大小？1 GB

\item {} 
表中的最大行数？无限

\item {} 
表中的最大列数？250\sphinxhyphen{}1600，取决于列类型

\item {} 
一个表上的最大索引数？无限

\end{itemize}

当然，这些实际上并不是无限的，而是限于可用的磁盘空间和内存/交换空间。当这些值变得异常大时，性能可能会受到影响。

最大表大小为32 TB，不需要操作系统提供大文件支持。大表存储为多个1GB文件，因此文件系统大小限制并不重要。通过将默认块大小增加到32k，最大表大小，行大小和最大列数可以增加三倍。也可以使用表分区来增加最大表大小。

一个限制是不能在长度超过2,000个字符的列上创建索引。最好通过长列的MD5哈希的函数索引来保证唯一性，并且全文索引允许在列中搜索单词。
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
如果存储的表中的行大小超过2KB（每行中数据的总大小），则“表中的最大行数”可能限制为40亿或更少。
\end{sphinxadmonition}


\section{KES数据页结构}
\label{\detokenize{sql:kes}}
适用版本：所有

问题描述：数据行存储需要哪些额外的空间？

问题解析：
\begin{quote}

例如，考虑一个100,000行的文件，每行有一个整数和文本描述。假设文本字符串的平均长度为二十个字节。文件大约为2.8MB。包含此数据的kingbase数据库文件的大小估计为5.2 MB

每行52个字节：
\begin{itemize}
\item {} 
24字节：每行头（大约）

\item {} 
24个字节：1个int字段和1个文本字段

\item {} \begin{itemize}
\item {} 
4个字节：页面上指向元组的指针

\end{itemize}

\end{itemize}

kingbase中的数据页大小为8192字节（8KB），因此：每个数据库页面8192/52=158行（四舍五入）。注意，这里假设fillfactor是100\%。

大约需要 633个数据库页面（向上舍入）

633个数据库页面*每页8192字节= 5,185,536字节（5.2 MB）

索引不需要那么多的开销，但是确实包含要建立索引的数据，因此它们也可能很大。

NULL存储为位图，因此它们使用的空间很小。
\end{quote}

\begin{sphinxadmonition}{note}{Note:}
大字段可能会透明压缩
\end{sphinxadmonition}


\section{如何将数据从客户端通过copy命令导入数据库}
\label{\detokenize{sql:copy}}
适用版本：所有

问题描述：RT

问题解答：通过copy导入数据，要求数据在数据库服务器上，如果数据在客户端机器上，需要用 \textbackslash{}copy


\section{Windows 如何配置免密登录}
\label{\detokenize{sql:id16}}
适用版本：所有

问题描述：RT

问题解答：
\begin{quote}

Linux通过配置 .kbpass，用户可以免密登录数据库。Windows下，对应文件是\%APPDATA\%kingbasekbpass.conf。文件内容格式：

hostname:port:database:username:password
\end{quote}


\section{命令报参数错误问题}
\label{\detokenize{sql:id17}}
适用版本：所有

问题描述：命令正确，却报奇怪的错误

问题描述：
\begin{quote}

用户命令格式报错，但实际命令是正确的。如下图：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=34\sphinxpxdimen]{{FAQ11099}.png}
\end{figure}
\end{quote}

原因分析：命令内部包含非法字符。这种问题原因很难排查，需要使用时注意。


\section{To\_date 函数问题}
\label{\detokenize{sql:to-date}}
问题描述：to\_date 函数显示结果与oracle不一致

验证版本：V8R6C2

原因分析：
\begin{quote}

系统除pg\_catalog下有to\_date函数外，组件kdb\_oracle\_datatype也会在sys用户下创建to\_date函数，二者返回值是有区别的。默认调用的是sys用户下的。

具体例子如下：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=393\sphinxpxdimen,height=336\sphinxpxdimen]{{FAQ11300}.png}
\end{figure}
\end{quote}


\section{视图源定义信息为啥和创建的语句不一样}
\label{\detokenize{sql:id18}}
适用版本：所有版本

问题解析：视图源定义信息是存在pg\_description.description列中，这里有的和创建语句一致，有的不一致。这个和视图的状态有关。下面是获取视图定义的信息规则：
\begin{itemize}
\item {} 
有效视图：通过Sys\_rewrite规则query查询树，反解析query查询获得视图的定义信息。

\item {} 
无效视图：直接通过pg\_description.description，得到定义信息

\end{itemize}

获取视图定义：查询sys\_get\_viewdef（reloid），如下例子

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TEST}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} create force view vtest as select * from test;}
\PYG{n}{WARNING}\PYG{p}{:}  \PYG{n}{View} \PYG{n}{created} \PYG{k}{with} \PYG{n}{compilation} \PYG{n}{errors}
\PYG{n}{CREATE} \PYG{n}{VIEW}
\PYG{n}{TEST} \PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select sys\PYGZus{}get\PYGZus{}viewdef(\PYGZsq{}VTEST\PYGZsq{}::regclass);}
   \PYG{n}{PG\PYGZus{}GET\PYGZus{}VIEWDEF}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{select} \PYG{o}{*} \PYG{k+kn}{from} \PYG{n+nn}{test}\PYG{p}{;}
\end{sphinxVerbatim}


\section{字符串类型长度怎么获取}
\label{\detokenize{sql:id19}}
适用版本：V8R3 , V8R6

问题分析：对于字符类型数据，pg\_attribute.attlen值为 \sphinxhyphen{}1。字符串类型长度是 abs(atttypmod) – 4.


\section{如何改变sys\_guid() 返回值类型}
\label{\detokenize{sql:sys-guid}}
适用版本：V8R3

问题描述：sys\_guid函数默认返回的是16进制的串的ascii编码，通过修改参数guid\_default\_return\_type=name，可以返回16进制字符串，但修改参数时，会发现参数实际已修改，但没效果。

问题分析：
\begin{quote}

以上问题是由于修改过程没有运行alter\_sys\_guid()函数导致的。修改过程如下：
\begin{itemize}
\item {} 
修改参数guid\_default\_return\_type；

\item {} 
重启数据库；

\item {} 
执行 select alter\_sys\_guid()。这个实际是重建sys\_guid()函数，根据参数guid\_default\_return\_type决定是调用sys\_guid\_bytea，还是调用sys\_guid\_name。

\end{itemize}

Alter\_sys\_guid 函数的内容：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
begin
  select setting into return\PYGZus{}type from sys\PYGZus{}catalog.sys\PYGZus{}settings where name = \PYGZsq{}guid\PYGZus{}default\PYGZus{}return\PYGZus{}type\PYGZsq{};
  if lower(return\PYGZus{}type) = \PYGZsq{}bytea\PYGZsq{} then
    stmt = \PYGZsq{}DROP FUNCTION IF EXISTS sys\PYGZus{}catalog.sys\PYGZus{}guid();
     CREATE OR REPLACE INTERNAL FUNCTION sys\PYGZus{}catalog.sys\PYGZus{}guid() RETURNS BYTEA AS
\PYGZdl{}\PYGZdl{}SELECT sys\PYGZus{}catalog.sys\PYGZus{}guid\PYGZus{}bytea()\PYGZdl{}\PYGZdl{} LANGUAGE sql;\PYGZsq{};
  else
    stmt = \PYGZsq{}DROP FUNCTION IF EXISTS sys\PYGZus{}catalog.sys\PYGZus{}guid();
     CREATE OR REPLACE INTERNAL FUNCTION sys\PYGZus{}catalog.sys\PYGZus{}guid() RETURNS NAME AS
\PYGZdl{}\PYGZdl{}SELECT sys\PYGZus{}catalog.sys\PYGZus{}guid\PYGZus{}name()\PYGZdl{}\PYGZdl{} LANGUAGE sql;\PYGZsq{};
  end if;
end;
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
对于R6 版本，没有alter\_sys\_guid，需要手动修改创建脚本。
\end{sphinxadmonition}
\end{quote}


\section{OPENSSL问题}
\label{\detokenize{sql:openssl}}
适用版本：所有版本

问题描述：

用户使用sys\_rman可能会遇到如下错误：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{could} \PYG{o+ow}{not} \PYG{n}{load} \PYG{n}{the} \PYG{n}{shared} \PYG{n}{library}\PYG{p}{:}\PYG{n}{crypto}\PYG{o}{/}\PYG{n}{dso}\PYG{o}{/}\PYG{n}{dso\PYGZus{}dlfcn}\PYG{o}{.}\PYG{n}{c}\PYG{p}{:}\PYG{l+m+mi}{113}\PYG{p}{:}\PYG{n}{filename}\PYG{p}{(}\PYG{n}{libssl\PYGZus{}conf}\PYG{o}{.}\PYG{n}{so}\PYG{p}{)}\PYG{p}{:}
\PYG{n}{libssl\PYGZus{}conf}\PYG{o}{.}\PYG{n}{so}\PYG{p}{:} \PYG{n}{cannot} \PYG{n+nb}{open} \PYG{n}{shared} \PYG{n+nb}{object} \PYG{n}{file}\PYG{p}{:} \PYG{n}{No} \PYG{n}{such} \PYG{n}{file} \PYG{o+ow}{or} \PYG{n}{directory}
\end{sphinxVerbatim}

问题解决：
\begin{quote}

在UOS/Debain的系统中，修改配置文件/etc/profile 增加一行：export OPENSSL\_CONF=/etc/ssl/

如果还未能解决问题，可以修改archive\_command，在命令行前加“export OPENSSL\_CONF=/etc/ssl/”
\end{quote}


\section{Pg\_relation\_size 问题}
\label{\detokenize{sql:pg-relation-size}}
适用版本：V8R3 , V8R6

问题描述：pg\_relation\_size 是否包含clob等大字段大小

问题解答：不包含行外存储的数据段大小。pg\_relation\_size是根据 schema.relname取得表的relfilenode，从而确认表大小。不包括reltoastrelid。


\section{全角字符支持}
\label{\detokenize{sql:id20}}
适用版本：V8R6

问题描述：用户应用开发不规范，SQL 中间掺杂全角字符，比如“，”。

问题解析：
\begin{quote}

V8R6对于中文符号进行部分兼容，其中包括全角逗号、空格等。如：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=243\sphinxpxdimen,height=56\sphinxpxdimen]{{FAQ13964}.png}
\end{figure}
\end{quote}


\section{时间函数问题}
\label{\detokenize{sql:id21}}
适用版本：V8R3 , V8R6

问题描述：为什么有的时间函数在同一事务内返回的都是同一值？

问题解析：
\begin{quote}

KES的认为返回事务开始时间点的时间有利于保证同一事务的多个修改保持同样的时间戳。这点与oracle机制不同，oracle默认返回命令执行时间点的时间戳。实际上KES同时提供了两类函数：
\begin{itemize}
\item {} 
以下函数返回事务开始的时间戳：

\end{itemize}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{transaction\PYGZus{}timestamp}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{now}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}
\begin{itemize}
\item {} 
以下返回语句执行时的时间戳

\end{itemize}
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{statement\PYGZus{}timestamp}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{clock\PYGZus{}timestamp}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{timeofday}
\end{sphinxVerbatim}
\end{quote}
\end{quote}


\section{如何取得对象的DDL信息}
\label{\detokenize{sql:ddl}}
适用版本：V8R6

问题描述：RT

问题解答：

V8R6提供了类似oracle dbms\_metadata的包，用于获取对象的定义信息。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select dbms\PYGZus{}metadata.GET\PYGZus{}DDL(\PYGZsq{}table\PYGZsq{},\PYGZsq{}t1\PYGZsq{});}
         \PYG{n}{get\PYGZus{}ddl}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{CREATE} \PYG{n}{TABLE} \PYG{n}{PUBLIC}\PYG{o}{.}\PYG{n}{T1}\PYG{p}{(} \PYG{o}{+}
  \PYG{n}{ID} \PYG{n}{INTEGER}             \PYG{o}{+}
 \PYG{p}{)}                       \PYG{o}{+}

\PYG{n}{test}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select dbms\PYGZus{}metadata.get\PYGZus{}index\PYGZus{}ddl(\PYGZsq{}ind\PYGZus{}t1\PYGZsq{},\PYGZsq{}public\PYGZsq{});}
                   \PYG{n}{get\PYGZus{}index\PYGZus{}ddl}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{CREATE} \PYG{n}{INDEX} \PYG{n}{ind\PYGZus{}t1} \PYG{n}{ON} \PYG{n}{public}\PYG{o}{.}\PYG{n}{t1} \PYG{n}{USING} \PYG{n}{btree} \PYG{p}{(}\PYG{n+nb}{id}\PYG{p}{)}\PYG{o}{+}
\end{sphinxVerbatim}


\section{全表update非常慢}
\label{\detokenize{sql:update}}
适用版本：V8R6

问题描述：全表关联update时，效率非常低

问题解决：请看以下两种update方法。方法一采用loop方式，效率非常低。而方法二采用hash方式进行连接，效率高

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=650\sphinxpxdimen,height=308\sphinxpxdimen]{{FAQ14823}.png}
\end{figure}


\section{Failed to find conversion function from UNKNOWN to TEXT}
\label{\detokenize{sql:failed-to-find-conversion-function-from-unknown-to-text}}
适用版本：V8R3B0170 , B0180

问题例子：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=561\sphinxpxdimen,height=180\sphinxpxdimen]{{FAQ14910}.png}
\end{figure}

问题解决：升级到 190之后或160之前的版本。


\chapter{PLSQL类}
\label{\detokenize{plsql:plsql}}\label{\detokenize{plsql::doc}}

\section{KES创建过程，报错：PL/SQL block not end correctly}
\label{\detokenize{plsql:kes-pl-sql-block-not-end-correctly}}
在使用ORACLE方法创建PLSQL函数时候，需要先设置好SQLTERM结束符。如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
CREATE OR REPLACE PROCEDURE proc1() AS
BEGIN
         raise notice \PYGZsq{}call proc1\PYGZsq{};
END;

报错：PL/SQL block not end correctly
\end{sphinxVerbatim}

正确执行方式：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZbs{}\PYG{n+nb}{set} \PYG{n}{SQLTERM} \PYG{o}{/}       \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{设置结束符}
\PYG{n}{CREATE} \PYG{n}{OR} \PYG{n}{REPLACE} \PYG{n}{PROCEDURE} \PYG{n}{proc1}\PYG{p}{(}\PYG{p}{)} \PYG{n}{AS}
\PYG{n}{BEGIN}
   \PYG{k}{raise} \PYG{n}{notice} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{call proc1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\PYG{n}{END}\PYG{p}{;}
\PYG{o}{/}
\end{sphinxVerbatim}


\section{如何调用含out参数的存储过程}
\label{\detokenize{plsql:out}}
对于 out参数的过程，只能在block里调用，而且必须传入参数。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{declare}
  \PYG{n}{v\PYGZus{}retcode} \PYG{n}{text}\PYG{p}{;}
  \PYG{n}{v\PYGZus{}id} \PYG{n}{integer}\PYG{p}{;}
\PYG{n}{begin}
  \PYG{n}{CALL} \PYG{n}{proc1}\PYG{p}{(}\PYG{n}{v\PYGZus{}id}\PYG{p}{,} \PYG{n}{v\PYGZus{}retcode}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{end}\PYG{p}{;}
\PYG{o}{/}
\end{sphinxVerbatim}


\section{Savepoint 使用问题}
\label{\detokenize{plsql:savepoint}}
适用版本：V8R6

V8R6不支持在 PLSQL块使用，以下不行：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{begin}
   \PYG{n}{insert} \PYG{n}{into} \PYG{n}{t1} \PYG{n}{values}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
   \PYG{n}{savepoint} \PYG{n}{sv1}\PYG{p}{;}
   \PYG{n}{insert} \PYG{n}{into} \PYG{n}{t1} \PYG{n}{values}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{exception}
   \PYG{n}{when} \PYG{n}{others} \PYG{n}{then}
     \PYG{n}{rollback} \PYG{n}{to} \PYG{n}{sv1}\PYG{p}{;}
\PYG{n}{end}\PYG{p}{;}
\end{sphinxVerbatim}

只能在事务块内使用：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{begin}\PYG{p}{;}
\PYG{n}{insert} \PYG{n}{into} \PYG{n}{t2} \PYG{n}{values}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{savepoint} \PYG{n}{sv1}\PYG{p}{;}
\PYG{n}{insert} \PYG{n}{into} \PYG{n}{t2} \PYG{n}{values}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{rollback} \PYG{n}{to}  \PYG{n}{sv1}\PYG{p}{;}
\PYG{n}{insert} \PYG{n}{into} \PYG{n}{t2} \PYG{n}{values}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{commit}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Create operator（bool与整型比较）}
\label{\detokenize{plsql:create-operator-bool}}
适用版本：V8R3

问题描述：
\begin{quote}

对于整数类型数据与bool类型进行比较时，要么转换报错，要么结果错误。具体问题如下例：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=368\sphinxpxdimen,height=232\sphinxpxdimen]{{FAQ15841}.png}
\end{figure}
\end{quote}

解决方法：
\begin{quote}

创建operator ，具体脚本如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
create or replace internal function sys\PYGZus{}catalog.bool\PYGZus{}eq\PYGZus{}numeric(bool,numeric) returns bool as \PYGZdl{}\PYGZdl{} select \PYGZdl{}1::numeric = \PYGZdl{}2; \PYGZdl{}\PYGZdl{} language sql;

create operator sys\PYGZus{}catalog.= (procedure = bool\PYGZus{}eq\PYGZus{}numeric,leftarg = bool,rightarg = numeric,commutator = =);

create or replace internal function sys\PYGZus{}catalog.numeric\PYGZus{}eq\PYGZus{}bool(numeric, bool) returns bool as \PYGZdl{}\PYGZdl{} select \PYGZdl{}1 = \PYGZdl{}2::numeric; \PYGZdl{}\PYGZdl{} language sql;

create operator sys\PYGZus{}catalog.= (procedure = numeric\PYGZus{}eq\PYGZus{}bool,leftarg = numeric,rightarg = bool,commutator = =);
\end{sphinxVerbatim}
\end{quote}


\section{For循环变量}
\label{\detokenize{plsql:for}}
适用版本：V8R3 , V8R6

问题描述：
\begin{quote}

在创建procedure 时，会有如下错误：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
reate or replace procedure plpgsql\PYGZus{}proc() as
\PYGZdl{}\PYGZdl{}
begin
  for i in select regexp\PYGZus{}split\PYGZus{}to\PYGZus{}table(\PYGZsq{}ab,bc,cd\PYGZsq{},\PYGZsq{},\PYGZsq{}) loop
    raise notice \PYGZsq{}\PYGZpc{}\PYGZsq{},i;
  end loop;
end;
\PYGZdl{}\PYGZdl{} language plpgsql;

ERROR:  loop variable of loop over rows must be a record variable or list of scalar variables
LINE 4:   for i in select regexp\PYGZus{}split\PYGZus{}to\PYGZus{}table(\PYGZsq{}ab,bc,cd\PYGZsq{},\PYGZsq{},\PYGZsq{}) loop
\end{sphinxVerbatim}
\end{quote}

问题分析：
\begin{quote}

以上的写法实际是plsql的语法，对于R6 版本的database\_mode=pg，R3版本大小写不敏感的环境，执行块时默认是plpgsql编译器。因此，以上写法是报错的。
\end{quote}

问题解决：
\begin{quote}

必须先定义循环变量。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
create or replace procedure plpgsql\PYGZus{}proc() as
\PYGZdl{}\PYGZdl{}
declare
  v\PYGZus{}text text;
begin
  for v\PYGZus{}text in select regexp\PYGZus{}split\PYGZus{}to\PYGZus{}table(\PYGZsq{}ab,bc,cd\PYGZsq{},\PYGZsq{},\PYGZsq{}) loop
    raise notice \PYGZsq{}\PYGZpc{}\PYGZsq{},v\PYGZus{}text;
  end loop;
end;
\PYGZdl{}\PYGZdl{} language plpgsql;
\end{sphinxVerbatim}
\end{quote}


\section{函数变量不能超过512}
\label{\detokenize{plsql:id1}}
适用版本：V8R3

问题描述：
\begin{quote}

使用block，function, procedure 时，可能会遇到如下错误：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
ERROR：ANONYMOUS BLOCK has more than 512 arguments。
\end{sphinxVerbatim}
\end{quote}

问题解析：
\begin{quote}

这是由于参数个数超过了512，需要修改代码。参数 max\_function\_args默认是512，无法修改。
\end{quote}


\chapter{参数相关}
\label{\detokenize{parameter:id1}}\label{\detokenize{parameter::doc}}

\section{Kingbase.conf 与 kingbase.auto.conf 参数文件}
\label{\detokenize{parameter:kingbase-conf-kingbase-auto-conf}}
适用版本：V8R3 , V8R6

问题描述：这两个参数文件的读取先后、优先级

问题解答：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
对于kingbase.conf 与 kingbase.auto.conf文件，如果有相同条目，则以kingbase.auto.conf文件参数值为准（忽略 kingbase.conf 相同条目）。

\item {} 
读取先后顺序：数据库启动时先读取 kingbase.conf，再读取kingbase.auto.conf，如果二者相同条目，会忽略kingbase.conf文件的相同条目。

\item {} 
所有文件读取完成后，才apply参数，由于kingbase.conf参数读取在前，kingbase.auto.conf读取在后，对于有先后顺序要求的参数必须注意。

\end{enumerate}

举例如下：
\begin{quote}

kingbase.conf 文件有 error\_user\_connect\_times and max\_error\_user\_connect\_times这两个参数，但是用户又运行了alter system setmax\_error\_user\_connect\_times，相当于在kingbase.auto.conf文件增加了max\_error\_user\_connect\_times条目。当系统启动时，先读取kingbase.conf文件，再读取kingbase.auto.conf文件，由于kingbase.auto.conf文件也有max\_error\_user\_connect\_times条目，就会忽略kingbase.conf文件中的同样条目。而apply的顺序是按读取先后进行的，当apply error\_user\_connect\_times （假设100）参数时，由于还没apply max\_error\_user\_connect\_times（在kingbase.auto.conf）参数 ，认为 max\_error\_user\_connect\_times 值为默认的 5 ，导致报错。
\end{quote}


\section{不同参数如何生效}
\label{\detokenize{parameter:id2}}
适用版本：V8R3 , V8R6

问题描述：为什么有些参数reload就可以生效，而有些参数必须重启数据库？

问题解析：
\begin{quote}

修改参数后，如何生效是由pg\_settings.context值决定的。具体如下：
\begin{itemize}
\item {} 
internal：这些参数是在编译或initdb时设定的，不能修改。如：block\_size， database\_mode

\item {} 
kingbase: 修改这些参数要求重启数据库。如：archive\_mode

\item {} 
sighup: 不需要重启数据库，只需reload就可生效。Kingbase会把sighup传递给子进程，通知子进程重新读取配置。如：archive\_command

\item {} 
backend: 不需要重启数据库，只需reload就可生效，但只影响后续启动的会话。如：log\_connections

\item {} 
user: 表示可以在会话中用 set 命令设置。如：bytea\_output

\end{itemize}
\end{quote}


\section{error\_user\_connect\_times and max\_error\_user\_connect\_times}
\label{\detokenize{parameter:error-user-connect-times-and-max-error-user-connect-times}}
适用版本：V8R3 , V8R6

问题描述：为什么数据库启动报错：\sphinxstyleemphasis{100000 is outsize the max valid range for parameter "max\_error\_user\_connect\_times" 5}，而实际的\sphinxstyleemphasis{max\_error\_user\_connect\_times}参数值并不是5

问题解答：这两个参数要求先后顺序，max\_error\_user\_connect\_times参数必须放于error\_user\_connect\_times
前面，否则会默认为max\_error\_user\_connect\_times是5 ，报错。


\section{Exclude\_reserved\_words 排除关键字}
\label{\detokenize{parameter:exclude-reserved-words}}
适用版本：V8R3 , V8R6

问题描述：客户设置Exclude\_reserved\_words=’level’，导致show transaction isolation level 语法错误。

问题分析：关键字可配置功能实际实现：将原来的关键字配置为非关键字，词法解析到该字符串时，不再将其识别为关键字，而认为是一个普通的字符串。该功能风险点：排除该关键字，那么语法规则中涉及到该关键字的语法规则都将失效，甚至出现莫名的错误（以为是关键字，结果识别为字符串，导致语法对应错误，识别为其他语义）。本例中配置了level，导致涉及level的语法失效。


\section{max\_locks\_per\_transaction设置过大引发数据库启动问题}
\label{\detokenize{parameter:max-locks-per-transaction}}
适用版本：V8R3 , V8R6

问题描述：数据库无法启动，报无法分配内存

问题解析：
\begin{itemize}
\item {} 
max\_locks\_per\_transaction：这个参数控制每个事务能够得到的平均的对象锁的个数，默认值是64。数据库在启动以后创建的共享锁表最大可以保存max\_locks\_per\_transaction * (max\_connections + max\_prepared\_transactions)个对象锁。每个锁空间需预留270个字节的共享内存。单个事务可以同时获得的对象锁的数目可以超过max\_locks\_per\_transaction的值，只要共享锁表中还有剩余空间。

\item {} 
max\_connections(integer)：这个参数只有在启动数据库时，才能被设置。它决定数据库可以同时建立的最大的客户端连接的数目。默认值是100。每个连接占用 400字节共享内存。

\begin{sphinxadmonition}{note}{Note:}
Increasing max\_connections costs \textasciitilde{}400 bytes of shared memory per connection slot, plus lock space (see max\_locks\_per\_transaction).
\end{sphinxadmonition}

\item {} 
用户将 max\_locks\_per\_transaction值设置 为 215927809，导致系统启动时要求分配  215927809 * 270 * 1000（max\_connections）= 54TB的内存空间，数据库启动失败

\end{itemize}


\section{max\_identifier\_length}
\label{\detokenize{parameter:max-identifier-length}}
适用版本：V8R3 , V8R6

问题描述：对象名称能否超过63字符？

问题解答：参数 max\_identifier\_length决定最大的对象名称长度，该参数只能在编译时指定，不能修改。默认是63。对于汉字表名，根据编码的不同，一个汉字占2\sphinxhyphen{}3字符。


\section{数据库启动失败，报“内存段超过可用内存”}
\label{\detokenize{parameter:id3}}
适用版本：所有版本

问题描述：
\begin{quote}

数据库启动报内存不足，错误信息如下：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=553\sphinxpxdimen,height=84\sphinxpxdimen]{{FAQ20071}.png}
\end{figure}
\end{quote}

原因分析：
\begin{quote}
\begin{itemize}
\item {} 
原因1：实际物理内存不够

\end{itemize}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=460\sphinxpxdimen,height=44\sphinxpxdimen]{{FAQ20092}.png}
\end{figure}
\begin{itemize}
\item {} 
原因2：swap 与 shared\_buffers 相差过大，如以上例子，Swap才配置2G，而Shared\_buffers 16G

\item {} 
原因3：系统参数设置过小

\end{itemize}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=421\sphinxpxdimen,height=36\sphinxpxdimen]{{FAQ20175}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=267\sphinxpxdimen,height=177\sphinxpxdimen]{{FAQ20177}.png}
\end{figure}
\begin{itemize}
\item {} 
原因4：启用了大页，但是大页内存却不够。数据库参数huge\_pages = on，表示数据库启动时只能用大页。如果操作系统大页内存设置过小，数据库就无法启动

\end{itemize}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=312\sphinxpxdimen,height=64\sphinxpxdimen]{{FAQ20260}.png}
\end{figure}
\begin{itemize}
\item {} 
原因5：数据库参数设置不合理。除了内存相关的参数，如shared\_buffers外，还有其他参数也会要求内存段：max\_connections, max\_prepared\_transactions都会影响内存段的分配。还有 max\_locks\_per\_transaction参数，每个需要270字节的内存。

\end{itemize}
\end{quote}


\chapter{License 相关}
\label{\detokenize{license:license}}\label{\detokenize{license::doc}}

\section{如何查询license有效时间}
\label{\detokenize{license:id1}}
适用版本：V8R3 , V8R6

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TEST}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} selectget\PYGZus{}license\PYGZus{}validdays ();}
 \PYG{n}{GET\PYGZus{}LICENSE\PYGZus{}VALIDDAYS}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{l+m+mi}{24}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}
\end{sphinxVerbatim}

SELECT get\_license\_validdays();   如果返回值为 \sphinxhyphen{}2 ，表示永久license


\section{如何查询license完整信息}
\label{\detokenize{license:id2}}
适用版本：V8R3


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline

TEST=\# select get\_license\_info();

                        GET\_LICENSE\_INFO

 License序列号 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 6AB57220\sphinxhyphen{}864E\sphinxhyphen{}11EA\sphinxhyphen{}AA4F\sphinxhyphen{}000C2937A8A8+

 生产日期 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 2020\sphinxhyphen{}04\sphinxhyphen{}25                               +

 产品名称 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} KingbaseES V8                            +

 细分版本模板名 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} TEST人大金仓内部测试               +

 产品版本号 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} V008R003                               +

 浮动基准日期 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用                                       +

 有效期间 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 30                                       +

 CPU检查 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                         +

 MAC地址 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 00:00:00:00:00:00                         +

 最大连接数 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                      +

 数据同步 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 物理同步 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 增量备份恢复 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                    +

 集群对网络故障的容错 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                            +

 集群配置工具 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                    +

 读写分离模块 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                    +

 保密通讯协议 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                    +

 审计 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                            +

 三权分立 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 密码复杂度 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                      +

 用户锁定 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 运行状态分析 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                    +

 滚动升级 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 恢复到指定时间点 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                +

 快速加载 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 日志压缩 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 全文检索 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 健康检查 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 并行查询 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 并行备份还原 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                    +

 日志解析 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 异构数据源 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                      +

 透明加密 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                        +

 强制访问控制 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 0                                    +

(1 row)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
V8R6 没有该函数
\end{sphinxadmonition}


\section{如何查询license单项信息}
\label{\detokenize{license:id3}}
适用版本：V8R3


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|}
\hline

TEST=\# select * from substring(get\_license\_info() ,
instr(get\_license\_info(), 'MAC地址'),

instr(get\_license\_info(), '最大连接') \sphinxhyphen{} instr(get\_license\_info(),
'MAC地址') \sphinxhyphen{} 1);

               SUBSTRING

 MAC地址 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 启用 \sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{} 00:00:00:00:00:00

(1 row)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{替换license步骤}
\label{\detokenize{license:id4}}
适用版本：V8R3 ，V8R6

替换过程：
\begin{quote}

第一步，登录服务器，执行：find \sphinxhyphen{}name license.dat，看license.dat在哪些路径。

第二步：把上一步找到的路径记录下来。

第三步，根据上一步的路径把原有license.dat重命名为license.dat\_old或者其他名字

第四步：把新的license.dat传到服务器，重命名为license.dat，并且执行chown \sphinxhyphen{}R kingabse:kingbase license.dat（用什么用户安装的用户权限给到哪个用户）

第五步，执行su \sphinxhyphen{}kingbase切换到kingbase用户，把最新的license拷贝到第二步记录下来的路径。

最后一步：重启数据库：sys\_ctl restart \sphinxhyphen{}D /home/kingbase/KingbaseES/V8/data(备注：每个地方data路径可能不一样，通过ps \sphinxhyphen{}ef查找出带\sphinxhyphen{}D的进程，确定准确的data路径)
\end{quote}


\section{替换license是否要重启数据库}
\label{\detokenize{license:id5}}
适用版本：V8R3, V8R6

问题描述：如题

问题解决：可以不必重启数据库，可以在任一system用户连接上执行select sys\_reload\_conf()，退出重登录后就可以看到变更生效。或者kill \sphinxhyphen{}1 kingbase主进程号的方式，也可以重新加载license信息。


\section{如何判断license有效}
\label{\detokenize{license:id6}}
适用版本：V8R3 , V8R6

问题描述：替换了license 后还是显示授权过期，更换另一个license就正常。

更换的license 需要比较以下几点：
\begin{quote}

1、 版本是否相同，包括：产品版本号、细分版本模板名。不同版本license不通用。

2、 数据库key值。如果换了license，但key值还是与原来相同，实际是同一个license文件，也就是实际没换。

3、 如果“浮动基准日期”是禁用的状态，到期日是“生产日期”+“有效期间”。如果“浮动基准日期”是启用的，到期日是license更换日期 +“有效期间”。

4、 License 例子如下：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=556\sphinxpxdimen,height=518\sphinxpxdimen]{{FAQ24011}.png}
\end{figure}
\end{quote}


\section{License与网卡}
\label{\detokenize{license:id7}}
适用版本：V8R3

问题描述：为什么部分R3版本无法识别bond开始的网卡？

问题解析：V8R3 B0261版本解决了网卡问题，可以识别所有网卡，而之前的版本只能识别e开头（不仅是eth开头的）的网卡。


\section{Bond网卡切换license支持问题}
\label{\detokenize{license:bondlicense}}
适用版本：V8R3 , V8R6新版本

问题描述：

问题分析：早期的license只提供一个license，如果网卡切换或者网卡更换


\chapter{扩展组件}
\label{\detokenize{extended-plug-in:id1}}\label{\detokenize{extended-plug-in::doc}}

\section{如何查看系统是否支持某组件}
\label{\detokenize{extended-plug-in:id2}}
适用版本：所有版本

问题描述：KES与原生PG不同，许多开源的组件不能直接在KES上使用，需要研发针对特定平台重新编译。如果用户想知道当前的版本自带或支持哪些组件，只需查询sys\_available\_extensions


\section{oracle\_fdw支持平台}
\label{\detokenize{extended-plug-in:oracle-fdw}}
适用版本：V8R6 , V8R6

目前只支持linux x86\_64


\section{create extension oracle\_fdw报.so找不到加载失败}
\label{\detokenize{extended-plug-in:create-extension-oracle-fdw-so}}
适用平台：{[}KESV8R2/3{]}

依赖oracle官方instantclient\sphinxhyphen{}basic\sphinxhyphen{}linux.x64\sphinxhyphen{}11.2.0.4.0.zip，目前推荐使用11.2版本，其他版本可能跟操作系统存在兼容问题，解决方法根据现场选择以下之一。

方法1（当机器上安装了>11.2的instantclient时推荐使用）：
\begin{quote}

解压后将so拷贝到kingbase安装后的lib目录下
\end{quote}

方法2（当机器上没有安装过instantclient时选用）：
\begin{quote}

解压到/usr/lib/路径下后执行ldconfig
\end{quote}


\section{oracle\_fdw支持功能}
\label{\detokenize{extended-plug-in:id3}}
基本的select insert delete， 简单的join


\section{Sys\_pathman}
\label{\detokenize{extended-plug-in:sys-pathman}}
问题描述: pathman\_config、pathman\_config\_params 删除后，如何重建？

问题解决：pathman\_config、pathman\_config\_params这两个表是sys\_pathman插件的表，想找回来可以drop extension之后再create extension; extension。


\section{Separate\_power}
\label{\detokenize{extended-plug-in:separate-power}}
问题描述: 需要开启审计日志，没有SYSSAO和SYSSSO用户，有什么解决办法吗

问题解决：create extensionSeparate\_power


\section{Sysaudit}
\label{\detokenize{extended-plug-in:sysaudit}}

\subsection{如何删除语句审计日志？}
\label{\detokenize{extended-plug-in:id4}}
语句审计日志可以通过视图sysaudit.sysaudit\_records查询。如果要删除语句审计记录，只需将移除\$KINGBASE\_DATA/aud目录下的文件。


\chapter{空间组件}
\label{\detokenize{gis:id1}}\label{\detokenize{gis::doc}}

\section{Create extension postgris 报错“GLIBC\_2.18 not defined in file libc.so.6”}
\label{\detokenize{gis:create-extension-postgris-glibc-2-18-not-defined-in-file-libc-so-6}}
适用版本：V8R3 , V8R6

问题描述：
\begin{quote}

create extension postgis，报错如下：无法加载库“postgis\sphinxhyphen{}2.5.si”: Server/lib/libstdc++.si.6: symbol \_\_cxa\_thread\_atexit\_impl, version GLIBC\_2.18 not defined in file libc.so.6 with link time reference
\end{quote}

问题分析：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
lddServer/lib/libstdc++.si.6 ，确认动态链接操作系统的 libc.so.6

\item {} 
strings libc.so.6 | grep GLIBC | more , 看到最高只到GLIBC\_2.17，也就是说操作系统自带的gcc版本不支持postgis\sphinxhyphen{}2.5。经验证，操作系统的gcc版本是4.8.5，而我们的编译环境的gcc版本是5.3.1，需要升级操作系统的gcc版本或根据底版本的gcc重新编译。

\end{enumerate}


\section{acgis版本备份还原}
\label{\detokenize{gis:acgis}}
适用版本：V8.3.1

问题描述：注意acgis备份还原不可将用户权限忽略，否则可能赵成acgis空间信息错乱，导致备份还原后acgis无法连接数据库。

注意sys\_restore时候，千万不可带\sphinxhyphen{}x参数。


\section{R6 是否支持超图}
\label{\detokenize{gis:r6}}
适用版本：V8R6

问题描述：RT

问题解答：R6 支持超图 10.1.1连接，但前提是必须要有postgis组件。


\chapter{系统管理类}
\label{\detokenize{system-management:id1}}\label{\detokenize{system-management::doc}}

\section{{[}KESV8R2/R3{]}表在指定表空间，为何显示为默认表空间？}
\label{\detokenize{system-management:kesv8r2-r3}}
1. 创建表空间 create tablespace testtb location '/home/kingbase/KingbaseES/tb\_dir';

2. 创建数据库指定表空间 create database testtb tablespace 'TESTTB';

3. 在数据库里创建表，且已存储到创建的表空间里 create table test2 (A int);

4. 查询物理存储select sys\_relation\_filepath('test2');

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SYS\PYGZus{}RELATION\PYGZus{}FILEPATH}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{n}{sys\PYGZus{}tblspc}\PYG{o}{/}\PYG{l+m+mi}{32785}\PYG{o}{/}\PYG{n}{SYS\PYGZus{}V008R002\PYGZus{}201608131}\PYG{o}{/}\PYG{l+m+mi}{32786}\PYG{o}{/}\PYG{l+m+mi}{32793}
\end{sphinxVerbatim}

5. 使用工具查看表空间显示错误，显示为默认表空间

6. 工具使用

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{select} \PYG{n}{TABLESPACE} \PYG{k+kn}{from} \PYG{n+nn}{sys\PYGZus{}tables} \PYG{n}{where} \PYG{n}{tablename} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TEST2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}

\PYG{n}{TABLESPACE}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}
\end{sphinxVerbatim}

解答：

   表的表空间显示0或空表示其表空间为所在库的表空间，也就是TEST2表默认为的表空间和TESTTB库一致，表空间为TESTTB。

   可以通过以下方式看到表的真实表空间：
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{TESTTB}\PYG{o}{=}\PYG{c+c1}{\PYGZsh{} select TABLESPACE\PYGZus{}NAME from user\PYGZus{}tables where table\PYGZus{}name = \PYGZsq{}TEST2\PYGZsq{};}

       \PYG{n}{TABLESPACE\PYGZus{}NAME}
\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}
 \PYG{n}{database} \PYG{n}{default} \PYG{n}{tablespace}
\PYG{p}{(}\PYG{l+m+mi}{1} \PYG{n}{row}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}


\section{为什么sys\_class里显示的很多表的 RELTABLESPACE值为 0？}
\label{\detokenize{system-management:sys-class-reltablespace-0}}
数据库创建时，可以指定表空间，如果没有指定数据库表空间，数据库默认表空间是 SYS\_DEFAULT

用户创建表时，如果没有指定表空间，则默认放在数据库所在的表空间，此时 RELTABLESPACE显示为 0。 也就是说  RELTABLESPACE = 0表示 relation所在的表空间是 sys\_database.DATTABLESPACE .


\section{KES有什么办法，默认不读取sys\_catalog下的系统视图？}
\label{\detokenize{system-management:kes-sys-catalog}}
客户业务表sys\_user和咋们系统视图sys\_user重名，客户反馈SQL中不能加模式名，URL加上currentSchema本地也试了不行。开发不愿意改代码只接受select * from sys\_user这么直接查

解答：
\begin{quote}

当Search\_path参数不含“sys\_catalog”时，在查询时，会自动将“sys\_catalog”加在search\_path最前面，这样，在有同名对象情况下，默认优先访问“sys\_catalog”下的对象。

修改kingbase.conf中的search\_path='"\$USER",PUBLIC,SYS\_CATALOG'，修改以后重启数据库就可以了（并java配置：嗯，URL中不加currentSchema测试可以了）
\end{quote}


\section{网线拔插后，IP丢失问题}
\label{\detokenize{system-management:ip}}
版本：所有版本

问题：手动拔掉网线，发现IP丢失，重新插入网线后，虽然网卡处于UP状态，但任然无法获得IP，需要手动运行 ifupeth0

分析：如果禁用NetworkManager服务，发现网线拔插后，网卡IP自动恢复。

注意：由于部分系统只有NetworkManager服务，而没有Network服务，如果禁用NetworkManager服务，将导致网络问题。


\chapter{工具类}
\label{\detokenize{tools:id1}}\label{\detokenize{tools::doc}}

\section{客户端连接找 .s.PGSQL.5432}
\label{\detokenize{tools:s-pgsql-5432}}
适用版本：所有版本

问题描述：
\begin{quote}

客户端连接报错如下

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=650\sphinxpxdimen,height=47\sphinxpxdimen]{{FAQ28490}.png}
\end{figure}
\end{quote}

问题分析：
\begin{quote}
\begin{itemize}
\item {} 
ksql 连接时，正常会去寻找 .s.KINGBASE.54321文件，这里却去找 PGSQL文件，说明了可能相关lib干扰了。

\item {} 
ldd ksql，确认libpq.so是否没有正确指向/opt/kb86/ES/V8/Server/lib目录，而是指向链接到其他目录。

\item {} 
确认LD\_LIBRARY\_PATH环境变量，确实包含第二步所指的“其他目录”。

\item {} 
修改LD\_LIBRARY\_PATH环境变量，去除“其他目录”，或者将/opt/kb86/ES/V8/Server/lib放于LD\_LIBRARY\_PATH 最前面

\end{itemize}

KES在编译时，会设置runpath，可以不设置LD\_LIBRARY\_PATH就能找到lib目录。但如果设置了LD\_LIBRARY\_PATH，LD\_LIBRARY\_PATH环境变量所指的路径优先级更高，这时可就会影响到数据库正常运行。
\end{quote}


\section{客户端管理工具无法加载ER图问题}
\label{\detokenize{tools:er}}
适用版本：所有版本

问题描述：客户端管理工具无法加载ER图

问题解决：
\begin{quote}

以下文件内容取自 ManagerTools/configuration/*/bundles.info

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=650\sphinxpxdimen,height=148\sphinxpxdimen]{{FAQ28979}.png}
\end{figure}

标注的这行，然后删掉configuration下，除了config.ini和bundles.info所在的目录以外的其他目录，再删掉安装目录下的.kingbase，重启工具。
\end{quote}

原因分析：
\begin{quote}

plugin下每一个com.kingbase开头的jar包对应着一个插件，加载插件的配置文件就是bundles.info，现场的环境没有加载erd那个插件，导致er图打开失败
\end{quote}


\section{如何修改管理工具client\_encoding}
\label{\detokenize{tools:client-encoding}}
适用版本：所有版本

问题描述：RT

问题解答：
\begin{quote}

manager连接数据库所使用的client\_encoding是通过ManagerTools/manager.ini设置的。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=510\sphinxpxdimen,height=128\sphinxpxdimen]{{FAQ29287}.png}
\end{figure}
\end{quote}


\section{迁移工具对于同名对象处理}
\label{\detokenize{tools:id2}}
适用版本：所有版本

问题描述：DTS从oracle迁移数据时，报错同名问题。

问题分析：对于oracle，同一schema下索引与表可以同名，但kingbase不允许。迁移工具在遇到同名时，会报错，需要用户手动处理。


\section{数据迁移报“invalid byte sequence for encoding "UTF8": 0x00 "}
\label{\detokenize{tools:invalid-byte-sequence-for-encoding-utf8-0x00}}
适用版本：V8R3 , V8R6

问题描述：如题

问题分析：0x00 是ascii 的0值，表示null，通过设置添加参数ignore\_char\_null\_check=on ， 避免空值检查。


\section{开始菜单没有数据库快捷工具图标}
\label{\detokenize{tools:id3}}
适用版本：V8R3 , V8R6

问题描述：
\begin{quote}

正确安装数据库后，切换到kingbase用户，开始菜单没有数据库快捷工具图标。/home/kingbase/.local/share/applications/下也没有快捷方式
\end{quote}

解决方式：
\begin{itemize}
\item {} 
把安装路径下/home/kingbase/ES/V8/desktop下的文件拷贝到/home/kingbase/.local/share/applications/

\item {} 
有的版本的操作系统，在安装完数据库软件后，需要注销，重新登录，才能看到开始菜单。

\end{itemize}


\section{缺少操作系统GUI组件}
\label{\detokenize{tools:gui}}
适用版本：所有版本

问题描述：KES以console安装报错，unable to load and prepare the installer in console

原因分析：
\begin{quote}

可能的原因是操作系统图形组件的缺失，需要安装相关组件。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{yum} \PYG{n}{install} \PYG{n}{gui}
\PYG{n}{yum} \PYG{n}{install} \PYG{n}{gnome}
\PYG{n}{yum} \PYG{n}{install} \PYG{n}{xorg}
\end{sphinxVerbatim}
\end{quote}


\section{R3客户端无法使用scram\sphinxhyphen{}sha\sphinxhyphen{}256认证}
\label{\detokenize{tools:r3scram-sha-256}}
适用版本：V8R3

问题描述：JDBC驱动连接数据库时，报错如下：提示“The authentication type 10 is not supported. Check that you have configured the sys\_hba.conf file to include the client's IP address or subnet, and that it is using an authentication scheme supported by the driver.”

问题解答：R3 的驱动无法使用scram\sphinxhyphen{}sha\sphinxhyphen{}256 认证，只能使用MD5认证


\section{undefined symbol: PqgssEncInUse}
\label{\detokenize{tools:undefined-symbol-pqgssencinuse}}
适用版本：V8R6

问题描述：
\begin{quote}

运行ksql报错：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} ksql \PYGZhy{}Usystem \PYGZhy{}dtest \PYGZhy{}p36521 \PYGZhy{}h172.16.24.240
ksql (V008R006C002B0016)
ksql: symbol lookup error: ksql: undefined symbol: PqgssEncInUse
\end{sphinxVerbatim}
\end{quote}

问题解答：通常是LD\_LIBRARY\_PATH环境变量设置问题。


\section{Bulkload并行加载报错}
\label{\detokenize{tools:bulkload}}
适用版本：V7

问题描述：Bulkload并行加载报错，ERROR:  parallel threads initilization failed

问题分析：bulkload并行导入数据，需要在数据库的配置文件kingbase.conf中修改参数max\_work\_threads.如果没有，添加到配置文件。

例如：max\_work\_threads=16


\chapter{数据安全}
\label{\detokenize{data-security:id1}}\label{\detokenize{data-security::doc}}

\section{Sys\_rman备份报“current time may be rewound”}
\label{\detokenize{data-security:sys-rmancurrent-time-may-be-rewound}}
适用版本：V8R3

原因分析：数据库初始化后，系统往回修改了时间（从2029年改回2020年），备份时由于存在比当前时间之后的数据库对象，导致备份失败。

处理：使用sys\_dump 导出、导入后，sys\_rman 备份正常。


\section{如何导出一致时间点的数据}
\label{\detokenize{data-security:id2}}
适用版本：V8R3 ， V8R6

问题描述：默认sys\_dump 导出的数据是表级的一致性，也就是对表发出copy命令时间点已提交的数据，但由于不同表copy时间点不同，因此，sys\_dump导出的数据不是完全一致时间点。如何导出一致时间点数据？

解决方法：
\begin{quote}

Session A: sys\_export\_snapshot实际返回的是当前事务ID，实际可以不需要isolation level repeatable read。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=125\sphinxpxdimen]{{FAQ31140}.png}
\end{figure}

Session B: sys\_dump \sphinxhyphen{}\sphinxhyphen{}snapshot=00000806\sphinxhyphen{}1

Session A: 结束事务

\begin{sphinxadmonition}{note}{Note:}
Sesssion B 导出的是Session A 运行sys\_export\_snapshot时间点已提交的数据，即使在导出过程中其他会话对数据库进行了修改并提交。
\end{sphinxadmonition}
\end{quote}


\section{索引问题导致数据访问问题}
\label{\detokenize{data-security:id3}}
版本：V8R3

问题原因：系统在进行压力测试，同时系统主备切换。主备间采取异步方式

问题现象：
\begin{quote}

可以看到，根据条件返回的记录数据与where条件不匹配。这3个条件是主键。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=299\sphinxpxdimen]{{FAQ31384}.png}
\end{figure}
\end{quote}

解决方案：rebuild index

原因分析：
\begin{quote}

1. 这条SQL采取的是索引访问；

2. 根据索引取得两个ctid，再根据ctid取得数据；

3. 通过访问表记录的xmax ，确定记录是有效的（未被删除）；

4. 问题1：为什么索引entry的值（4,3,2521）与table tuple（7,5,998）值不一致？索引通过ctid与table tuple关联，当索引异常时，就可能出现该问题。

5. 问题2：既然是主键，索引entry为什么会出现两个entry？索引是没有有效性判断的，需要访问表进行判断，也就是说就算索引存在两个相同entry，理论上通过tuple有效判断后最多只能留1条。
\end{quote}


\chapter{TPCC测试类}
\label{\detokenize{TPCC-test:tpcc}}\label{\detokenize{TPCC-test::doc}}

\section{tpcc测试中是否需要开启autovacuum}
\label{\detokenize{TPCC-test:tpccautovacuum}}
在tpcc运行时间小于30分钟的时候禁用该参数，tpcc测试大于30分钟的时候需要开启。


\section{index\_cursor\_id参数的数值是固定的么？}
\label{\detokenize{TPCC-test:index-cursor-id}}
不是固定的，在tpcc测试中需要每次到数据库中查询到该参数的数值，然后配置到参数文件中，查询语句是

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{select} \PYG{n}{oid} \PYG{k+kn}{from} \PYG{n+nn}{sys\PYGZus{}class} \PYG{n}{where} \PYG{n}{relname} \PYG{n}{like}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ bmsql\PYGZus{}new\PYGZus{}order\PYGZus{}pkey}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{;}
\end{sphinxVerbatim}


\section{在tpcc测试中unixdomain作用是？}
\label{\detokenize{TPCC-test:tpccunixdomain}}
Unix domain socket 或者 IPC socket是一种终端，可以使同一台操作系统上的两个或多个进程进行数据通信。与管道相比，Unix domain socket既可以使用字节流，又可以使用数据队列，而管道通信则只能使用字节流。

Unix domain socket的接口和Internet socket很像，但它不使用网络底层协议来通信。Unix domain socket 的功能是POSIX操作系统里的一种组件。Unix domain socket 使用系统文件的地址来作为自己的身份。它可以被系统进程引用。所以两个进程可以同时打开一个Unix domain sockets来进行通信。不过这种通信方式是发生在系统内核里而不会在网络里传播。


\section{集群环境下测试tpcc连接参数怎样配置？}
\label{\detokenize{TPCC-test:id1}}
集群环境下连接参数和非集群环境一样。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{driver}\PYG{o}{=}\PYG{n}{com}\PYG{o}{.}\PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{Driver}
\PYG{n}{conn}\PYG{o}{=}\PYG{n}{jdbc}\PYG{p}{:}\PYG{n}{kingbase8}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mf}{127.0}\PYG{o}{.}\PYG{l+m+mf}{0.1}\PYG{p}{:}\PYG{l+m+mi}{54888}\PYG{o}{/}\PYG{n}{BENCHMARKSQL}
\PYG{n}{user}\PYG{o}{=}\PYG{n}{BENCHMARKSQL}
\PYG{n}{password}\PYG{o}{=}\PYG{l+m+mi}{123456}
\end{sphinxVerbatim}


\chapter{接口}
\label{\detokenize{interface:id1}}\label{\detokenize{interface::doc}}

\section{JDBC接口}
\label{\detokenize{interface/jdbc:jdbc}}\label{\detokenize{interface/jdbc::doc}}

\subsection{JDBC打开日志方式}
\label{\detokenize{interface/jdbc:id1}}
JDBC驱动支持控制日志打印级别和日志输出到文件或者控制台。

日志级别：loggerLevel = 日志级别  指定日志记录级别。例如："OFF", "INFO", "DEBUG", "TRACE"，默认值是null即不输出日志。

日志输出：loggerFile = 日志文件名字

指定日志信息保存文件或者console 输出：
\begin{quote}

1：如果没有指定loggerFile，表示不生成JDBC日志文件,日志信息全部打印到当前console输出。

2：如果loggerFile有指定路径，则只打印到文件。例如：LogFile=e:\textbackslash{}logFile.txt，默认值是null。这个路径可以是相对路径，也可以是绝对路径。
\end{quote}


\subsection{没有VIP情况下，JDBC连接如何配置？}
\label{\detokenize{interface/jdbc:vip-jdbc}}
JDBC驱动通过IP，端口，数据库名，用户名，密码来连接数据库，没有VIP情况下，就配置数据库的集群所有主机实际的地址。

配置文件的内容在开始配置后不会变更，连接成功后，驱动会给数据库发送查询语句来判断当前配置的主机是否是主机，不是的话回去更新主备机的记录，但这个是记录在驱动的内部的，不会去写配置文件。

jdbc不支持自带连接池，客户可以使用第三方连接池，如druid，c3p0,dbcp等


\subsection{V8R6 JDBC能否使用VIP？}
\label{\detokenize{interface/jdbc:v8r6-jdbcvip}}
不能使用vip。

jdbc.conf文件有 host和 slave\_add项，表示主、备节点。比如，初始配置 host=VIP，而VIP是飘移的，如果VIP飘移到备机，那相当于集群少了一台主机（原主机“不见”了）


\subsection{LOB对象update机制}
\label{\detokenize{interface/jdbc:lobupdate}}
应用SQL：1条语句，update GA\_MSGS set "MSG\_BODY"=\$1 where MSG\_ID ='\$2'。

数据库日志捕获SQL为:大约50条，update GA\_MSGS set "MSG\_BODY"=\$1 where "CTID"=\$2 and  "XMIN"= \$3 returning CTID,XMIN;

尝试ksql执行update GA\_MSGS set "MSG\_BODY"=\$1 where MSG\_ID = '\$2'，数据库日志捕获为1条update GA\_MSGS set "MSG\_BODY"=\$1 where MSG\_ID = '\$2'，未发生变化。

是java驱动转化了SQL语句吗，另外50条update语句中的blob字段参数值，是一个不断增长的过程，每自动更新下一次，参数值会补充一断新的值。

日志分析：
\begin{quote}

1、应用没有这种SQL，是JDBC接口自动转换的。

2、每次update操作  "CTID"=\$2 and  "XMIN"= \$3参数值 ctid每次增加 1，xmin都是相同的。

3、库日志中的update语句blob参数\$1，目前看着符合规律，继承之前的参数变得越来越长，比如第一次a，第二次ac，第三次acb，第四次acbd…
\end{quote}

结论：
\begin{quote}

用select ... for update，查询大对象，然后用大对象的set方法（如blob.setBytes）设置大对象的值时，驱动实际执行了一条update语句，这条update语句是驱动构造的。

因为R3的大对象实际是bytea和text，数据都是写在用户表里的，内容都是一次写过去的。

如果应用本身是update语句，驱动不会去修改语句，只有通过大对象的方法去写大对象才会生成该语句。

这个write方法每次调用一次就会调用update语句写一次，Blob实际是bytea，没法分片写，所以实际blob内容是缓存在本地的，每次添加内容，都会在原来的内容上加上新的内容更新一次。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=416\sphinxpxdimen]{{jdbc-33958}.png}
\end{figure}
\end{quote}


\subsection{KBBlob 迁移至Oracle}
\label{\detokenize{interface/jdbc:kbblob-oracle}}
适用版本：所有版本

问题描述：用户将BLOB从Kingbase迁移至Oracle，报错如下：“kblob cannot be cast to oracle.sql.blob”

问题分析：KBBlob 不支持迁移至Oracle Blob，只能是Oracle Blob迁移至KBBlob


\subsection{JDBC的jar包需要区分JDK版本，需要区分OS和CPU平台吗？}
\label{\detokenize{interface/jdbc:jdbcjarjdk-oscpu}}
适用版本：V8R2

问题分析：JDBC目前编译时，是根据JDK环境编译的jar包。所以请使用时检查应用的JDK环境。V82的JDBC驱动支持Oracle 1.6，1.7，1.8 和OpenJDK 1.6,1.7,1.8

兼容度：低版本JDK环境编译的jar包可以运行在高版本的JDK环境下，反之则不行。
JAVA程序编译出来都是class文件的中间码(运行在JVM虚拟机上)，不是机器码所以不区分OS和CPU，只区分JDK环境。所以正常来说只需要保证JDK的版本匹配即可。


\subsection{JDBC的连接参数只能通过URL串来填写吗？}
\label{\detokenize{interface/jdbc:jdbcurl}}
适用版本：V8R2

问题描述：JDBC的连接参数只能通过URL串来填写吗？

问题分析：不是，除了ConfigurePath外，其它也可用配置文件方式。JDBC的可选的连接串参数是比较多的，当你需要的参数较多时都写在连接串上显得比较笨拙，为了方便现场人员运维管理，新提供了JDBC配置文件的方式来配置参数。


\subsection{如何使用JDBC配置文件方式？}
\label{\detokenize{interface/jdbc:id2}}
适用版本：V8R2

问题分析：JDBC是否使用配置文件，是通过连接串参数ConfigurePath控制。当你ConfigurePath=jdbc.conf时，会优先使用配置文件里的参数。如果没有ConfigurePath参数，就只使用URL连接串中的参数。


\subsection{JDBC读写分离怎么打开关闭?}
\label{\detokenize{interface/jdbc:id3}}
适用版本：V8R2

问题分析：JDBC是否使用读写分离功能,通过USEDISPATCH控制。USEDISPATCH=true时就会使用读写分离功能进行分发。USEDISPATCH=false，或者不写这个参数时，就使用原JDBC单机方式。


\subsection{JDBC 读写分离都需要配置哪些参数？}
\label{\detokenize{interface/jdbc:id4}}
适用版本：V8R2

一般情况下，只需额外5个参数来控制。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}打开读写分离功能，}
\PYG{n}{USEDISPATCH}\PYG{o}{=}\PYG{n}{true}
\PYG{c+c1}{\PYGZsh{}备机地址}
\PYG{n}{SLAVE\PYGZus{}ADD}\PYG{o}{=}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{8.223}\PYG{p}{,}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{8.130}
\PYG{c+c1}{\PYGZsh{}备机端口}
\PYG{n}{SLAVE\PYGZus{}PORT}\PYG{o}{=}\PYG{l+m+mi}{54321}\PYG{p}{,}\PYG{l+m+mi}{54321}
\PYG{c+c1}{\PYGZsh{}主机读负载率，备机之间轮询平分，取值范围0\PYGZhy{}100,例如0表示读语句全部分发备机，100表示读语句全部发送主机}
\PYG{n}{HOSTLOADRATE}\PYG{o}{=}\PYG{l+m+mi}{33}
\PYG{c+c1}{\PYGZsh{}底层socket receive的超时时间}
\PYG{n}{socketTimeout}\PYG{o}{=}\PYG{l+m+mi}{10}
\PYG{c+c1}{\PYGZsh{}是否使用连接池缓存连接}
\PYG{n}{USECONNECT\PYGZus{}POOL}\PYG{o}{=}\PYG{n}{false}
\end{sphinxVerbatim}


\subsection{JDBC读写分离一主两备的URL和配置文件的样例}
\label{\detokenize{interface/jdbc:id5}}
适用版本：V8R2

1：只用连接串,开启JDBC读写分离 一主两备：

URL

\begin{sphinxVerbatim}[commandchars=\\\{\}]
jdbc:kingbase8://192.168.8.128:54321/TEST?USEDISPATCH=true\PYGZam{}SLAVE\PYGZus{}ADD=192.168.8.223,192.168.8.130\PYGZam{}SLAVE\PYGZus{}PORT=54321,54321\PYGZam{}HOSTLOADRATE=33\PYGZam{}USECONNECT\PYGZus{}POOL=false
\end{sphinxVerbatim}

2：连接串+配置文件,开启JDBC读写分离 一主两备：

URL

\begin{sphinxVerbatim}[commandchars=\\\{\}]
jdbc:kingbase8://192.168.8.128:54321/TEST?ConfigurePath=jdbc.conf
\end{sphinxVerbatim}

配置文件

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{USEDISPATCH}\PYG{o}{=}\PYG{n}{true}
\PYG{n}{SLAVE\PYGZus{}ADD}\PYG{o}{=}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{8.223}\PYG{p}{,}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{8.130}
\PYG{n}{SLAVE\PYGZus{}PORT}\PYG{o}{=}\PYG{l+m+mi}{54321}\PYG{p}{,}\PYG{l+m+mi}{54321}
\PYG{n}{HOSTLOADRATE}\PYG{o}{=}\PYG{l+m+mi}{33}
\PYG{n}{socketTimeout}\PYG{o}{=}\PYG{l+m+mi}{10}
\PYG{n}{USECONNECT\PYGZus{}POOL}\PYG{o}{=}\PYG{n}{false}
\end{sphinxVerbatim}

3：目前读写分离实际项目中用到的配置文件参数样例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}主机地址}
\PYG{n}{HOST}\PYG{o}{=}\PYG{l+m+mf}{121.1}\PYG{o}{.}\PYG{l+m+mf}{20.3}
\PYG{n}{PORT}\PYG{o}{=}\PYG{l+m+mi}{54321}
\PYG{n}{DBNAME}\PYG{o}{=}\PYG{n}{NPC}
\PYG{n}{user}\PYG{o}{=}\PYG{n}{RDWWpom}

\PYG{n}{password}\PYG{o}{=}\PYG{n}{RDWW123456}
\PYG{c+c1}{\PYGZsh{}loggerLevel can be OFF, INFO, DEBUG, TRACE}
\PYG{n}{loggerLevel}\PYG{o}{=}\PYG{n}{OFF}
\PYG{n}{loggerFile}\PYG{o}{=}\PYG{n}{jdbc\PYGZus{}test}\PYG{o}{.}\PYG{n}{log}
\PYG{n}{preferQueryMode}\PYG{o}{=}\PYG{n}{extendedForPrepared}
\PYG{c+c1}{\PYGZsh{}是否使用读写分离功能}
\PYG{n}{USEDISPATCH}\PYG{o}{=}\PYG{n}{true}
\PYG{n}{HOSTLOADRATE}\PYG{o}{=}\PYG{l+m+mi}{33}
\PYG{c+c1}{\PYGZsh{}备机地址}
\PYG{n}{SLAVE\PYGZus{}ADD}\PYG{o}{=}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{8.220}\PYG{p}{,}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{8.221}
\PYG{n}{SLAVE\PYGZus{}PORT}\PYG{o}{=}\PYG{l+m+mi}{54321}\PYG{p}{,}\PYG{l+m+mi}{54321}
\PYG{c+c1}{\PYGZsh{}是否使用连接池缓存连接}
\PYG{n}{USECONNECT\PYGZus{}POOL}\PYG{o}{=}\PYG{n}{false}
\PYG{n}{CONNECT\PYGZus{}POOLSIZE}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{c+c1}{\PYGZsh{}在新建连接时检查当前连接DB是不是Master,如果不是回去slave检查有没有Master,如果还是找不到Master就会向上报错}
\PYG{n}{MASTER\PYGZus{}CHECK}\PYG{o}{=}\PYG{n}{true}
\PYG{c+c1}{\PYGZsh{}失败重发的最高次数}
\PYG{n}{RETRYTIMES}\PYG{o}{=}\PYG{l+m+mi}{10}
\PYG{c+c1}{\PYGZsh{}失败重发每次的间隔时间（单位：秒）}
\PYG{n}{RETRYINTERVAL}\PYG{o}{=}\PYG{l+m+mi}{5}
\PYG{c+c1}{\PYGZsh{}开启集群备机监测线程定时监测集群备机状态}
\PYG{n}{CLUSTER\PYGZus{}MONITOR}\PYG{o}{=}\PYG{n}{true}
\PYG{c+c1}{\PYGZsh{}监测线程每次监测的间隔时间（单位：秒）}
\PYG{n}{MONITORINTERVAL}\PYG{o}{=}\PYG{l+m+mi}{5}
\PYG{c+c1}{\PYGZsh{}指定底层socket receive的超时时间，值可以为任意正整数，“0”表示没有超时，一直等，直到返回，默认取值为：“0”（单位：秒）}
\PYG{c+c1}{\PYGZsh{}socketTimeout=10}
\PYG{c+c1}{\PYGZsh{}指定Socket做connect时的超时时间，默认取值为：“10”（单位：秒）}
\PYG{c+c1}{\PYGZsh{}connectTimeout=10}
\end{sphinxVerbatim}


\subsection{JDBC连接池功能，是否开启，开启后的功能及性能}
\label{\detokenize{interface/jdbc:id6}}
适用版本：V8R2

问题分析：
\begin{quote}

如果应用已经有了连接池，就不开启JDBC连接池，因为连接池需要锁来管理全局队列，高并发建连接会有性能损耗。

如果应用没有连接池，可以开启JDBC连接池，因为频繁建连接时很耗时的行为。开启连接池可以降低应用频繁建连接的损耗。

JDBC连接池功能限制：JDBC连接池只是为了读写分离测试性能时使用，只支持相同用户的连接。如果是不同用户的连接，不要使用，会有模式混乱问题。
\end{quote}


\subsection{JDBC读写分离配置参数依赖关系}
\label{\detokenize{interface/jdbc:id7}}
适用版本：V8R2

关于JDBC 读写分离配置项的依赖关系：
\begin{description}
\item[{USEDISPATCH=false}] \leavevmode
\#是否使用读写分离功能,此配置项关闭JDBC就变成单机JDBC，无读写分离功能。

\item[{MASTER\_CHECK=true}] \leavevmode
\#在新建连接时检查当前连接DB是不是Master,如果不是会去slave节点中检查有没有新升级的Master,如果还是找不到Master节点就会向上报错。（此功能开启需要同时开启读写分离功能）。

\item[{USECONNECT\_POOL=false}] \leavevmode
\#是否使用连接池缓存连接，此功能开启需要同时开启读写分离功能。（此功能开启需要同时开启读写分离功能）。

\item[{MASTER\_CHECK=true}] \leavevmode
\#在新建连接时检查当前连接DB是不是Master,如果不是回去slave检查有没有Master,如果还是找不到Master就会向上报错。（此功能开启需要同时开启读写分离功能）。

\item[{RETRYTIMES=10}] \leavevmode
\#连接异常问题造成的语句执行失败情况下，重建连接并重发的最高重试次数（0\textasciitilde{}100）。（此功能开启需要同时开启读写分离功能）

\item[{RETRYINTERVAL=10}] \leavevmode
\#失败时重建连接并重发的每次的间隔时间（单位：秒）。（此功能开启需要重试次数大于0）

\item[{CLUSTER\_MONITOR=true}] \leavevmode
\#开启集群备机监测线程定时监测集群备机状态，更新全局备机信息（无锁）。（此功能开启需要同时开启读写分离功能）。

\item[{MONITORINTERVAL=5}] \leavevmode
\#备机监测线程每次查询备机信息的间隔时间（单位：秒）。（此功能开启需要同时开启读写分离功能）。

\item[{TransactionDispatchStrategy=2}] \leavevmode
\#事务中语句的分法策略，1表示事务中的所有语句都不分发，默认是2 表示事务中遇到写语句之前的读语句可以分发。（此功能开启需要同时开启读写分离功能）。

\end{description}


\subsection{JDBC读写分离在哪些情况下重发也不会成功}
\label{\detokenize{interface/jdbc:id8}}
适用版本：V8R2

JDBC支持切机本意就是指尽量让应用的语句不因为切机造成执行失败，让应用对切机无感知。对于单事务语句基本都可以重发成功。

但是并不是所有的语句都可以重发成功。
\begin{itemize}
\item {} 
涉及连接会话上下文的情况。

\item {} 
游标：cursor，refcursor切机后全部丢失，重发不能成功。

\item {} 
事务：切机后连接全部都断掉了，事务回退失败，不能重发。

\item {} 
结果集遍历：和游标类似，重发不能成功。

\item {} 
批量执行。

\end{itemize}


\subsection{JDBC读写分离分发策略}
\label{\detokenize{interface/jdbc:id9}}
适用版本：V8R2

读语句分发，分两种情况：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
单语句事务，这种情况下每条语句都是一个独立的事务，所以读语句分发备机没有问题

\item {} 
多语句事务，这种情况下，读语句处于事务内，分发需要考虑事务隔离级别，V82支持的三种隔离级别：可重复读，读提交，序列化。严格意义上这三种都不允许读语句分发，因为可能出现不可重复读或者读不到已提交的内容。

\end{enumerate}

但是如果事务内的语句就不分发的话，读写分离就失去大半意义了，因为无论是应用还是框架基本上都是用事务控制的，所以JDBC提供一个分发策略参数控制，

TransactionDispatchStrategy可以选择分发策略：（性能优先，默认是2）
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
事务内的所有语句都只发主机，完全不分发备机。

\item {} 
事务内遇到写语句之前的读语句，可以分发备机，遇到写语句之后就只发主机。

\end{enumerate}


\subsection{JDBC读写分离相关参数默认值}
\label{\detokenize{interface/jdbc:id10}}
适用版本：V8R2
\begin{description}
\item[{loggerLevel=OFF}] \leavevmode
\#默认 OFF，可用参数OFF, DEBUG, TRACE

\item[{loggerFile=jdbc\_test.log}] \leavevmode
\#默认 null，日志文件名，可以是相对路径，也可以是绝对路径，如果默认null就是不生成日志文件

\item[{preferQueryMode=extendedForPrepared}] \leavevmode
\#默认 extend，可用参数simple，extend，extendedForPrepared

\item[{socketTimeout=10}] \leavevmode
\#默认 0（没有超时，一直等，直到返回），单位是秒，可选值为任意正整数，控制底层socket receive的超时时间。次参数设置取决于应用的超时控制机制，如果应用有自己的超时控制比较好，能够自己控制对端不在线而造成的socket receive一直等待的时间，这个值可以设0完全让应用去控制超时时间。但是如果应有没有超时控制或者控制的不好，只要JDBC不返回，应用不能自己根据超时返回，一直阻塞，那就需要设置这个超时时间，一般设置为该应用查询语句正常返回的最长返回时间。

\item[{USEDISPATCH=true}] \leavevmode
\#默认 false，用来控制是否使用读写分离功能

\item[{HOSTLOADRATE=33}] \leavevmode
\#默认 0，用来控制主机读负载率

\item[{SLAVE\_ADD=192.168.8.228,192.168.8.229}] \leavevmode
\#备机地址
\#默认 null

\item[{SLAVE\_PORT=54321,54321}] \leavevmode
\#默认 null

\item[{USECONNECT\_POOL=false}] \leavevmode
\#是否使用连接池缓存连接
\#默认 false，开启连接池

\item[{CONNECT\_POOLSIZE=100}] \leavevmode
\#默认 10个连接

\item[{MASTER\_CHECK=true}] \leavevmode
\#在新建连接时检查当前连接DB是不是Master,如果不是回去slave检查有没有Master,如果还是找不到Master就会向上报错
\#默认 true

\item[{RETRYTIMES=10}] \leavevmode
\#失败重发的最高次数
\#默认 10 次

\item[{RETRYINTERVAL=5}] \leavevmode
\#失败重发每次的间隔时间（单位：秒）
\#默认 5 秒

\item[{CLUSTER\_MONITOR=true}] \leavevmode
\#开启集群备机监测线程定时监测集群备机状态
\#默认 开启

\item[{MONITORINTERVAL=5}] \leavevmode
\#监测线程每次监测的间隔时间（单位：秒）
\#默认 50秒

\item[{TransactionDispatchStrategy =2  默认是2}] \leavevmode
\#事务内语句分发策略，提供两种策略选择
\#1：事务内语句全都不分发，只发给主机。2：事务内遇到写语句之前读语句可以分发

\end{description}


\subsection{集群状态正常，sockettimeout设置大于0时，为什么执行时间超长的事物会失败并导致jdbc重建连接？}
\label{\detokenize{interface/jdbc:sockettimeout0-jdbc}}
适用版本：V8R2

sockettimeout是控制底层socket超时返回的最长时间，默认是0，即没有超时。如果指定大于0的值，意思就是最多等待sockettimeout的时间socket的receive操作就会返回，这主要是用来防止当server掉线时，client端socket的receive操作会一直等待。但是这会带来副作用，就是如果一条语句真的执行很长时间超过了sockettimeout的值时，会被认为是超时而中断receive返回超时错误，如果是在读写分离状态下，超时会造成重建连连接重发语句。一条语句如果是因为大于设置的socketTimeout而超时退出，那么应用需等待（socketTimeout * （RETRYTIMES + 1）+ RETRYINTERVAL * RETRYTIMES）才会收到异常。此时需要根据用户的语句最长执行时间来设置sockettimeout或者设置为0一直等待。

如果应用自己有防这种JDBC操作一直不返回的机制，JDBC调用不返回，应用会有自己的超时控制，那就不需要JDBC设置soc kettimeout，让应用自己控制超时时间就好。

如果应用没有这种防呆机制，一个JDBC操作不返回就会造成应用完全卡死，那就需要设置JDBC的sockettimeout值，让JDBC来控制超时时间。


\subsection{主备切换后，备机rewind，或者备机故障后，备机恢复时为什么 备机的连接数是持续上升，而不是一次性全部建好？}
\label{\detokenize{interface/jdbc:rewind}}
适用版本：V8R2

主备切换后，连接不是马上就全部建立起来的，而是应用确实调用到JDBC时，JDBC才会去判断集群是否切换了，重建连接，重发语句执行。所以连接数是恢复速度和应用的操作JDBC负荷有关，通常是慢慢建立起来的，备机的连接会稍滞后于主机连接恢复速度，因为切机重发时，都是只要能找到新的主机就可以重发成功了，不会等到所有备机重启完成。只有等到下一次发送语句触发备机时，JDBC才会去检测备机是否已经起来了，如果是才会重建备机连接。


\subsection{主机切机后，应用第一次登陆WEB慢，JDBC等待时间分析}
\label{\detokenize{interface/jdbc:web-jdbc}}
适用版本：V8R2
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
局域网内 测试拔网线切机
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumii}{enumiii}{}{)}%
\item {} 
集群的新主机起来可连接后\sphinxhyphen{}>

\item {} 
应用用户登录WEB\sphinxhyphen{}>

\item {} 
使用连接池中已经有的JDBC连接(主机的连接都已经失效，备机的连接在rewind之前都还有效) \sphinxhyphen{}>

\item {} 
发送SQL \sphinxhyphen{}>

\item {} 
(I/O Error 20秒)收到错误返回 \sphinxhyphen{}>

\item {} 
重建JDBC连接 （sleep 5秒）\sphinxhyphen{}>

\item {} 
(在线0.1秒返回)+(不在线的需要10秒返回) \sphinxhyphen{}>

\item {} 
重建连接完成开始执行登陆SQL返回，总计35秒左右。

\end{enumerate}

\item {} 
其中 (不在线的需要10秒返回) 这个可以通过connectTimeout 参数控制connect超时时间，默认是10秒。

\end{enumerate}
\begin{quote}

其中 (sleep 5秒) 这个可以通过RETRYINTERVAL参数控制重建连接的间隔时间，默认是5秒。

其中 (I/O Error 20秒) 这个可以通过socketTimeout参数控制receive的超时时间，默认是0无限等待。
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
备机的连接不是马上断掉，而是在一段时间内都还可以使用，等到rewind时连接才会全部断掉。

\end{enumerate}


\subsection{JDBC打开日志方式}
\label{\detokenize{interface/jdbc:id11}}
适用版本：V8R2

JDBC驱动支持控制日志打印级别和日志输出到文件或者控制台。

\sphinxstylestrong{日志级别：}
\begin{description}
\item[{loggerLevel = 日志级别}] \leavevmode
指定日志记录级别。例如："OFF", "INFO", "DEBUG", "TRACE"，默认值是null即不输出日志。通常读写分离将日志开启到INFO，单机将日志开到TRACE。

\end{description}

\sphinxstylestrong{日志输出：}
\begin{description}
\item[{loggerFile = 日志文件名字}] \leavevmode
\sphinxstylestrong{指定日志信息保存文件或者console 输出：}
\begin{itemize}
\item {} 
如果没有指定loggerFile，表示不生成JDBC日志文件,日志信息全部打印到当前console输出。

\item {} 
如果loggerFile有指定路径，则只打印到文件。例如：loggerFile=e:\textbackslash{}logFile.txt，默认值是null。这个路径可以是相对路径，也可以是绝对路径。

\end{itemize}

\end{description}


\subsection{JDBC 报错：无效的 "UTF8" 编码字节顺序}
\label{\detokenize{interface/jdbc:jdbc-utf8}}
适用版本：V8R2

V82早期版本的JDBC默认都是UTF8编码的，需要设置client\_Encoding=GBK来指定客户端编码。这个参数现在已经变更为clientEncoding

V82目前版本的JDBC 默认都是获取系统默认编码，自动设置为系统的clientEncoding，绝大多数情况下是不需要用户再自己指定这个参数的。


\subsection{系统JVM和应用和JDBC和数据库编码之间的关系}
\label{\detokenize{interface/jdbc:jvmjdbc}}
适用版本：V8R2

\sphinxstylestrong{乱码的问题通常都是编码不一致导致。}

\sphinxstylestrong{分析步骤}

第一 落实应用的编码是什么。需要询问应用的开发人员。

第二 落实JVM的file.encoding 是什么？一般Windows环境是GBK，linux是UTF8。

第三 如果应用的编码和JVM的file.encoding一致，JDBC默认使用JVM的编码，不需要额外指定clientEncoding参数。否则需要指定JVM的\sphinxhyphen{}Dfile.encoding=GBK或者JDBC的clientEncoding参数。

第四 如果还是报无效编码错误，就把JDBC日志打开到INFO或者TRACE，确认连接串信息对不对，再去看日志里是否有乱码数据。

\sphinxstylestrong{编码解释}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
系统JVM的默认编码：file.encoding 通常和操作系统默认编码一样。当然用户可以同过jvm参数\sphinxhyphen{}Dfile.encoding=UTF8 来手动指定期望的编码格式。JDK1.7及以上的可以通过命令java \sphinxhyphen{}XshowSettings:properties –version 产看jvm参数值。

\item {} 
应用的编码：应用开发的时候自己指定的编码格式。通常应用的编码是要和运行环境的jvm的file.encoding保持一致。

\item {} 
JDBC的编码：JDBC通过参数clientEncoding指定编码格式，包括JDBC发给数据库的内容和返回给应用的内容都是按clientEncoding编码。通常需要和应用的编码保持一致。

\item {} 
数据库的编码：

\end{enumerate}
\begin{itemize}
\item {} 
client\_encoding 就是客户端编码，JDBC通过clientEncoding指定。

\item {} 
server\_encoding 就是服务端编码，这个是数据库自身存储时的编码。

\end{itemize}


\subsection{V7 V8 JDBC 混用问题}
\label{\detokenize{interface/jdbc:v7-v8-jdbc}}
适用版本：V8R2

V8的JDBC 连接 V7的数据库出现的错误:
\begin{quote}

com.kingbase8.util.KSQLException: FATAL: 3 在参数 "extra\_float\_digits" (\sphinxhyphen{}15 .. 2)的有效范围之外
\end{quote}

V7的JDBC 连接 V8的数据库出现的错误：
\begin{quote}

{[}KingbaseES JDBC Driver{]}不能与数据库建立连接: 不支持的前端协议 3.3: 服务端支持 1.0 到 3.0。
\end{quote}


\subsection{JDBC读写分离模式混淆找不到表}
\label{\detokenize{interface/jdbc:id12}}
适用版本：V8R2

如果是开启读写分离的，可能是开启了JDBC连接池，目前JDBC连接池只支持相同的URL相同用户的连接，不支持多用户名。

解决办法关闭JDBC连接池指定连接参数 USECONNECT\_POOL=false 即可


\subsection{JDBC读写分离日志分析办法}
\label{\detokenize{interface/jdbc:id13}}
适用版本：V8R2

常用的JDBC日志的命令：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
比如我要看一个线程的日志，假如131 是线程ID，

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grep} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{[131}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{.}\PYG{o}{/}\PYG{n}{jdbc\PYGZus{}new}\PYG{o}{.}\PYG{n}{log} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{131.}\PYG{n}{log}
\end{sphinxVerbatim}

这样就能看到131线程的完整JDBC日志，这样就能看到这个线程都干了什么事情，反推应用的业务逻辑。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
比如我要看 131这个线程里的所有执行语句

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grep} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{consume time}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{.}\PYG{o}{/}\PYG{l+m+mf}{131.}\PYG{n}{log} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{131}\PYG{n}{\PYGZus{}consume}\PYG{o}{.}\PYG{n}{log}
\end{sphinxVerbatim}

这个日志就是这个线程里执行的全部的SQL是什么和SQL执行的时间。

例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{11}\PYG{p}{:}\PYG{l+m+mi}{17}\PYG{p}{:}\PYG{l+m+mi}{29}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{114}\PYG{p}{]} \PYG{p}{[}\PYG{n}{com}\PYG{o}{.}\PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{dispatcher}\PYG{o}{.}\PYG{n}{executor}\PYG{o}{.}\PYG{n}{DispatchAbstractStatement}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{executeTemplet}\PYG{p}{]} \PYG{n}{DispatchPreparedStatementV2}\PYG{o}{.}\PYG{n}{executeQuery}\PYG{p}{(}\PYG{n}{select} \PYG{n}{pk\PYGZus{}value} \PYG{p}{,}\PYG{n}{CTID}\PYG{p}{,}\PYG{n}{XMIN} \PYG{k+kn}{from} \PYG{n+nn}{ecms\PYGZus{}gen\PYGZus{}pk} \PYG{n}{where} \PYG{n}{pk\PYGZus{}name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pk\PYGZus{}web\PYGZus{}url\PYGZus{}access\PYGZus{}log}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{for} \PYG{n}{update}\PYG{p}{;}\PYG{p}{)} \PYG{n}{consume} \PYG{n}{time}\PYG{p}{:}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{17}\PYG{p}{(}\PYG{n}{ms}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
比如我要看 monitor线程的日志

\end{enumerate}

从全日志里搜  monitor找到对应的线程ID比如是{[}32{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grep} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{[32}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{.}\PYG{o}{/}\PYG{n}{jdbc\PYGZus{}new}\PYG{o}{.}\PYG{n}{log} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{32.}\PYG{n}{log}
\end{sphinxVerbatim}

这样就能看到monitor不停的刷在线的主备机的IP，这样基本就能看到集群的历史和现在的状态，主备机都是谁。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
比如我要看是哪条SQL把事务设置为写事务了，从而不再分发备机。

\end{enumerate}

从日志里搜”Enter transactional state from sql”，后面的SQL就是被识别为写语句的SQL。

例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{11}\PYG{p}{:}\PYG{l+m+mi}{17}\PYG{p}{:}\PYG{l+m+mi}{29}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{114}\PYG{p}{]} \PYG{p}{[}\PYG{n}{com}\PYG{o}{.}\PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{dispatcher}\PYG{o}{.}\PYG{n}{sqlParser}\PYG{o}{.}\PYG{n}{sql}\PYG{o}{.}\PYG{n}{SqlParser}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{parse}\PYG{p}{]} \PYG{n}{Enter} \PYG{n}{transactional} \PYG{n}{state} \PYG{k+kn}{from} \PYG{n+nn}{sql}\PYG{p}{[}\PYG{n}{select} \PYG{n}{pk\PYGZus{}value} \PYG{k+kn}{from} \PYG{n+nn}{ecms\PYGZus{}gen\PYGZus{}pk} \PYG{n}{where} \PYG{n}{pk\PYGZus{}name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pk\PYGZus{}web\PYGZus{}url\PYGZus{}access\PYGZus{}log}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{for} \PYG{n}{update}\PYG{p}{]}\PYG{o}{.}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
比如我要看应用建一个新的JDBC连接的时间消耗

\end{enumerate}

从日志里搜“this connect consume time”，这个会显示建一个连接的时间消耗。

例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{11}\PYG{p}{:}\PYG{l+m+mi}{25}\PYG{p}{:}\PYG{l+m+mi}{16}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{302}\PYG{p}{]} \PYG{p}{[}\PYG{n}{com}\PYG{o}{.}\PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{Driver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{makeConnection}\PYG{p}{]} \PYG{n}{this} \PYG{n}{connect} \PYG{n}{consume} \PYG{n}{time}\PYG{p}{:}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{135}\PYG{p}{(}\PYG{n}{ms}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
比如我要看看都发生了什么错误

\end{enumerate}

从日志里搜“Exception”，就能看到所有的异常信息。

例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08} \PYG{l+m+mi}{11}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:}\PYG{l+m+mi}{29}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{302}\PYG{p}{]} \PYG{p}{[}\PYG{n}{com}\PYG{o}{.}\PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{Driver}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{connect}\PYG{p}{]} \PYG{n}{Unexpected} \PYG{n}{connection} \PYG{n}{error}\PYG{p}{:} \PYG{n}{java}\PYG{o}{.}\PYG{n}{sql}\PYG{o}{.}\PYG{n}{SQLException}\PYG{p}{:} \PYG{n}{JDBC} \PYG{n}{can}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{t find a vaild master database in cluster...}
\end{sphinxVerbatim}


\subsection{JDBC使用SSL加密}
\label{\detokenize{interface/jdbc:jdbcssl}}
适用版本：V8R2

\sphinxstylestrong{1. 使用LibPQFactory}

\sphinxstylestrong{服务器：}
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
确保安装openssl

\item {} 
在data目录下，创建自签名的证书

\end{enumerate}
\begin{quote}

为服务器创建一个快速的自签名的证书，填充那些openssl要求的信息。确保把本地主机名当做"Common Name"输入；挑战密码可以留空。该程序将生成一个用口令保护的密钥，它不会接受小于四字符的口令。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{new} \PYG{o}{\PYGZhy{}}\PYG{n}{text} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{req}
\end{sphinxVerbatim}

要移去密钥（如果你想自动启动服务器就必须这样），运行下面的命令：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{rsa} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{privkey}\PYG{o}{.}\PYG{n}{pem} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key}
\PYG{n}{rm} \PYG{n}{privkey}\PYG{o}{.}\PYG{n}{pem}
\end{sphinxVerbatim}

将一个证书变成自签名的证书并复制密钥和证书到服务器将要查找它们的地方

\begin{sphinxVerbatim}[commandchars=\\\{\}]
openssl req \PYGZhy{}x509 \PYGZhy{}days 3650 \PYGZhy{}in server.req \PYGZhy{}text \PYGZhy{}key server.key \PYGZhy{}out server.crt

修改文件权限，如果文件的权限比这个更自由，服务器将拒绝该文件。
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chmod} \PYG{n}{og}\PYG{o}{\PYGZhy{}}\PYG{n}{rwx} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key}
\end{sphinxVerbatim}

生成根证书

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cp} \PYG{n}{server}\PYG{o}{.}\PYG{n}{crt} \PYG{n}{root}\PYG{o}{.}\PYG{n}{crt}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{2}
\item {} 
配置kingbase.conf文件

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ssl} \PYG{o}{=} \PYG{n}{on}                                 \PYG{c+c1}{\PYGZsh{} (change requires restart)}
\PYG{c+c1}{\PYGZsh{}ssl\PYGZus{}ciphers = \PYGZsq{}HIGH:MEDIUM:+3DES:!aNULL\PYGZsq{} \PYGZsh{} allowed SSL ciphers}
                                               \PYG{c+c1}{\PYGZsh{} (change requires restart)}
\PYG{c+c1}{\PYGZsh{}ssl\PYGZus{}prefer\PYGZus{}server\PYGZus{}ciphers = on              \PYGZsh{} (change requires restart)}
\PYG{c+c1}{\PYGZsh{}ssl\PYGZus{}ecdh\PYGZus{}curve = \PYGZsq{}prime256v1\PYGZsq{}               \PYGZsh{} (change requires restart)}
\PYG{c+c1}{\PYGZsh{}ssl\PYGZus{}cert\PYGZus{}file = \PYGZsq{}server.crt\PYGZsq{}               \PYGZsh{} (change requires restart)}
\PYG{c+c1}{\PYGZsh{}ssl\PYGZus{}key\PYGZus{}file = \PYGZsq{}server.key\PYGZsq{}                \PYGZsh{} (change requires restart)}
\PYG{n}{ssl\PYGZus{}ca\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ root.crt }\PYG{l+s+s1}{\PYGZsq{}}                       \PYG{c+c1}{\PYGZsh{} (change requires restart)}
\PYG{c+c1}{\PYGZsh{}ssl\PYGZus{}crl\PYGZus{}file = \PYGZsq{}\PYGZsq{}                           \PYGZsh{} (change requires restart)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{3}
\item {} 
配置sys\_hba.conf文件

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hostssl}    \PYG{n+nb}{all}             \PYG{n+nb}{all}             \PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{o}{/}\PYG{l+m+mi}{0}               \PYG{n}{md5}  \PYG{n}{clientcert}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

5)重启数据库服务器

6)为客户端创建所需证书
\begin{quote}

生成kingbase8.key

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{genrsa} \PYG{o}{\PYGZhy{}}\PYG{n}{des3} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key} \PYG{l+m+mi}{1024}
\PYG{n}{openssl} \PYG{n}{rsa} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key}
\PYG{n}{chmod} \PYG{l+m+mi}{400} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key}
\end{sphinxVerbatim}

生成kingbase8.csr，CN需要指定为要连接数据库的用户名，如需匹配不同的用户，可指定为*

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{new} \PYG{o}{\PYGZhy{}}\PYG{n}{key} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{csr} \PYG{o}{\PYGZhy{}}\PYG{n}{subj} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/C=GB/ST=Berkshire/L=Newbury/O=Kingbase/CN=SYSTEM}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

生成kingbase8.crt

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{x509} \PYG{o}{\PYGZhy{}}\PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{days} \PYG{l+m+mi}{3650} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{csr} \PYG{o}{\PYGZhy{}}\PYG{n}{CA} \PYG{n}{root}\PYG{o}{.}\PYG{n}{crt} \PYG{o}{\PYGZhy{}}\PYG{n}{CAkey} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{crt} \PYG{o}{\PYGZhy{}}\PYG{n}{CAcreateserial}
\end{sphinxVerbatim}

生成kingbase8.pk8

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{pkcs8} \PYG{o}{\PYGZhy{}}\PYG{n}{topk8} \PYG{o}{\PYGZhy{}}\PYG{n}{outform} \PYG{n}{DER} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{pk8} \PYG{o}{\PYGZhy{}}\PYG{n}{nocrypt}
\end{sphinxVerbatim}
\end{quote}
\end{quote}

\sphinxstylestrong{jdbc：}
\begin{quote}

通过参数sslmode配置证书验证方式，该参数支持四个值：disable（禁用SSL）、require、verify\sphinxhyphen{}ca、verify\sphinxhyphen{}full。使用verify\sphinxhyphen{}ca和verify\sphinxhyphen{}full时，需通过连接参数sslrootcert指定根证书文件的位置，如不指定，Linux默认路径为\$HOME/.kingbase8/root.crt，Windows默认路径为\%APPDATA\%kingbase8root.crt，将服务器data目录下的root.crt放到对应目录下即可。只有verify\sphinxhyphen{}full模式会对主机名进行验证。

通过参数sslcert配置客户端证书位置，如不指定，Linux默认路径为\$HOME/.kingbase8/kingbase8.crt，Windows默认路径为\%APPDATA\%kingbase8kingbase8.crt，将服务器data目录下的kingbase8.crt放到对应目录下即可。

通过参数sslkey配置秘钥文件位置，如不指定，Linux默认路径为\$HOME/.kingbase8/kingbase8.pk8，Windows默认路径为\%APPDATA\%kingbase8kingbase8.pk8，将服务器data目录下的kingbase8.pk8放到对应目录下即可。

举例：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
jdbc:kingbase8://192.168.222.128:54321/TEST?sslmode=verify\PYGZhy{}ca\PYGZam{}sslrootcert=root.crt\PYGZam{}sslcert=kingbase8.crt\PYGZam{}sslkey=kingbase8.pk8
\end{sphinxVerbatim}
\end{quote}

\sphinxstylestrong{2. 使用默认的SSLSocketFactory}

\sphinxstylestrong{服务器：}
\begin{quote}

1)、2)、3)、4)、5)见上
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{5}
\item {} 
创建truststore，用于认证服务器端证书

\end{enumerate}
\begin{quote}

把服务器证书转化为der格式

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{x509} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{server}\PYG{o}{.}\PYG{n}{crt} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{crt}\PYG{o}{.}\PYG{n}{der} \PYG{o}{\PYGZhy{}}\PYG{n}{outform} \PYG{n}{der}
\end{sphinxVerbatim}

创建truststore，装入服务器证书

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{keytool} \PYG{o}{\PYGZhy{}}\PYG{n}{keystore} \PYG{o}{.}\PYG{o}{/}\PYG{n}{truststore} \PYG{o}{\PYGZhy{}}\PYG{n}{alias} \PYG{n}{kingbase8server} \PYG{o}{\PYGZhy{}}\PYG{k+kn}{import} \PYG{o}{\PYGZhy{}}\PYG{n}{file} \PYG{o}{.}\PYG{o}{/}\PYG{n}{server}\PYG{o}{.}\PYG{n}{crt}\PYG{o}{.}\PYG{n}{der}
\end{sphinxVerbatim}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{6}
\item {} 
创建keystore，保存客户端证书

\end{enumerate}
\begin{quote}

生成客户端的keyPair

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{keytool} \PYG{o}{\PYGZhy{}}\PYG{n}{genkeypair} \PYG{o}{\PYGZhy{}}\PYG{n}{dname} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cn=kingbase8client, ou=basesoft, o=basesoft, c=CN}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZhy{}}\PYG{n}{alias} \PYG{n}{kingbase8client} \PYG{o}{\PYGZhy{}}\PYG{n}{keystore} \PYG{o}{.}\PYG{o}{/}\PYG{n}{keystore} \PYG{o}{\PYGZhy{}}\PYG{n}{validity} \PYG{l+m+mi}{180}
\end{sphinxVerbatim}

生成证书请求

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{keytool} \PYG{o}{\PYGZhy{}}\PYG{n}{certreq} \PYG{o}{\PYGZhy{}}\PYG{n}{alias} \PYG{n}{kingbase8client} \PYG{o}{\PYGZhy{}}\PYG{n}{file} \PYG{o}{.}\PYG{o}{/}\PYG{n}{kingbase8client}\PYG{o}{.}\PYG{n}{csr} \PYG{o}{\PYGZhy{}}\PYG{n}{keystore} \PYG{o}{.}\PYG{o}{/}\PYG{n}{keystore}
\end{sphinxVerbatim}

用root.crt签发客户端证书

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{x509} \PYG{o}{\PYGZhy{}}\PYG{n}{sha1} \PYG{o}{\PYGZhy{}}\PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{o}{.}\PYG{o}{/}\PYG{n}{kingbase8client}\PYG{o}{.}\PYG{n}{csr} \PYG{o}{\PYGZhy{}}\PYG{n}{CA} \PYG{o}{.}\PYG{o}{/}\PYG{n}{root}\PYG{o}{.}\PYG{n}{crt} \PYG{o}{\PYGZhy{}}\PYG{n}{CAkey} \PYG{o}{.}\PYG{o}{/}\PYG{n}{server}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{CAcreateserial} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{o}{.}\PYG{o}{/}\PYG{n}{kingbase8client}\PYG{o}{.}\PYG{n}{crt}\PYG{o}{.}\PYG{n}{der} \PYG{o}{\PYGZhy{}}\PYG{n}{outform} \PYG{n}{DER} \PYG{o}{\PYGZhy{}}\PYG{n}{days} \PYG{l+m+mi}{365} \PYG{o}{\PYGZhy{}}\PYG{n}{passin} \PYG{k}{pass}\PYG{p}{:}\PYG{l+m+mi}{123456} \PYG{o}{\PYGZhy{}}\PYG{n}{extfile} \PYG{o}{/}\PYG{n}{etc}\PYG{o}{/}\PYG{n}{pki}\PYG{o}{/}\PYG{n}{tls}\PYG{o}{/}\PYG{n}{openssl}\PYG{o}{.}\PYG{n}{cnf} \PYG{o}{\PYGZhy{}}\PYG{n}{extensions} \PYG{n}{v3\PYGZus{}req}
\end{sphinxVerbatim}

把证书添加到keystore中

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{keytool} \PYG{o}{\PYGZhy{}}\PYG{n}{keystore} \PYG{o}{.}\PYG{o}{/}\PYG{n}{keystore} \PYG{o}{\PYGZhy{}}\PYG{n}{alias} \PYG{n}{kingbase8server} \PYG{o}{\PYGZhy{}}\PYG{k+kn}{import} \PYG{o}{\PYGZhy{}}\PYG{n}{file} \PYG{o}{.}\PYG{o}{/}\PYG{n}{server}\PYG{o}{.}\PYG{n}{crt}\PYG{o}{.}\PYG{n}{der}
\PYG{n}{keytool} \PYG{o}{\PYGZhy{}}\PYG{n}{keystore} \PYG{o}{.}\PYG{o}{/}\PYG{n}{keystore} \PYG{o}{\PYGZhy{}}\PYG{n}{alias} \PYG{n}{kingbase8client} \PYG{o}{\PYGZhy{}}\PYG{k+kn}{import} \PYG{o}{\PYGZhy{}}\PYG{n}{file} \PYG{o}{.}\PYG{o}{/}\PYG{n}{kingbase8client}\PYG{o}{.}\PYG{n}{crt}\PYG{o}{.}\PYG{n}{der}
\end{sphinxVerbatim}
\end{quote}
\end{quote}

\sphinxstylestrong{jdbc：}
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
只需配置连接参数ssl=true；

\item {} 
将truststore和keystore拷贝到客户端；

\item {} 
执行程序时指定java运行参数

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZhy{}}\PYG{n}{Djavax}\PYG{o}{.}\PYG{n}{net}\PYG{o}{.}\PYG{n}{ssl}\PYG{o}{.}\PYG{n}{trustStore}\PYG{o}{=}\PYG{n}{truststore} \PYG{o}{\PYGZhy{}}\PYG{n}{Djavax}\PYG{o}{.}\PYG{n}{net}\PYG{o}{.}\PYG{n}{ssl}\PYG{o}{.}\PYG{n}{trustStorePassword}\PYG{o}{=}\PYG{l+m+mi}{123456}
\PYG{o}{\PYGZhy{}}\PYG{n}{Djavax}\PYG{o}{.}\PYG{n}{net}\PYG{o}{.}\PYG{n}{ssl}\PYG{o}{.}\PYG{n}{keyStore}\PYG{o}{=}\PYG{n}{keystore} \PYG{o}{\PYGZhy{}}\PYG{n}{Djavax}\PYG{o}{.}\PYG{n}{net}\PYG{o}{.}\PYG{n}{ssl}\PYG{o}{.}\PYG{n}{keyStorePassword}\PYG{o}{=}\PYG{l+m+mi}{123456}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
生成keystore时，签发客户端证书命令，可能会对openssl的版本有一定的要求，自测使用版本为OpenSSL 1.0.1e\sphinxhyphen{}fips，可以通过命令openssl version查看openssl版本。

\item {} 
如果需要不与主机名和用户名绑定，使用LibPQFactory方式，需要配置jdbc连接参数sslmode为verify\sphinxhyphen{}ca，指定该参数不会验证主机名，生成kingbase8.csr时，CN指定为*，可匹配不同的用户。使用SSLSocketFactory不验证主机名和用户名。

\item {} 
使用java命令执行应用程序时，可以通过\sphinxhyphen{}cp或\sphinxhyphen{}Djava.ext.dirs指定jar包路径。但通过后者指定时，会覆盖Java本身的ext设置，如果未指定该系统属性的原加载路径，将失去一些功能，如java自带的加解密算法实现，会报NOSuchAlgorithmException的错误。故需同时在该设置下指定路径\$JAVA\_HOME/jre/lib/ext，如\sphinxhyphen{}Djava.ext.dirs=./plugin: \$JAVA\_HOME/jre/lib/ex。

\end{enumerate}
\end{sphinxadmonition}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\setcounter{enumi}{3}
\item {} 
如果openssl版本太高，使用其生成的证书服务器可能会报"unknown message digest algorithm"错误，此时需将openssl.cnf配置加密算法改为sha1，并且通过环境变量OPENSSL\_CONF指定该文件的位置。

\end{enumerate}
\begin{quote}

openssl version      查看openssl的版本
openssl version \sphinxhyphen{}d   查看openssl.cnf所在目录
\end{quote}
\end{quote}


\subsection{JDBC常见异常}
\label{\detokenize{interface/jdbc:id14}}
适用版本：V8R2
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
com.kingbase8.util.KSQLException:The column index is out of range: 1, number of columns: 0.

\end{enumerate}

该异常报错原因是sql无需绑定参数（如空sql:””），然后进行了参数绑定，请客户自己排查原因。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
Bad version number in .class file(unable to load class com.kingbase8.Driver)

\end{enumerate}

异常原因为jdk的版本小于jdbc驱动包编译的版本，提升jdk版本或使用与jdk版本对应的jar包。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
java.lang.NoClassDefFoundError或java.lang.ClassNotFoundException

\end{enumerate}

这两个异常都是找不到类，通常是缺少jar包，百度下该类在什么包里，导入对应jar包即可。

查看是否导入jar包：

\sphinxstylestrong{工具idea}：

1）点击File –> Project Structure；

2）找到Modules，选中项目，点击Dependencies；

3）如果缺少，点击右侧+号即可导入。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{jdbc-1}.png}
\end{figure}

\sphinxstylestrong{工具eclipse：}

1）点击项目，右键，选中Build Path，Configure Build Path，在Libraries中查看所有导入的包。缺少可通过Add JARs导入。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{jdbc-2}.png}
\end{figure}

2）直接展开项目，也可以查看，如未导入，直接选中未导入的jar包，右键，Build Path，Add to Build Path。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{jdbc-3}.png}
\end{figure}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
This connection has been closed.

\end{enumerate}

该异常是因为使用了已关闭的连接，该连接可能由客户端关闭，也可能是jdbc遇到了I/O异常时，关闭当前连接。应用程序未处理I/O异常，直接使用该连接，就会导致该异常。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
I/O异常( An I/O e rror occurred while sending to the backend.)

\end{enumerate}

通常是由网络原因导致的，也有可能是超时导致或者磁盘满了。如果是单条语句报I/O异常，通常是语句超时导致，语句超时指的就是语句执行时间超过了socketTimeout设置的时间。如果多条语句报错，那就是其他两个原因。

也有可能是绑定的从参数个数超过了SQL的参数限制（Short.MAX\_VALUE:32767)。（java.io.IOException:Tried to send an out\sphinxhyphen{}of\sphinxhyphen{}range integer as a 2\sphinxhyphen{}byte value:）

如果是在流写入的过程中遇到该异常，也可能是创建临时文件失败。写入的流如果大于50k，就会在默认临时文件目录（java.io.tmpdir的值)中创建一个文件来缓存内容，中间出现IO异常，也会抛出该错误信息。

以上错误可以通过错误堆栈来区分。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{5}
\item {} 
替换jar包未生效问题

\end{enumerate}

原因是之前的jar包未删除。排查方法：可以删除新导入的jar包，看项目是否可以正常运行，如果可以正常运行，说明还存在其他jar包，删掉之前的jar包，再导入新的jar包。找不到其他的jar包可能原因是用户修改了驱动包名称或者驱动包被打在了其他jar包里。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{6}
\item {} 
连接错误分析

\end{enumerate}

（1）java.net.SocketTimeoutException:connect time out

该错误表示底层的socket连接在10s内（connectTimeout默认值为10s）建立失败，此时客户端与服务器之间网络不通。

（2）com.kingbase8.util.KSQLException: Connection to 192.168.19.128:5432 refused. Check that the hostname and port are correct and that the postmaster is accepting TCP/IP connections.
Caused by: java.net.ConnectException: Connection refused: connect

该错误表示设置的端口无法连接，可能是数据库未开启或者端口填写错误。

（3）The authentication type 10 is not supported. Check that you have configured the sys\_hba.conf file to include the client's IP address or subnet, and that it is using an authentication scheme supported by the driver.

该错误是R3的驱动连接了R6的数据库。原因是R3的驱动不支持sha256验证，R6数据库默认就是sha256验证方式。

（4）SCRAM authentication is not supported by this driver. You need JDK >= 8 and pgjdbc >= 42.2.0 (not ".jre" versions)

R6 jdk1.6版本的驱动不支持sha256验证，需要使用md5验证方式。首先需要修改sys\_hba.conf中的验证方式为md5，然后需要创建一个md5加密的用户。show password\_encryption查看密码加密方式，不是md5的话需要修改加密方式为md5再创建用户。创建好后可以使用SELECT rolname,rolpassword FROM pg\_authid;查看用户名和密码。

（5）FATAL:invalid value for parameter "client\_encoding":XXX

该错误是指服务器不支持XXX客户端编码。JDBC驱动连接数据库时默认设置的客户端编码是JVM的编码，如果该编码服务器不支持就会报上述错误。可以通过修改JVM编码或者通过设置JDBC连接参数clientEncoding来解决。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{7}
\item {} 
无法确定参数\$1的类型

\end{enumerate}

使用\$1::type或cast函数对参数进行类型强转。使用Hibernate通常用cast函数，否则无法通过hibernate的语句解析。


\subsection{JDBC读取BLOB乱码}
\label{\detokenize{interface/jdbc:jdbcblob}}
适用版本：V8R2

BLOB存储的内容为二进制，不会出现乱码。
1.如果打印内容为com.kingbase8.jdbc.KbBlob@14ae5a5，这个是Blob的对象名称，需要调用Blob的getBytes等方法，把Blob的存储内容拿出来，具体的参考手册示例。
2.如果打印内容为x开头的十六进制字符串，和ksql查询出的内容一样，或者转字符串的时候使用了其他编码，打印出来的也可能是乱码，此时可以直接比较byte数组的大小，如果取出来的结果的数组是写之前的2倍加2的大小，那么需要更换新驱动或者在连接串指定连接参数prepareThreshold=\sphinxhyphen{}1。
如果不是以上两种情况，那就是写之前就已经转成了乱码，直接把待写入的byte数组转成字符串看是否是乱码。


\subsection{读写分离分发现象分析}
\label{\detokenize{interface/jdbc:id15}}
适用版本：V8R2

问题描述1：集群状态正常，主机负载率也不是100，但是查询语句全部分发主机。

问题分析：原因可能为连接数据库的用户的权限小于流复制的权限，导致JDBC检测线程查不到在线备机，所有语句全部分发主机。是否该原因可通过工具或者ksql使用相同用户连接相同数据库，执行select CLIENT\_ADDR from sys\_stat\_replication;看是否可以查询到备机。

解决办法：使用超级用户

问题描述2：读语句发往同一台备机

问题分析：使用同一个Statement执行的读语句都会发往同一台备机，原因是Statement的底层实际是有一个主Statement和一个备Statement，如果备Statement不为空时，不会去重新获取新的Statement，会一直使用同一个。如果想将语句进行分发，就建立新的Statement来执行语句。使用PreparedStatement/CallableStatement定义语句后，反复使用execute执行，多次执行都是发往同一台机器。


\subsection{com.kingbase8.util.KSQLException: ERROR: type "q" does not exist（R6）}
\label{\detokenize{interface/jdbc:com-kingbase8-util-ksqlexception-error-type-q-does-not-exist-r6}}
适用版本：V8R2

问题分析：该问题是由于服务器开启了空串转为null参数（ora\_input\_emptystr\_isnull=true），开启该参数后，原先为空串可以用q'<>'表示，但是有些版本驱动已经修改，服务器未修改，所以会有该问题。

解决办法：通过升级服务器版本或者关闭空串转为null参数（ora\_input\_emptystr\_isnull=false）来解决。


\subsection{fetchsize功能}
\label{\detokenize{interface/jdbc:fetchsize}}
V8R3：使用参数defaultRowFetchSize指定返回行数即可。

V8R6：自动提交模式下，使用参数defaultRowFetchSize指定返回行数即可。

非自动提交模式下，使用参数defaultRowFetchSize指定返回行数，同时指定连接参数     useFetchSizeInAutoCommit=true。同时还需将服务器的GUC参数enable\_autocommit\_crossquery和enable\_autocommit\_fetch置为true。


\subsection{同时使用R3和R6，jar包冲突的解决方案}
\label{\detokenize{interface/jdbc:r3r6-jar}}
V8R6使用别名包，驱动名称为com.kingbase86.Driver。连接串示例：\sphinxurl{jdbc:kingbase86://localhost:54321/test}


\subsection{如何查看jar包的版本号？}
\label{\detokenize{interface/jdbc:jar}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{java} \PYG{o}{\PYGZhy{}}\PYG{n}{jar} \PYG{n}{kingbase8}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.6}\PYG{o}{.}\PYG{l+m+mf}{0.}\PYG{n}{jar} \PYG{o}{\PYGZhy{}}\PYG{n}{version}
\end{sphinxVerbatim}


\section{Spring\sphinxhyphen{}JDBC 常见问题}
\label{\detokenize{interface/spring-jdbc:spring-jdbc}}\label{\detokenize{interface/spring-jdbc::doc}}

\subsection{大字段的设置\sphinxhyphen{}\sphinxhyphen{}lobHandler}
\label{\detokenize{interface/spring-jdbc:lobhandler}}
LobHandler 接口为操作 BLOB/CLOB 提供了统一访问接口，而不管底层数据库究竟是以大对象的方式还是以一般数据类型的方式进行操作。

大部分数据库厂商的 JDBC 驱动程序（如 DB2）都以 JDBC 标准的 API 操作 LOB 数据，但 Oracle 9i 及以前的 JDBC 驱动程序采用了自己的 API 操作 LOB 数据，Oracle 9i 直接使用自己的 API 操作 LOB 数据，且不允许通过 PreparedStatement 的setAsciiStream()、setBinaryStream()、setCharacterStream() 等方法填充流数据。Spring 提供 LobHandler 接口主要是为了迁就 Oracle 特立独行的作风。所以 Oracle 必须使用 OracleLobHandler 实现类，而其它的数据库统一使用 DefaultLobHandler 就可以了。Oracle 10g 改正了 Oracle 9i 这个异化的风格，所以 Oracle 10g 也可以使用 DefaultLobHandler。

\sphinxstylestrong{Oracle 数据库的 LobHandler 配置}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{bean} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{oracleLobHandler}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{class}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{org.springframework.jdbc.support.lob.OracleLobHandler}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{lazy}\PYG{o}{\PYGZhy{}}\PYG{n}{init}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{true}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nativeJdbcExtractor}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{ref}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nativeJdbcExtractor}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{bean}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{一般数据库 LobHandler 的配置}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{bean} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{defaultLobHandler}\PYG{l+s+s2}{\PYGZdq{}}
 \PYG{n}{class}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{org.springframework.jdbc.support.lob.DefaultLobHandler}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{lazy}\PYG{o}{\PYGZhy{}}\PYG{n}{init}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{true}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{Cannot determine a dialect for org.springframework.jdbc.core}
\label{\detokenize{interface/spring-jdbc:cannot-determine-a-dialect-for-org-springframework-jdbc-core}}
问题描述：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
org.springframework.data.jdbc.repository.config.DialectResolver\PYGZdl{}NoDialectException: Cannot determine a dialect for org.springframework.jdbc.core.JdbcTemplate@7c90b7b7. Please provide a Dialect.
\end{sphinxVerbatim}

堆栈信息：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name \PYGZsq{}jdbcConverter\PYGZsq{} defined in class path resource [org/springframework/boot/autoconfigure/data/jdbc/JdbcRepositoriesAutoConfiguration\PYGZdl{}SpringBootJdbcConfiguration.class]: Unsatisfied dependency expressed through method \PYGZsq{}jdbcConverter\PYGZsq{} parameter 4; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name \PYGZsq{}jdbcDialect\PYGZsq{} defined in class path resource [org/springframework/boot/autoconfigure/data/jdbc/JdbcRepositoriesAutoConfiguration\PYGZdl{}SpringBootJdbcConfiguration.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [org.springframework.data.relational.core.dialect.Dialect]: Factory method \PYGZsq{}jdbcDialect\PYGZsq{} threw exception; nested exception is org.springframework.data.jdbc.repository.config.DialectResolver\PYGZdl{}NoDialectException: Cannot determine a dialect for org.springframework.jdbc.core.JdbcTemplate@7c90b7b7. Please provide a Dialect.
\end{sphinxVerbatim}

解决办法：
\begin{quote}

出现该问题是因为使用了spring\sphinxhyphen{}boot\sphinxhyphen{}starter\sphinxhyphen{}data\sphinxhyphen{}jdbc包，该包要求提供jdbcDialect，目前未适配，推荐使用spring\sphinxhyphen{}boot\sphinxhyphen{}starter\sphinxhyphen{}jdbc。
\end{quote}


\section{Hibernate使用常见问题}
\label{\detokenize{interface/hibernate:hibernate}}\label{\detokenize{interface/hibernate::doc}}

\subsection{Hibernate使用需要配置方言包}
\label{\detokenize{interface/hibernate:id1}}
Hibernate的使用需要配置方言包，使用方言包的版本需要根据Hibernate核心包的版本来确定。Hibernate核心包通常由客户从网络下载，核心包的包名为hibernate\sphinxhyphen{}core\sphinxhyphen{}xxx.jar或hibernate\sphinxhyphen{}xxx.jar或hibernatex.jar。目前R2、R3提供以下版本的方言包。
\begin{quote}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
方言包
&\sphinxstyletheadfamily 
适用范围
\\
\hline
hibernate\sphinxhyphen{}2.0.3dialect.jar
&
{[}2.0,2.1）
\\
\hline
hibernate\sphinxhyphen{}3.1dialect.jar
&
{[}3.1,3.2）
\\
\hline
hibernate\sphinxhyphen{}3.2.7gadialect.jar
&
{[}3.2,3.3）
\\
\hline
hibernate\sphinxhyphen{}3.3dialect.jar
&
{[}3.3,3.6）
\\
\hline
hibernate\sphinxhyphen{}3.6.10dialect.jar
&
{[}3.6,4.0）
\\
\hline
hibernate\sphinxhyphen{}4.0.1finaldialect.jar
&
{[}4.0,4.3）
\\
\hline
hibernate\sphinxhyphen{}4.3.11finaldialect.jar
&
{[}4.3,5.0）
\\
\hline
hibernate\sphinxhyphen{}4.3.2finaldialect.jar
&
{[}4.3,5.0）
\\
\hline
hibernate\sphinxhyphen{}5.0.12.Finaldialect.jar
&
{[}5.0,5.2）
\\
\hline
hibernate\sphinxhyphen{}5.2.17.Finaldialect.jar
&
{[}5.2,5.4）
\\
\hline
hibernate\sphinxhyphen{}5.4.6.Finaldialect.jar
&
{[}5.4,6.0）
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{quote}

V7的方言包类名都是KingbaseDialect，V82的方言包类名都是Kingbase8Dialect。请注意类名配置。

使用时注意配置是否填写正确

V7的hibernate 的dialect配置例子

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dialect}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{hibernate}\PYG{o}{.}\PYG{n}{dialect}\PYG{o}{.}\PYG{n}{KingbaseDialect}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{connection.driver\PYGZus{}class}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{com}\PYG{o}{.}\PYG{n}{kingbase}\PYG{o}{.}\PYG{n}{Driver}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{connection.url}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{jdbc}\PYG{p}{:}\PYG{n}{kingbase}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{87.128}\PYG{p}{:}\PYG{l+m+mi}{5421}\PYG{o}{/}\PYG{n}{TEST}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

V82的hibernate 的dialect配置例子

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dialect}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{hibernate}\PYG{o}{.}\PYG{n}{dialect}\PYG{o}{.}\PYG{n}{Kingbase8Dialect}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{connection.driver\PYGZus{}class}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{com}\PYG{o}{.}\PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{Driver}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{connection.url}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{jdbc}\PYG{p}{:}\PYG{n}{kingbase8}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{87.128}\PYG{p}{:}\PYG{l+m+mi}{54333}\PYG{o}{/}\PYG{n}{TEST}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

在运行项目时如果遇到以下两种异常，均是因为项目未导入方言包：
\begin{quote}

1.java.lang.ClassNotFoundException: Could not load requested class : org.hibernate.dialect.Kingbase8Dialect

2.org.hibernate.boot.registry.selector.spi.StrategySelectionException: Unable to resolve name {[}org.hibernate.dialect.Kingbase8Dialect{]} as strategy {[}org.hibernate.dialect.Dialect{]}
\end{quote}

目前遇到的情况有：
\begin{quote}

1.未将方言包加入项目的classpath中；

2.将核心包当成方言包导入。
\end{quote}


\subsection{V8 Hibernate非法long值问题}
\label{\detokenize{interface/hibernate:v8-hibernatelong}}
这个问题是由于V8 hibernate把TEXT类型默认对应到CLOB类型处理，但是CLOB是通过OID来访问的，所以造成类型转换报错。解决办法更换新的方言包，新的dialect。

方言包把TEXT类型默认对应到LONGVARCHAR就解决了。


\subsection{Hibernate 无法确定参数类型\$1}
\label{\detokenize{interface/hibernate:hibernate-1}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
使用cast函数对于不识别的类型进行强转，如cast(? as timestamp)，as后面的类型需要为hibernate类型，hibernate类型自行百度。

\item {} 
对于V7，这个问题可能是用户打开了Hibernate的SQL注释功能，改为false即可。

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}property name=\PYGZdq{}use\PYGZus{}sql\PYGZus{}comments\PYGZdq{}\PYGZgt{}false\PYGZlt{}/property\PYGZgt{}

parse JDBC\PYGZus{}STATEMENT\PYGZus{}7: /* from TestDb  where username=\PYGZdl{}1 */ select testdb0\PYGZus{}.id as id0\PYGZus{}, testdb0\PYGZus{}.username as username0\PYGZus{}, testdb0\PYGZus{}.btest as btest0\PYGZus{} from hibernate\PYGZus{}test testdb0\PYGZus{} where testdb0\PYGZus{}.username=\PYGZdl{}2
ERROR:  could not determine data type of parameter \PYGZdl{}1
\end{sphinxVerbatim}


\subsection{Hibernate 错误: 字段的类型为 TEXT, 但表达式的类型为 BYTEA你需要重写或转换表达式}
\label{\detokenize{interface/hibernate:hibernate-text-bytea}}
问题分析：
\begin{quote}

这个问题原因是JDBC指定了bytea的OID传给服务器，而服务器实际字段类型是TEXT，不支持类型转换。

查看hibernate源码：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{public} \PYG{n}{Query} \PYG{n}{setParameter}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{position}\PYG{p}{,} \PYG{n}{Object} \PYG{n}{val}\PYG{p}{)} \PYG{n}{throws} \PYG{n}{HibernateException}    \PYG{p}{\PYGZob{}}
      \PYG{k}{if} \PYG{p}{(}\PYG{n}{val} \PYG{o}{==} \PYG{n}{null}\PYG{p}{)} \PYG{p}{\PYGZob{}}
         \PYG{n}{setParameter}\PYG{p}{(} \PYG{n}{position}\PYG{p}{,} \PYG{n}{val}\PYG{p}{,} \PYG{n}{Hibernate}\PYG{o}{.}\PYG{n}{SERIALIZABLE} \PYG{p}{)}\PYG{p}{;}
      \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

看出对于null值，hibernate都是按照Hibernate.SERIALIZABLE类型处理。而Hibernate.SERIALIZABLE类型使用Hibernate.BINARY.set(st, toBytes(value), index)。

Hibernate.BINRAY底层使用JDBC的setBinaryStream或者setBytes绑定参数。
\end{quote}

解决办法：
\begin{quote}

JDBC直接修改所有Bind参数传bytea的地方都改成0。如仍需绑定为bytea，可通过连接参数bytestype=bytea来指定。
\end{quote}


\subsection{Hibernate控制输出真实SQL日志}
\label{\detokenize{interface/hibernate:hibernatesql}}
编辑hibernate.cfg.xml，配置方法：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
参数：show\_sql=true 打印SQL语句；

\item {} 
参数：format\_sql=true 使SQL语句格式更加美观统一；

\item {} 
参数：use\_sql\_comments=true 使SQL语句中自动注入注释，增加可读性。

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{show\PYGZus{}sql}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{true}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}    \PYG{o}{/}\PYG{o}{/}\PYG{n}{控制台打印SQL语句}
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{format\PYGZus{}sql}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{true}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}  \PYG{o}{/}\PYG{o}{/}\PYG{n}{格式化SQL语句}
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{use\PYGZus{}sql\PYGZus{}comments}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{true}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}  \PYG{o}{/}\PYG{o}{/}\PYG{n}{指出是什么操作生成了该语句}
\end{sphinxVerbatim}


\subsection{Springboot JPA配置方言包问题}
\label{\detokenize{interface/hibernate:springboot-jpa}}
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in class path resource
Caused by: org.hibernate.HibernateException: Access to DialectResolutionInfo cannot be null when 'hibernate.dialect' not set

Hibernate SQL方言没有设置导致的，在properties文件中增加下面这行：
\begin{quote}

spring.jpa.database\sphinxhyphen{}platform=org.hibernate.dialect.Kingbase8Dialect或者spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.Kingbase8Dialect
\end{quote}


\subsection{hibernate\sphinxhyphen{}spatial方言包配置}
\label{\detokenize{interface/hibernate:hibernate-spatial}}
hibernate\sphinxhyphen{}spatial是hibernate的数据空间插件，该方言包只在pg兼容版提供，依赖于hibernate方言包，目前只有5.3.7一个版本，使用该方言只需要将原先配置的hibernate方言的名称改为org.hibernate.spatial.dialect.kingbase.PostgisDialect即可，其他参见hibernate配置。如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dialect}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{hibernate}\PYG{o}{.}\PYG{n}{spatial}\PYG{o}{.}\PYG{n}{dialect}\PYG{o}{.}\PYG{n}{kingbase}\PYG{o}{.}\PYG{n}{PostgisDialect}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}


\subsection{hibernate使用numeric或char(1)映射java的boolean}
\label{\detokenize{interface/hibernate:hibernatenumericchar-1-javaboolean}}
当java类型为boolean，数据库字段类型为char(1)或numeric类型时，需将映射类型设置为org.hibernate.type.NumericBooleanType，例如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sex}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n+nb}{type}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{org.hibernate.type.NumericBooleanType}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
         \PYG{o}{\PYGZlt{}}\PYG{n}{column} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sex}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

否则，映射为char(1)的时候会报“对于字符类型来说这个值太长了(1)”的错误，映射为numeric时且当该字段作为查询条件时，会在查询的时候无结果，原因是jdbc实际绑定的参数都是0和1，但oid类型为boolean，所以数据库查询时会自动推断类型，参数值被推断为f和t，但实际存储的是0和1，导致查询无结果。

这个问题在后续已修复，可直接更换新的驱动包。但是对于类似于from Person p where p.sex=true;的bool作为查询条件参数写死的hql，还需导入扩展方言hibernate\sphinxhyphen{}dialect\sphinxhyphen{}extension.jar，方言包名称修改为：org.hibernate.dialect.Kingbase8ExtensionDialect。该方言包依赖原先的方言包。


\subsection{The column name sequence\_catalog was not found in this ResultSet.}
\label{\detokenize{interface/hibernate:the-column-name-sequence-catalog-was-not-found-in-this-resultset}}
Hibernate查询sequence的语句从5.4开始发生了改变，该错误需替换对应版本的方言包，目前我们提供了5.4.6版本的方言包，使用5.4版本以上的核心包，使用5.4.6的方言包。


\subsection{主键自增策略hilo}
\label{\detokenize{interface/hibernate:hilo}}
使用hilo策略，默认的表hibernate\_unique\_key需要自己建立，而且必须拥有默认的字段next\_hi，建表后，需要插入一条数据作为起始值。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{create} \PYG{n}{table} \PYG{n}{hibernate\PYGZus{}unique\PYGZus{}key} \PYG{p}{(}\PYG{n}{next\PYGZus{}hi} \PYG{n}{integer} \PYG{o+ow}{not} \PYG{n}{null}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{insert} \PYG{n}{into} \PYG{n}{hibernate\PYGZus{}unique\PYGZus{}key} \PYG{p}{(}\PYG{n}{next\PYGZus{}hi}\PYG{p}{)} \PYG{n}{values}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Method com.kingbase8.jdbc.KbPreparedStatement.setCharacterStream(int, Reader, long) is not yet implemented.}
\label{\detokenize{interface/hibernate:method-com-kingbase8-jdbc-kbpreparedstatement-setcharacterstream-int-reader-long-is-not-yet-implemented}}
该问题通常因为客户未使用ES的hibernate方言包，在使用了ES的hibernate方言包时，不会走到ES驱动未实现的方法中，解决方案就是配置ES的hibernate方言包。


\subsection{Hibernate的hql不支持部分数据库函数的使用}
\label{\detokenize{interface/hibernate:hibernatehql}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
将hql语句转换为sql语句，createQuery使用的是hql，createSQLQuery使用的是sql语句；

\item {} 
在方言包里注册函数解决。

\end{enumerate}


\subsection{Hibernate设置为update已经建好表，仍旧去建表}
\label{\detokenize{interface/hibernate:hibernateupdate}}
原因为使用了大小写不敏感的数据库，在大小写不敏感的库中，查询返回的表名与建表时的大小写保持一致。如果建表时使用小写，Hibernate查询返回的表名为小写，本地的表名是转为大写去比较，找不到所以会去建表，请改为大小写敏感的数据库。

\sphinxstylestrong{修改后可能存在的问题：}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
索引重复创建

\end{enumerate}
\begin{quote}

应用可能是从MySQL、SQLServer迁移过来的。索引名称在某些数据库中（如 MySQL、SQLServer），索引是以表为维度创建的，在不同的表中的索引是可以重名的； 而在另外的一些数据库中（如 PostgreSQL、Oracle、KingbaseES），索引是以数据库为维度创建的，即使是作用在不同表上的索引，它们也要求其名称的唯一性。所以需要修改索引名称。
\end{quote}


\subsection{java.lang.NoSuchMethodError: javax.persistence.Table.indexes(){[}Ljavax/persistence/Index;}
\label{\detokenize{interface/hibernate:java-lang-nosuchmethoderror-javax-persistence-table-indexes-ljavax-persistence-index}}
jar包冲突，有多个jar包存在javax/persistence/Index类。


\subsection{表取名user怎么规避？}
\label{\detokenize{interface/hibernate:user}}
在映射上@Table(name=“t\_user")换个名字或者@Table(name="user",schema="xxx")显示指定模式名


\subsection{其它模式下有同名表，导致当前模式没有表但未去建表}
\label{\detokenize{interface/hibernate:id2}}
目前已知5.0.12这个版本的hibernate在查找表时，如果没有显示指定模式名，查询顺序为先查当前模式，没有查找默认模式，再没有就查找全模式，其他模式下有表，就会导致当前模式下创建失败，解决方法：1.在@Table显示指定schema；2.删除其他模式下的同名表；3.升级hibernate版本。


\section{Mybatis 常见问题}
\label{\detokenize{interface/mybatis:mybatis}}\label{\detokenize{interface/mybatis::doc}}

\subsection{Mybatis设置SQL超时时间}
\label{\detokenize{interface/mybatis:mybatissql}}
mybatis如果不指定,默认超时时间是不做限制的,默认值为0.

mybatis sql配置超时时间有两种方法:

\sphinxstylestrong{1. 全局配置}
\begin{quote}

在mybatis配置文件的settings节点中,增加如下配置

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{settings}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{n}{setting} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{defaultStatementTimeout}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{value}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{25}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{/}\PYG{o}{\PYGZgt{}}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{settings}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

以秒为单位的全局SQL超时时间设置,当超出了设置的超时时间时,会抛出SQLTimeoutException
\end{quote}

\sphinxstylestrong{2. Mapper XML配置}
\begin{quote}

在mapper xml文件中对具体一个sql进行设置,方法为在select/update/insert节点中配置timeout属性,超时时间并只作用于这一个sql.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{insert}
  \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{insert}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{parameterType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{com.test.abc.Person}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{flushCache}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{true}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{statementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PREPARED}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{keyProperty}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{keyColumn}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{useGeneratedKeys}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}
  \PYG{n}{timeout}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\end{quote}


\subsection{Mybatis非法long值问题}
\label{\detokenize{interface/mybatis:mybatislong}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
这个问题是由于V7的JDBC默认把TEXT类型对应为LONGVARCHAR，而Mybatis又把LONGVARCHAR类型默认按照CLOB对象处理，造成和Hibernate非法long值的情形类似，但是Mybatis没有提供方言机制，所以无法像Hibernate那样同过方言包控制，只能把V7的JDBC的TEXT类的值对应到Varchar来处理，就解决非法值问题。

\item {} 
如果用新的JDBC还出此问题，说明用户自己把string类型的jdbcType手动设置为LONGVARCHAR了。解决办法：就是把jdbcType去掉或者设置为VARCAHR即可。

\end{enumerate}


\subsection{Mybatis 报错：字段的类型为 TEXT, 但表达式的类型为 BYTEA你需要重写或转换表达式}
\label{\detokenize{interface/mybatis:mybatis-text-bytea}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
这个问题需要查看出错SQL的mapper文件，需要知道mapper中参数是否指定了类型，从正常逻辑上来说不应该出现这样的转换，应该可通过调整参数类型解决。

\item {} 
这个也可以从JDBC入手，把所有Bind参数设置Oid.BYTEA的全都改为0，让服务器自己推断类型。

\end{enumerate}


\subsection{Mybatis 控制JDBC底层不走预编译}
\label{\detokenize{interface/mybatis:mybatis-jdbc}}
在mapper文件中可以使用statementType标记使用什么的对象操作SQL语句。

statementType：标记操作SQL的对象 ，如statementType=”STATEMENT”

要实现动态传入表名、列名，需要做如下修改，sql里的所有变量取值都改成\$\{xxxx\}，而不是\#\{xxx\}

取值说明：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
STATEMENT:直接操作sql，不进行预编译，获取数据：\$—Statement

\item {} 
PREPARED:预处理，参数，进行预编译，获取数据：\#—–PreparedStatement:默认

\item {} 
CALLABLE:执行存储过程————CallableStatement

\end{enumerate}


\subsection{Mybatis 控制Bind参数}
\label{\detokenize{interface/mybatis:mybatis-bind}}
\#\{\}：相当于JDBC中的PreparedStatement，走Bind报文。

\$\{\}：是输出变量的值，字串替换，不走Bind。

简单说，\#\{\}是经过预编译的，是安全的；\$\{\}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。


\subsection{Mybatis 使用pagehelper插件}
\label{\detokenize{interface/mybatis:mybatis-pagehelper}}
Mybatis使用该插件需要将helperDialect设置成postgresql，如不指定，会报错：com.github.pagehelper.PageException：无法自动获取数据库类型，请通过helperDialect参数指定！
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
直接使用Mybatis设置如下：

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}plugins\PYGZgt{}
           \PYGZlt{}!\PYGZhy{}\PYGZhy{} com.github.pagehelper为PageHelper类所在包名 \PYGZhy{}\PYGZhy{}\PYGZgt{}
           \PYGZlt{}plugin interceptor=\PYGZdq{}com.github.pagehelper.PageInterceptor\PYGZdq{}\PYGZgt{}
                    \PYGZlt{}property name=\PYGZdq{}helperDialect\PYGZdq{} value=\PYGZdq{}postgresql\PYGZdq{} /\PYGZgt{}
           \PYGZlt{}/plugin\PYGZgt{}
\PYGZlt{}/plugins\PYGZgt{}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
springboot整合mybatis使用如下：

\end{enumerate}

在pom文件中引入Pagehelper分页插件：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}!\PYGZhy{}\PYGZhy{} 分页插件 \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}dependency\PYGZgt{}
    \PYGZlt{}groupId\PYGZgt{}com.github.pagehelper\PYGZlt{}/groupId\PYGZgt{}
    \PYGZlt{}artifactId\PYGZgt{}pagehelper\PYGZhy{}spring\PYGZhy{}boot\PYGZhy{}starter\PYGZlt{}/artifactId\PYGZgt{}
    \PYGZlt{}version\PYGZgt{}1.2.5\PYGZlt{}/version\PYGZgt{}
\PYGZlt{}/dependency\PYGZgt{}
\end{sphinxVerbatim}

配置分页插件，打开application.properties，添加如下配置信息：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}分页插件}
\PYG{n}{pagehelper}\PYG{o}{.}\PYG{n}{helper}\PYG{o}{\PYGZhy{}}\PYG{n}{dialect}\PYG{o}{=}\PYG{n}{postgresql}
\end{sphinxVerbatim}


\subsection{Mybatis 使用自动返回主键功能}
\label{\detokenize{interface/mybatis:id1}}
该功能使用在V7仅支持insert语句

建表语句，要求表含有主键，且主键自增：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{create} \PYG{n}{table} \PYG{n}{t\PYGZus{}user} \PYG{p}{(}\PYG{n+nb}{id} \PYG{n+nb}{int} \PYG{n}{identity} \PYG{n}{primary} \PYG{n}{key}\PYG{p}{,}\PYG{n}{username} \PYG{n}{text}\PYG{p}{,}\PYG{n}{password} \PYG{n}{text}\PYG{p}{,}\PYG{n}{sex} \PYG{n}{boolean}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

在mapper文件里配置：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}!\PYGZhy{}\PYGZhy{} useGeneratedKeys：（仅对 insert 有用）这会告诉 MyBatis 使用 JDBC 的getGeneratedKeys方法来取出由数据内部生成的主键。默认值： false。 \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}!\PYGZhy{}\PYGZhy{}keyProperty：（仅对 insert有用）标记一个属性， MyBatis 会通过 getGeneratedKeys或者通过 insert 语句的 selectKey 子元素设置它的值。默认：不设置。 \PYGZhy{}\PYGZhy{}\PYGZgt{}

         \PYGZlt{}insert id=\PYGZdq{}insertUser\PYGZdq{} useGeneratedKeys=\PYGZdq{}true\PYGZdq{} keyProperty=\PYGZdq{}id\PYGZdq{}\PYGZgt{}
                   insert into t\PYGZus{}user (username,password,sex) values
                   (\PYGZsh{}\PYGZob{}username\PYGZcb{},\PYGZsh{}\PYGZob{}password\PYGZcb{},\PYGZsh{}\PYGZob{}sex\PYGZcb{})
         \PYGZlt{}/insert\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}
如果使用tk\sphinxhyphen{}mybatis提供的mapper接口，V7需要mapper包的版本在3.4.0及以上，否则使用update相关的接口时，会报“不能返回generatedkeys或没有指定返回”的错误。
\end{sphinxadmonition}


\subsection{Mybatis配置databaseId}
\label{\detokenize{interface/mybatis:mybatisdatabaseid}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}!\PYGZhy{}\PYGZhy{}数据库厂商标示 \PYGZhy{}\PYGZhy{}\PYGZgt{}
    \PYGZlt{}databaseIdProvider type=\PYGZdq{}DB\PYGZus{}VENDOR\PYGZdq{}\PYGZgt{}
        \PYGZlt{}property name=\PYGZdq{}KingbaseES\PYGZdq{} value=\PYGZdq{}kingbase\PYGZdq{}/\PYGZgt{}
    \PYGZlt{}/databaseIdProvider\PYGZgt{}

\PYGZlt{}select id=\PYGZdq{}getAllProduct\PYGZdq{} resultType=\PYGZdq{}product\PYGZdq{} databaseId=\PYGZdq{}kingbase\PYGZdq{}\PYGZgt{}
        SELECT * FROM product3
\PYGZlt{}/select\PYGZgt{}
\end{sphinxVerbatim}


\subsection{Mybatis使用匿名块插入语句报错}
\label{\detokenize{interface/mybatis:id2}}
Mybatis中使用begin insert ...;insert...; end;格式的语句插入数据，报无法识别的GBK编码：'0x00'或者指定了连接参数prepareThreshold=\sphinxhyphen{}1报Can‘t change resolved type for param:1 from 1043 to 25.该问题属于plsql问题需要升级数据库版本。

在升级数据库版本后，如果出现类型转换错误，则使用强转（例如?::bytea）把其转换为对应类型，出现该错误的原因为匿名块无法识别oid绑定类型为0的参数，会将其默认识别为text，传给下层时无法转换为对应类型，就会报错。特别地，如果字段类型为二进制，如bytea、blob，如果参数内容有数据库无法识别的编码的话，转换成text就会报无法转换的编码错误，此时指定连接参数bytestype=bytea即可。


\subsection{Mybatis使用ScriptRunner执行含plsql的sql脚本报错}
\label{\detokenize{interface/mybatis:mybatisscriptrunnerplsqlsql}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
ScriptRunner默认按照自定义的分隔符每行执行，分隔符默认为分号，如果sql脚本中包含plsql语句，按照分号分割出来的语句是不正确的，所以可以使用setDelimiter(String)来设置自定义的分隔符，如设置分隔符为"/"，则sql脚本中的每条语句后都添加"/"，ScriptRunner将会按照此对语句进行分割，连接KingbaseES时，普通语句之间无需使用分隔符，驱动会对普通语句进行分割；

\item {} 
或者可以通过runner.setSendFullScript(true);设置将sql脚本一次发送，但是由于驱动不会对包含plsql的多语句进行分割，所以会报”无法插入多条命令到一个准备好的语句中“，此时指定jdbc连接参数preferQueryMode=simple走简单查询报文即可。

\end{enumerate}


\subsection{Mybatis使用游标的注册方式}
\label{\detokenize{interface/mybatis:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{select} \PYG{n+nb}{id}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{selectTempManualDataTest}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{statementType}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CALLABLE}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}
        \PYG{p}{\PYGZob{}}\PYG{c+c1}{\PYGZsh{}\PYGZob{}out\PYGZus{}return,mode=OUT,javaType=ResultSet,jdbcType=OTHER, resultMap=tempMap\PYGZcb{} = call proc\PYGZus{}aaaaa() \PYGZcb{}}
    \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{select}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{Note:}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
jdbcType只能设置为OTHER，不能设置为CURSOR，Mybatis的CURSOR的值为\sphinxhyphen{}10，是OracleCURSOR的值，不是Types.REF\_CURSOR的值，我们不支持；

\item {} 
如果没有设置javaType的类型，返回值的类型为ResultSet，如果设置了返回值的类型为ResultSet，则返回值为List对象。

\end{enumerate}
\end{sphinxadmonition}


\subsection{Mybatis写json类型示例}
\label{\detokenize{interface/mybatis:mybatisjson}}
建表：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{create} \PYG{n}{table} \PYG{n}{t\PYGZus{}json}\PYG{p}{(}\PYG{n+nb}{id} \PYG{n}{serial}\PYG{p}{,}\PYG{n}{content} \PYG{n}{json}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

实体类：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{package} \PYG{n}{com}\PYG{o}{.}\PYG{n}{test}\PYG{o}{.}\PYG{n}{entity}\PYG{p}{;}

\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{JsonEntity} \PYG{p}{\PYGZob{}}

   \PYG{n}{private} \PYG{n+nb}{int} \PYG{n+nb}{id}\PYG{p}{;}
   \PYG{n}{private} \PYG{n}{Object} \PYG{n}{fcontent}\PYG{p}{;}

    \PYG{n}{public}  \PYG{n+nb}{int} \PYG{n}{getId}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n+nb}{id}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{public} \PYG{n}{void} \PYG{n}{setId}\PYG{p}{(} \PYG{n+nb}{int} \PYG{n+nb}{id}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{this}\PYG{o}{.}\PYG{n}{id} \PYG{o}{=}  \PYG{n+nb}{id}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{public}  \PYG{n}{Object} \PYG{n}{getContent}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{fcontent}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{n}{public} \PYG{n}{void} \PYG{n}{setContent}\PYG{p}{(}\PYG{n}{Object} \PYG{n}{b}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{n}{this}\PYG{o}{.}\PYG{n}{fcontent} \PYG{o}{=}  \PYG{n}{b}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n+nd}{@Override}
    \PYG{n}{public} \PYG{n}{String} \PYG{n}{toString}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{id=}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{+} \PYG{n}{this}\PYG{o}{.}\PYG{n}{id} \PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{JsonTypeHandler.java}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{package} \PYG{n}{com}\PYG{o}{.}\PYG{n}{test}\PYG{o}{.}\PYG{n}{handler}\PYG{p}{;}

\PYG{k+kn}{import} \PYG{n+nn}{java}\PYG{n+nn}{.}\PYG{n+nn}{sql}\PYG{n+nn}{.}\PYG{n+nn}{CallableStatement}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{java}\PYG{n+nn}{.}\PYG{n+nn}{sql}\PYG{n+nn}{.}\PYG{n+nn}{PreparedStatement}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{java}\PYG{n+nn}{.}\PYG{n+nn}{sql}\PYG{n+nn}{.}\PYG{n+nn}{ResultSet}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{java}\PYG{n+nn}{.}\PYG{n+nn}{sql}\PYG{n+nn}{.}\PYG{n+nn}{SQLException}\PYG{p}{;}

\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{apache}\PYG{n+nn}{.}\PYG{n+nn}{ibatis}\PYG{n+nn}{.}\PYG{n+nn}{type}\PYG{n+nn}{.}\PYG{n+nn}{BaseTypeHandler}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{apache}\PYG{n+nn}{.}\PYG{n+nn}{ibatis}\PYG{n+nn}{.}\PYG{n+nn}{type}\PYG{n+nn}{.}\PYG{n+nn}{JdbcType}\PYG{p}{;}

\PYG{k+kn}{import} \PYG{n+nn}{com}\PYG{n+nn}{.}\PYG{n+nn}{test}\PYG{n+nn}{.}\PYG{n+nn}{utils}\PYG{n+nn}{.}\PYG{n+nn}{JsonUtil}\PYG{p}{;}


\PYG{o}{/}\PYG{o}{/} \PYG{n}{继承自BaseTypeHandler}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}} \PYG{n}{使用Object是为了让JsonUtil可以处理任意类型}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{JsonTypeHandler} \PYG{n}{extends} \PYG{n}{BaseTypeHandler}\PYG{o}{\PYGZlt{}}\PYG{n}{Object}\PYG{o}{\PYGZgt{}} \PYG{p}{\PYGZob{}}

    \PYG{n+nd}{@Override}
    \PYG{n}{public} \PYG{n}{void} \PYG{n}{setNonNullParameter}\PYG{p}{(}\PYG{n}{PreparedStatement} \PYG{n}{ps}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{i}\PYG{p}{,} \PYG{n}{Object} \PYG{n}{parameter}\PYG{p}{,}
            \PYG{n}{JdbcType} \PYG{n}{jdbcType}\PYG{p}{)} \PYG{n}{throws} \PYG{n}{SQLException} \PYG{p}{\PYGZob{}}

        \PYG{n}{ps}\PYG{o}{.}\PYG{n}{setString}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{JsonUtil}\PYG{o}{.}\PYG{n}{stringify}\PYG{p}{(}\PYG{n}{parameter}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n+nd}{@Override}
    \PYG{n}{public} \PYG{n}{Object} \PYG{n}{getNullableResult}\PYG{p}{(}\PYG{n}{ResultSet} \PYG{n}{rs}\PYG{p}{,} \PYG{n}{String} \PYG{n}{columnName}\PYG{p}{)}
            \PYG{n}{throws} \PYG{n}{SQLException} \PYG{p}{\PYGZob{}}

        \PYG{k}{return} \PYG{n}{JsonUtil}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rs}\PYG{o}{.}\PYG{n}{getString}\PYG{p}{(}\PYG{n}{columnName}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Object}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n+nd}{@Override}
    \PYG{n}{public} \PYG{n}{Object} \PYG{n}{getNullableResult}\PYG{p}{(}\PYG{n}{ResultSet} \PYG{n}{rs}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{columnIndex}\PYG{p}{)} \PYG{n}{throws} \PYG{n}{SQLException} \PYG{p}{\PYGZob{}}

        \PYG{k}{return} \PYG{n}{JsonUtil}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{rs}\PYG{o}{.}\PYG{n}{getString}\PYG{p}{(}\PYG{n}{columnIndex}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Object}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n+nd}{@Override}
    \PYG{n}{public} \PYG{n}{Object} \PYG{n}{getNullableResult}\PYG{p}{(}\PYG{n}{CallableStatement} \PYG{n}{cs}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{columnIndex}\PYG{p}{)}
            \PYG{n}{throws} \PYG{n}{SQLException} \PYG{p}{\PYGZob{}}

        \PYG{k}{return} \PYG{n}{JsonUtil}\PYG{o}{.}\PYG{n}{parse}\PYG{p}{(}\PYG{n}{cs}\PYG{o}{.}\PYG{n}{getString}\PYG{p}{(}\PYG{n}{columnIndex}\PYG{p}{)}\PYG{p}{,} \PYG{n}{Object}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{JsonUtil.java}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{package} \PYG{n}{com}\PYG{o}{.}\PYG{n}{test}\PYG{o}{.}\PYG{n}{utils}\PYG{p}{;}


\PYG{k+kn}{import} \PYG{n+nn}{java}\PYG{n+nn}{.}\PYG{n+nn}{io}\PYG{n+nn}{.}\PYG{n+nn}{OutputStream}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{java}\PYG{n+nn}{.}\PYG{n+nn}{text}\PYG{n+nn}{.}\PYG{n+nn}{SimpleDateFormat}\PYG{p}{;}

\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{apache}\PYG{n+nn}{.}\PYG{n+nn}{ibatis}\PYG{n+nn}{.}\PYG{n+nn}{logging}\PYG{n+nn}{.}\PYG{n+nn}{Log}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{apache}\PYG{n+nn}{.}\PYG{n+nn}{ibatis}\PYG{n+nn}{.}\PYG{n+nn}{logging}\PYG{n+nn}{.}\PYG{n+nn}{LogFactory}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{codehaus}\PYG{n+nn}{.}\PYG{n+nn}{jackson}\PYG{n+nn}{.}\PYG{n+nn}{map}\PYG{n+nn}{.}\PYG{n+nn}{DeserializationConfig}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{codehaus}\PYG{n+nn}{.}\PYG{n+nn}{jackson}\PYG{n+nn}{.}\PYG{n+nn}{map}\PYG{n+nn}{.}\PYG{n+nn}{ObjectMapper}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{codehaus}\PYG{n+nn}{.}\PYG{n+nn}{jackson}\PYG{n+nn}{.}\PYG{n+nn}{map}\PYG{n+nn}{.}\PYG{n+nn}{annotate}\PYG{n+nn}{.}\PYG{n+nn}{JsonFilter}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{codehaus}\PYG{n+nn}{.}\PYG{n+nn}{jackson}\PYG{n+nn}{.}\PYG{n+nn}{map}\PYG{n+nn}{.}\PYG{n+nn}{ser}\PYG{n+nn}{.}\PYG{n+nn}{impl}\PYG{n+nn}{.}\PYG{n+nn}{SimpleBeanPropertyFilter}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{codehaus}\PYG{n+nn}{.}\PYG{n+nn}{jackson}\PYG{n+nn}{.}\PYG{n+nn}{map}\PYG{n+nn}{.}\PYG{n+nn}{ser}\PYG{n+nn}{.}\PYG{n+nn}{impl}\PYG{n+nn}{.}\PYG{n+nn}{SimpleFilterProvider}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{springframework}\PYG{n+nn}{.}\PYG{n+nn}{core}\PYG{n+nn}{.}\PYG{n+nn}{annotation}\PYG{n+nn}{.}\PYG{n+nn}{AnnotationUtils}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{codehaus}\PYG{n+nn}{.}\PYG{n+nn}{jackson}\PYG{n+nn}{.}\PYG{n+nn}{map}\PYG{n+nn}{.}\PYG{n+nn}{SerializationConfig}\PYG{p}{;}

\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{JsonUtil} \PYG{p}{\PYGZob{}}

    \PYG{n}{private} \PYG{n}{static} \PYG{n}{Log} \PYG{n}{log} \PYG{o}{=} \PYG{n}{LogFactory}\PYG{o}{.}\PYG{n}{getLog}\PYG{p}{(}\PYG{n}{JsonUtil}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)}\PYG{p}{;}

    \PYG{n}{private} \PYG{n}{static} \PYG{n}{ObjectMapper} \PYG{n}{objectMapper} \PYG{o}{=} \PYG{n}{null}\PYG{p}{;}

    \PYG{n}{static} \PYG{p}{\PYGZob{}}

        \PYG{n}{objectMapper} \PYG{o}{=} \PYG{n}{new} \PYG{n}{ObjectMapper}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

        \PYG{n}{objectMapper}\PYG{o}{.}\PYG{n}{setDateFormat}\PYG{p}{(}\PYG{n}{new} \PYG{n}{SimpleDateFormat}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{yyyy\PYGZhy{}mm\PYGZhy{}dd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{objectMapper}\PYG{o}{.}\PYG{n}{disable}\PYG{p}{(}\PYG{n}{DeserializationConfig}\PYG{o}{.}\PYG{n}{Feature}\PYG{o}{.}\PYG{n}{FAIL\PYGZus{}ON\PYGZus{}UNKNOWN\PYGZus{}PROPERTIES}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{objectMapper}\PYG{o}{.}\PYG{n}{configure}\PYG{p}{(}\PYG{n}{SerializationConfig}\PYG{o}{.}\PYG{n}{Feature}\PYG{o}{.}\PYG{n}{FAIL\PYGZus{}ON\PYGZus{}EMPTY\PYGZus{}BEANS}\PYG{p}{,} \PYG{n}{false}\PYG{p}{)}\PYG{p}{;}
        \PYG{n}{objectMapper}\PYG{o}{.}\PYG{n}{setFilters}\PYG{p}{(}\PYG{n}{new} \PYG{n}{SimpleFilterProvider}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{setFailOnUnknownId}\PYG{p}{(}\PYG{n}{false}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{o}{/}\PYG{o}{*}
    \PYG{n}{public} \PYG{n}{static} \PYG{n}{JsonUtil} \PYG{n}{getInstance}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{instance} \PYG{o}{==} \PYG{n}{null}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{synchronized} \PYG{p}{(}\PYG{n}{JsonUtil}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                \PYG{k}{if} \PYG{p}{(}\PYG{n}{instance} \PYG{o}{==} \PYG{n}{null}\PYG{p}{)} \PYG{p}{\PYGZob{}}
                    \PYG{n}{instance} \PYG{o}{=} \PYG{n}{new} \PYG{n}{JsonUtil}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
                \PYG{p}{\PYGZcb{}}
            \PYG{p}{\PYGZcb{}}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{return} \PYG{n}{instance}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{o}{*}\PYG{o}{/}

    \PYG{n}{public} \PYG{n}{static} \PYG{n}{String} \PYG{n}{stringify}\PYG{p}{(}\PYG{n}{Object} \PYG{n+nb}{object}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{try} \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{objectMapper}\PYG{o}{.}\PYG{n}{writeValueAsString}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}} \PYG{n}{catch} \PYG{p}{(}\PYG{n+ne}{Exception} \PYG{n}{e}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{log}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{n}{e}\PYG{o}{.}\PYG{n}{getMessage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{return} \PYG{n}{null}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{public} \PYG{n}{static} \PYG{n}{String} \PYG{n}{stringify}\PYG{p}{(}\PYG{n}{Object} \PYG{n+nb}{object}\PYG{p}{,} \PYG{n}{String}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{properties}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{try} \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{objectMapper}
                    \PYG{o}{.}\PYG{n}{writer}\PYG{p}{(}\PYG{n}{new} \PYG{n}{SimpleFilterProvider}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{addFilter}\PYG{p}{(}\PYG{n}{AnnotationUtils}\PYG{o}{.}\PYG{n}{getValue}\PYG{p}{(}
                        \PYG{n}{AnnotationUtils}\PYG{o}{.}\PYG{n}{findAnnotation}\PYG{p}{(}\PYG{n+nb}{object}\PYG{o}{.}\PYG{n}{getClass}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{JsonFilter}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{toString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                                \PYG{n}{SimpleBeanPropertyFilter}\PYG{o}{.}\PYG{n}{filterOutAllExcept}\PYG{p}{(}\PYG{n}{properties}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
                    \PYG{o}{.}\PYG{n}{writeValueAsString}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}} \PYG{n}{catch} \PYG{p}{(}\PYG{n+ne}{Exception} \PYG{n}{e}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{log}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{n}{e}\PYG{o}{.}\PYG{n}{getMessage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{return} \PYG{n}{null}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{public} \PYG{n}{static} \PYG{n}{void} \PYG{n}{stringify}\PYG{p}{(}\PYG{n}{OutputStream} \PYG{n}{out}\PYG{p}{,} \PYG{n}{Object} \PYG{n+nb}{object}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{try} \PYG{p}{\PYGZob{}}
            \PYG{n}{objectMapper}\PYG{o}{.}\PYG{n}{writeValue}\PYG{p}{(}\PYG{n}{out}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}} \PYG{n}{catch} \PYG{p}{(}\PYG{n+ne}{Exception} \PYG{n}{e}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{log}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{n}{e}\PYG{o}{.}\PYG{n}{getMessage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{public} \PYG{n}{static} \PYG{n}{void} \PYG{n}{stringify}\PYG{p}{(}\PYG{n}{OutputStream} \PYG{n}{out}\PYG{p}{,} \PYG{n}{Object} \PYG{n+nb}{object}\PYG{p}{,} \PYG{n}{String}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.} \PYG{n}{properties}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{try} \PYG{p}{\PYGZob{}}
            \PYG{n}{objectMapper}\PYG{o}{.}\PYG{n}{writer}\PYG{p}{(}\PYG{n}{new} \PYG{n}{SimpleFilterProvider}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{addFilter}\PYG{p}{(}
                        \PYG{n}{AnnotationUtils}\PYG{o}{.}\PYG{n}{getValue}\PYG{p}{(}\PYG{n}{AnnotationUtils}\PYG{o}{.}\PYG{n}{findAnnotation}\PYG{p}{(}\PYG{n+nb}{object}\PYG{o}{.}\PYG{n}{getClass}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{JsonFilter}\PYG{o}{.}\PYG{n}{class}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{toString}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}
                            \PYG{n}{SimpleBeanPropertyFilter}\PYG{o}{.}\PYG{n}{filterOutAllExcept}\PYG{p}{(}\PYG{n}{properties}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{o}{.}\PYG{n}{writeValue}\PYG{p}{(}\PYG{n}{out}\PYG{p}{,} \PYG{n+nb}{object}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}} \PYG{n}{catch} \PYG{p}{(}\PYG{n+ne}{Exception} \PYG{n}{e}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{log}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{n}{e}\PYG{o}{.}\PYG{n}{getMessage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}
    \PYG{p}{\PYGZcb{}}

    \PYG{n}{public} \PYG{n}{static} \PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{T} \PYG{n}{parse}\PYG{p}{(}\PYG{n}{String} \PYG{n}{json}\PYG{p}{,} \PYG{n}{Class}\PYG{o}{\PYGZlt{}}\PYG{n}{T}\PYG{o}{\PYGZgt{}} \PYG{n}{clazz}\PYG{p}{)} \PYG{p}{\PYGZob{}}

        \PYG{k}{if} \PYG{p}{(}\PYG{n}{json} \PYG{o}{==} \PYG{n}{null} \PYG{o}{|}\PYG{o}{|} \PYG{n}{json}\PYG{o}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{null}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{try} \PYG{p}{\PYGZob{}}
            \PYG{k}{return} \PYG{n}{objectMapper}\PYG{o}{.}\PYG{n}{readValue}\PYG{p}{(}\PYG{n}{json}\PYG{p}{,} \PYG{n}{clazz}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}} \PYG{n}{catch} \PYG{p}{(}\PYG{n+ne}{Exception} \PYG{n}{e}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{log}\PYG{o}{.}\PYG{n}{error}\PYG{p}{(}\PYG{n}{e}\PYG{o}{.}\PYG{n}{getMessage}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{e}\PYG{p}{)}\PYG{p}{;}
        \PYG{p}{\PYGZcb{}}

        \PYG{k}{return} \PYG{n}{null}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

映射文件：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{} encoding=\PYGZdq{}UTF\PYGZhy{}8\PYGZdq{}?\PYGZgt{}
\PYGZlt{}!DOCTYPE mapper
PUBLIC \PYGZdq{}\PYGZhy{}//mybatis.org//DTD Mapper 3.0//EN\PYGZdq{}
\PYGZdq{}http://mybatis.org/dtd/mybatis\PYGZhy{}3\PYGZhy{}mapper.dtd\PYGZdq{}\PYGZgt{}
\PYGZlt{}mapper namespace=\PYGZdq{}com.test.interfaces.MybatisDao\PYGZdq{}\PYGZgt{}


   \PYGZlt{}!\PYGZhy{}\PYGZhy{} json的相关SQL指令 \PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}resultMap id=\PYGZdq{}JsonTableMap\PYGZdq{} type=\PYGZdq{}JsonEntity\PYGZdq{}\PYGZgt{}
       \PYGZlt{}result column=\PYGZdq{}id\PYGZdq{} property=\PYGZdq{}id\PYGZdq{} /\PYGZgt{}
       \PYGZlt{}result column=\PYGZdq{}content\PYGZdq{} property=\PYGZdq{}fcontent\PYGZdq{} typeHandler = \PYGZdq{}com.test.handler.JsonTypeHandler\PYGZdq{}/\PYGZgt{}
   \PYGZlt{}/resultMap\PYGZgt{}

   \PYGZlt{}select id=\PYGZdq{}selectJsonTableList\PYGZdq{} resultMap=\PYGZdq{}JsonTableMap\PYGZdq{}\PYGZgt{}
      select * from \PYGZdl{}\PYGZob{}name\PYGZcb{}
   \PYGZlt{}/select\PYGZgt{}
   \PYGZlt{}select id=\PYGZdq{}selectJsonTableByID\PYGZdq{} resultMap=\PYGZdq{}JsonTableMap\PYGZdq{}\PYGZgt{}
      select * from t\PYGZus{}json where id=\PYGZsh{}\PYGZob{}id\PYGZcb{}
   \PYGZlt{}/select\PYGZgt{}
    \PYGZlt{}insert id=\PYGZdq{}insertJsonTable\PYGZdq{}\PYGZgt{}
        insert into t\PYGZus{}json (content) values ((\PYGZsh{}\PYGZob{}fcontent, typeHandler=com.test.handler.JsonTypeHandler\PYGZcb{})::json)
    \PYGZlt{}/insert\PYGZgt{}
    \PYGZlt{}update id=\PYGZdq{}updateJsonTable\PYGZdq{} parameterType=\PYGZdq{}JsonEntity\PYGZdq{} \PYGZgt{}
        update t\PYGZus{}json set content=(\PYGZsh{}\PYGZob{}fcontent, typeHandler=com.test.handler.JsonTypeHandler\PYGZcb{})::json where t\PYGZus{}json.id=\PYGZsh{}\PYGZob{}id\PYGZcb{}
    \PYGZlt{}/update\PYGZgt{}
    \PYGZlt{}delete id=\PYGZdq{}deleteJsonTable\PYGZdq{}\PYGZgt{}
        delete from \PYGZdl{}\PYGZob{}name\PYGZcb{}
    \PYGZlt{}/delete\PYGZgt{}
\PYGZlt{}/mapper\PYGZgt{}
\end{sphinxVerbatim}


\section{Mybatis\sphinxhyphen{}plus常见问题}
\label{\detokenize{interface/mybatis-plus:mybatis-plus}}\label{\detokenize{interface/mybatis-plus::doc}}

\subsection{Mybatis\sphinxhyphen{}plus使用}
\label{\detokenize{interface/mybatis-plus:id1}}
Mybatis\sphinxhyphen{}plus适配KingbaseES，只使用基本功能，无需替换jar包，可正常使用。如需使用分页功能和代码生成器需替换jar包，目前提供了2.2.0和3.1.2两个版本。使用分页插件配置，需配置方言类型，类型为kingbasees，如：<property name="dialectType" value="kingbasees" />，其余正常使用即可，同时支持V7和V8。如只使用mybatis\sphinxhyphen{}plus的分页插件，也可不替换jar包，将dialectType配置为postgresql即可。

例如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}property name=\PYGZdq{}plugins\PYGZdq{}\PYGZgt{}
         \PYGZlt{}array\PYGZgt{}
                   \PYGZlt{}!\PYGZhy{}\PYGZhy{} 分页插件配置 \PYGZhy{}\PYGZhy{}\PYGZgt{}
                   \PYGZlt{}bean id=\PYGZdq{}paginationInterceptor\PYGZdq{}
                                              class=\PYGZdq{}com.baomidou.mybatisplus.plugins.PaginationInterceptor\PYGZdq{}\PYGZgt{}
                            \PYGZlt{}property name=\PYGZdq{}dialectType\PYGZdq{} value=\PYGZdq{}kingbasees\PYGZdq{} /\PYGZgt{}
                   \PYGZlt{}/bean\PYGZgt{}
         \PYGZlt{}/array\PYGZgt{}
\PYGZlt{}/property\PYGZgt{}
\end{sphinxVerbatim}


\section{Activiti使用常见问题}
\label{\detokenize{interface/activiti:activiti}}\label{\detokenize{interface/activiti::doc}}

\subsection{Activiti使用}
\label{\detokenize{interface/activiti:id1}}
Activiti使用报错：org.activiti.engine.ActivitiException: couldn't deduct database type from database product name 'KingbaseES'，是因为Activiti不支持国产数据库。适配KingbaseES，修改方式有两种：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
将Activiti参数databaseType配置为postgres。配置示例如下：

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}bean id=\PYGZdq{}processEngineConfiguration\PYGZdq{} class=\PYGZdq{}org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration\PYGZdq{}\PYGZgt{}
        \PYGZlt{}property name=\PYGZdq{}jdbcDriver\PYGZdq{} value=\PYGZdq{}com.kingbase8.Driver\PYGZdq{}\PYGZgt{}\PYGZlt{}/property\PYGZgt{}
        \PYGZlt{}property name=\PYGZdq{}jdbcUrl\PYGZdq{} value=\PYGZdq{}jdbc:kingbase8://192.168.222.128:54321/TEST\PYGZdq{}\PYGZgt{}\PYGZlt{}/property\PYGZgt{}
        \PYGZlt{}property name=\PYGZdq{}jdbcUsername\PYGZdq{} value=\PYGZdq{}SYSTEM\PYGZdq{}\PYGZgt{}\PYGZlt{}/property\PYGZgt{}
        \PYGZlt{}property name=\PYGZdq{}jdbcPassword\PYGZdq{} value=\PYGZdq{}123456\PYGZdq{}\PYGZgt{}\PYGZlt{}/property\PYGZgt{}
        \PYGZlt{}!\PYGZhy{}\PYGZhy{} 没有表创建表 \PYGZhy{}\PYGZhy{}\PYGZgt{}
        \PYGZlt{}property name=\PYGZdq{}databaseSchemaUpdate\PYGZdq{} value=\PYGZdq{}true\PYGZdq{}\PYGZgt{}\PYGZlt{}/property\PYGZgt{}
        \PYGZlt{}property name=\PYGZdq{}databaseType\PYGZdq{} value=\PYGZdq{}postgres\PYGZdq{}\PYGZgt{}\PYGZlt{}/property\PYGZgt{}
 \PYGZlt{}/bean\PYGZgt{}
\end{sphinxVerbatim}

该方法会在第二次启动时出现自动建表表已存在问题（这是因为R3默认为大写，pg为小写），解决方案为在表建成功后，将参数databaseSchemaUpdate的值改为none。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n+nb}{property} \PYG{n}{name}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{databaseSchemaUpdate}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{value}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{none}\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n+nb}{property}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

SpringBoot整合Activiti时，无法直接配置databaseType参数，因为activiti\sphinxhyphen{}spring\sphinxhyphen{}boot\sphinxhyphen{}starter\sphinxhyphen{}basic里没有提供该参数。可以更换新的驱动包（官网的驱动包即可），然后配置连接参数productName=PostgreSQL，如：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
jdbc:kingbase8://192.168.222.128:54321/TEST?productName=PostgreSQL
\end{sphinxVerbatim}

如果无法更换驱动包，则需要自行扩展配置。添加如下两个文件：

\sphinxstylestrong{ActivitiConfig.java}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
package com.example.activiti.config;

import java.io.IOException;

import javax.sql.DataSource;

import org.activiti.spring.SpringAsyncExecutor;
import org.activiti.spring.SpringProcessEngineConfiguration;
import org.activiti.spring.boot.AbstractProcessEngineAutoConfiguration;
import org.activiti.spring.boot.ActivitiProperties;
import org.activiti.spring.boot.JpaProcessEngineAutoConfiguration;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.AutoConfigureAfter;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;
import org.springframework.transaction.PlatformTransactionManager;

@Configuration
@AutoConfigureAfter(\PYGZob{} DataSourceAutoConfiguration.class \PYGZcb{})
@AutoConfigureBefore(\PYGZob{} JpaProcessEngineAutoConfiguration.class \PYGZcb{})
public class ActivitiConfig \PYGZob{}

   @Configuration
   @EnableConfigurationProperties(\PYGZob{} ActivitiProperties.class \PYGZcb{})
   public static class ActivitiConfiguration extends AbstractProcessEngineAutoConfiguration \PYGZob{}
      private ActivitiDatasourceProperties activitiDatasourceProperties;

      public ActivitiDatasourceProperties getActivitiDatasourceProperties() \PYGZob{}
         return activitiDatasourceProperties;
      \PYGZcb{}

      @Autowired
      public void setActivitiDatasourceProperties(ActivitiDatasourceProperties activitiDatasourceProperties) \PYGZob{}
         this.activitiDatasourceProperties = activitiDatasourceProperties;
      \PYGZcb{}

      @Bean
      @ConditionalOnMissingBean
      public PlatformTransactionManager transactionManager(DataSource dataSource) \PYGZob{}
         return new DataSourceTransactionManager(dataSou\PYGZhy{}rce);
      \PYGZcb{}

      @Bean
      @ConditionalOnMissingBean
      public SpringProcessEngineConfiguration springProcessEngineConfiguration(DataSource dataSource,
            PlatformTransactionManager transactionManager, SpringAsyncExecutor springAsyncExecutor)
            throws IOException \PYGZob{}
         SpringProcessEngineConfiguration config = baseSpringProcessEngineConfiguration(dataSource,
               transactionManager, springAsyncExecutor);
         config.setDatabaseType(this.activitiDatasourceProperties.getDatabaseType());
         return config;
      \PYGZcb{}
   \PYGZcb{}
\PYGZcb{}
\end{sphinxVerbatim}

\sphinxstylestrong{ActivitiDatasourceProperties.java}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{package} \PYG{n}{com}\PYG{o}{.}\PYG{n}{example}\PYG{o}{.}\PYG{n}{activiti}\PYG{o}{.}\PYG{n}{config}\PYG{p}{;}

\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{springframework}\PYG{n+nn}{.}\PYG{n+nn}{boot}\PYG{n+nn}{.}\PYG{n+nn}{context}\PYG{n+nn}{.}\PYG{n+nn}{properties}\PYG{n+nn}{.}\PYG{n+nn}{ConfigurationProperties}\PYG{p}{;}
\PYG{k+kn}{import} \PYG{n+nn}{org}\PYG{n+nn}{.}\PYG{n+nn}{springframework}\PYG{n+nn}{.}\PYG{n+nn}{stereotype}\PYG{n+nn}{.}\PYG{n+nn}{Component}\PYG{p}{;}

\PYG{n+nd}{@ConfigurationProperties}\PYG{p}{(}\PYG{n}{prefix} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{spring.activiti}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n+nd}{@Component}
\PYG{n}{public} \PYG{k}{class} \PYG{n+nc}{ActivitiDatasourceProperties} \PYG{p}{\PYGZob{}}

   \PYG{n}{private} \PYG{n}{String} \PYG{n}{databaseType}\PYG{p}{;}

   \PYG{n}{public} \PYG{n}{String} \PYG{n}{getDatabaseType}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{databaseType}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

   \PYG{n}{public} \PYG{n}{void} \PYG{n}{setDatabaseType}\PYG{p}{(}\PYG{n}{String} \PYG{n}{databaseType}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{n}{this}\PYG{o}{.}\PYG{n}{databaseType} \PYG{o}{=} \PYG{n}{databaseType}\PYG{p}{;}
   \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstylestrong{application.properties}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}数据库类型，必须配置}
\PYG{n}{spring}\PYG{o}{.}\PYG{n}{activiti}\PYG{o}{.}\PYG{n}{database}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{type}\PYG{o}{=}\PYG{n}{postgres}
\PYG{c+c1}{\PYGZsh{}第一次执行配置为true，自动建表，之后执行改为none}
\PYG{n}{spring}\PYG{o}{.}\PYG{n}{activiti}\PYG{o}{.}\PYG{n}{database}\PYG{o}{\PYGZhy{}}\PYG{n}{schema}\PYG{o}{\PYGZhy{}}\PYG{n}{update}\PYG{o}{=}\PYG{n}{none}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
替换activiti\sphinxhyphen{}engine.jar包，目前R2、R3支持5.10,5.14,5.20,5.21.0,6.0.0五个版本，使用该方式无需配置databaseType，也不会出现自动建表表已存在问题，但是支持版本较少，activiti各版本之间不通用，所以推荐使用第一种方式。

\end{enumerate}


\section{Maven 仓库使用常见问题}
\label{\detokenize{interface/maven:maven}}\label{\detokenize{interface/maven::doc}}

\subsection{Maven本地仓库使用KingbaseES的JDBC驱动}
\label{\detokenize{interface/maven:mavenkingbaseesjdbc}}
需要在本地仓库上方我们的JDBC驱动文件，注意目录结构
\begin{itemize}
\item {} 
GroupID是文件目录名字，每一个. 都是一级目录

\item {} 
artifactId 是里面的目录名字

\item {} 
version 是更里面的目录名字

\item {} 
最后文件名构成是  artifactId\sphinxhyphen{}version.jar

\end{itemize}

例如V82的JDBC驱动在pom.xml中配置如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}dependency\PYGZgt{}
      \PYGZlt{}groupId\PYGZgt{}com.kingbase8\PYGZlt{}/groupId\PYGZgt{}
      \PYGZlt{}artifactId\PYGZgt{}kingbase8\PYGZlt{}/artifactId\PYGZgt{}
      \PYGZlt{}version\PYGZgt{}8.2.0\PYGZlt{}/version\PYGZgt{}
      \PYGZlt{}!\PYGZhy{}\PYGZhy{} scope\PYGZgt{}system\PYGZlt{}/scope\PYGZgt{}
   \PYGZlt{}systemPath\PYGZgt{}\PYGZdl{}\PYGZob{}project.basedir\PYGZcb{}/lib/kingbase8\PYGZhy{}8.2.0.jar\PYGZlt{}/systemPath\PYGZhy{}\PYGZhy{}\PYGZgt{}
   \PYGZlt{}/dependency\PYGZgt{}
\end{sphinxVerbatim}

V82的JDBC驱动对应的本地仓库目录：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{E}\PYG{p}{:}\PYGZbs{}\PYG{n}{maven\PYGZus{}repository\PYGZus{}325}\PYGZbs{}\PYG{n}{com}\PYGZbs{}\PYG{n}{kingbase8}\PYGZbs{}\PYG{n}{kingbase8}\PYGZbs{}\PYG{l+m+mf}{8.2}\PYG{o}{.}\PYG{l+m+mi}{0}\PYGZbs{}\PYG{n}{kingbase8}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{8.2}\PYG{o}{.}\PYG{l+m+mf}{0.}\PYG{n}{jar}
\end{sphinxVerbatim}


\subsection{Maven本地仓库使用KingbaseES的dialect方言包}
\label{\detokenize{interface/maven:mavenkingbaseesdialect}}
直接举例说明

例如Hibernate的4.3.2方言包在pom.xml中配置如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}\PYG{n}{org}\PYG{o}{.}\PYG{n}{hibernate}\PYG{o}{.}\PYG{n}{dialect}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{groupId}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}\PYG{n}{hibernate}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{artifactId}\PYG{o}{\PYGZgt{}}
      \PYG{o}{\PYGZlt{}}\PYG{n}{version}\PYG{o}{\PYGZgt{}}\PYG{l+m+mf}{4.3}\PYG{o}{.}\PYG{l+m+mi}{2}\PYG{n}{finaldialect}\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{version}\PYG{o}{\PYGZgt{}}
   \PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{dependency}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}

Hibernate的4.3.2方言包对应的本地仓库目录：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{E}\PYG{p}{:}\PYGZbs{}\PYG{n}{maven\PYGZus{}repository\PYGZus{}325}\PYGZbs{}\PYG{n}{org}\PYGZbs{}\PYG{n}{hibernate}\PYGZbs{}\PYG{n}{dialect}\PYGZbs{}\PYG{n}{hibernate}\PYGZbs{}\PYG{l+m+mf}{4.3}\PYG{o}{.}\PYG{l+m+mi}{2}\PYG{n}{finaldialect}\PYGZbs{}\PYG{n}{hibernate}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{4.3}\PYG{o}{.}\PYG{l+m+mi}{2}\PYG{n}{finaldialect}\PYG{o}{.}\PYG{n}{jar}
\end{sphinxVerbatim}


\section{Druid 数据库连接池配置问题}
\label{\detokenize{interface/druid:druid}}\label{\detokenize{interface/druid::doc}}

\subsection{Druid 配置国产金仓数据库}
\label{\detokenize{interface/druid:id1}}
需要配置driverClassName才能支持国产数据库

Druid 金仓V8数据源的配置例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
jdbc.driverClassName=com.kingbase8.Driver
jdbc.url=jdbc:kingbase8://127.0.0.1:54321/test
jdbc.username=root
jdbc.password=1qaz!QAZ
filters= stat,log4j
(filters常用种类：
监控统计用的filter:stat
日志用的filter:log4j
防御sql注入的filter:wall目前不支持国产数据库)
\end{sphinxVerbatim}

配置了wall过滤器。配置了wall过滤器后，如果配置了dbType可以解决该异常，但是有些语句的语法Druid无法解析，会抛出其他的异常，所以不要配置wall。


\subsection{Druid 配置例子}
\label{\detokenize{interface/druid:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
 \PYGZlt{}bean id=\PYGZdq{}dataSource\PYGZdq{} class=\PYGZdq{}com.alibaba.druid.pool.DruidDataSource\PYGZdq{}
  init\PYGZhy{}method=\PYGZdq{}init\PYGZdq{} destroy\PYGZhy{}method=\PYGZdq{}close\PYGZdq{}\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}driverClassName\PYGZdq{} value=\PYGZdq{}\PYGZdl{}\PYGZob{}jdbc.driverClassName\PYGZcb{}\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}url\PYGZdq{} value=\PYGZdq{}\PYGZdl{}\PYGZob{}jdbc.url\PYGZcb{}\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}username\PYGZdq{} value=\PYGZdq{}\PYGZdl{}\PYGZob{}jdbc.username\PYGZcb{}\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}password\PYGZdq{} value=\PYGZdq{}\PYGZdl{}\PYGZob{}jdbc.password\PYGZcb{}\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{} 配置初始化大小、最小、最大 \PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}initialSize\PYGZdq{} value=\PYGZdq{}10\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}minIdle\PYGZdq{} value=\PYGZdq{}10\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}maxActive\PYGZdq{} value=\PYGZdq{}100\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{} 配置获取连接等待超时的时间 单位毫秒\PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}maxWait\PYGZdq{} value=\PYGZdq{}10000\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{} 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
有两个含义:
Destroy线程会检测连接的间隔时间;
testWhileIdle的判断依据，详细看testWhileIdle属性的说明\PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}timeBetweenEvictionRunsMillis\PYGZdq{} value=\PYGZdq{}60000\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{} 配置一个连接在池中最小生存的时间，单位是毫秒
Destory线程中如果检测到当前连接的最后活跃时间和当前时间的差值大于
minEvictableIdleTimeMillis，则关闭当前连接 \PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}minEvictableIdleTimeMillis\PYGZdq{} value=\PYGZdq{}18000000\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}testWhileIdle\PYGZdq{} value=\PYGZdq{}true\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{} 这里建议配置为TRUE，防止取到的连接不可用 \PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}testOnBorrow\PYGZdq{} value=\PYGZdq{}true\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}testOnReturn\PYGZdq{} value=\PYGZdq{}false\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{} 这里配置提交方式，默认就是TRUE，可以不用配置 \PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}defaultAutoCommit\PYGZdq{} value=\PYGZdq{}true\PYGZdq{} /\PYGZgt{}
  \PYGZlt{}!\PYGZhy{}\PYGZhy{} 验证连接有效与否的SQL，不同的数据配置不同 \PYGZhy{}\PYGZhy{}\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}validationQuery\PYGZdq{} value=\PYGZdq{}select 1 \PYGZdq{} /\PYGZgt{}
  \PYGZlt{}property name=\PYGZdq{}filters\PYGZdq{} value=\PYGZdq{}stat\PYGZdq{} /\PYGZgt{}
 \PYGZlt{}/bean\PYGZgt{}
\end{sphinxVerbatim}


\subsection{Druid的连接强制回收}
\label{\detokenize{interface/druid:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}!\PYGZhy{}\PYGZhy{} 连接泄露检查，打开removeAbandoned功能 , 连接从连接池借出后，长时间不归还，将触发强制回连接。回收周期随timeBetweenEvictionRunsMillis进行，如果连接为从连接池借出状态，并且未执行任何sql，并且从借出时间起已超过removeAbandonedTimeout时间，则强制归还连接到连接池中。
removeAbandoned是连接池的高级功能，理论上这中配置不应该出现在实际的生产环境，因为有时应用程序执行长事务，可能这种情况下，会被连接池误回收，该种配置一般在程序测试阶段，为了定位连接泄漏的具体代码位置，被开启。
生产环境中连接的关闭应该靠程序自己保证 \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}property name=\PYGZdq{}removeAbandoned\PYGZdq{} value=\PYGZdq{}false\PYGZdq{} /\PYGZgt{}
\PYGZlt{}!\PYGZhy{}\PYGZhy{} 超时时间，秒 \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}property name=\PYGZdq{}removeAbandonedTimeout\PYGZdq{} value=\PYGZdq{}80\PYGZdq{}/\PYGZgt{}
\PYGZlt{}!\PYGZhy{}\PYGZhy{} 关闭abanded连接时输出错误日志，这样出现连接泄露时可以通过错误日志定位忘记关闭连接的位置 \PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}property name=\PYGZdq{}logAbandoned\PYGZdq{} value=\PYGZdq{}true\PYGZdq{} /\PYGZgt{}
\end{sphinxVerbatim}


\section{C3P0连接池配置问题}
\label{\detokenize{interface/c3p0:c3p0}}\label{\detokenize{interface/c3p0::doc}}

\subsection{常用C3p0配置金仓V8数据库}
\label{\detokenize{interface/c3p0:c3p0v8}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}c3p0\PYGZhy{}config\PYGZgt{}
       \PYGZlt{}named\PYGZhy{}config name=\PYGZdq{}database\PYGZdq{}\PYGZgt{}
    \PYGZlt{}property name=\PYGZdq{}user\PYGZdq{}\PYGZgt{}SYSTEM\PYGZlt{}/property\PYGZgt{}
    \PYGZlt{}property name=\PYGZdq{}password\PYGZdq{}\PYGZgt{}MANAGER\PYGZlt{}/property\PYGZgt{}
    \PYGZlt{}property name=\PYGZdq{}driverClass\PYGZdq{}\PYGZgt{}com. kingbase8.Driver\PYGZlt{}/property\PYGZgt{}
    \PYGZlt{}property name=\PYGZdq{}jdbcUrl\PYGZdq{}\PYGZgt{}jdbc:kingbase8://127.0.0.1:54321/TEST \PYGZlt{}/property\PYGZgt{}
\PYGZlt{}property name=\PYGZdq{}initialPoolSize\PYGZdq{}\PYGZgt{}2\PYGZlt{}/property\PYGZgt{}
    \PYGZlt{}property name=\PYGZdq{}maxPoolSize\PYGZdq{}\PYGZgt{}100\PYGZlt{}/property\PYGZgt{}
\PYGZlt{}property name=\PYGZdq{}minPoolSize\PYGZdq{}\PYGZgt{}10\PYGZlt{}/property\PYGZgt{}

\PYGZlt{}!\PYGZhy{}\PYGZhy{}最大空闲时间,单位秒,指定的时间内未使用则连接被丢弃。Default: 0永不丢弃\PYGZhy{}\PYGZhy{}\PYGZgt{}
\PYGZlt{}property name=\PYGZdq{}maxIdleTime\PYGZdq{}\PYGZgt{}1800\PYGZlt{}/property\PYGZgt{}
\PYGZlt{}!\PYGZhy{}\PYGZhy{}连接有效性检测\PYGZhy{}\PYGZhy{}\PYGZgt{}
        \PYGZlt{}property name=\PYGZdq{}preferredTestQuery\PYGZdq{}\PYGZgt{}select 1 from dual\PYGZlt{}/property\PYGZgt{}
        \PYGZlt{}!\PYGZhy{}\PYGZhy{}当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 \PYGZhy{}\PYGZhy{}\PYGZgt{}
        \PYGZlt{}property name=\PYGZdq{}acquireIncrement\PYGZdq{}\PYGZgt{}3\PYGZlt{}/property\PYGZgt{}
       \PYGZlt{}/named\PYGZhy{}config\PYGZgt{}
\PYGZlt{}/c3p0\PYGZhy{}config\PYGZgt{}
\end{sphinxVerbatim}


\section{DBCP连接池配置问题}
\label{\detokenize{interface/DBCP:dbcp}}\label{\detokenize{interface/DBCP::doc}}

\subsection{常用dbcp配置金仓V8数据库}
\label{\detokenize{interface/DBCP:dbcpv8}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}bean id=\PYGZdq{}dataSource\PYGZus{}dbcp\PYGZdq{}
      class=\PYGZdq{}org.apache.commons.dbcp.BasicDataSource\PYGZdq{} destroy\PYGZhy{}method=\PYGZdq{}close\PYGZdq{}\PYGZgt{}\PYGZlt{}!\PYGZhy{}\PYGZhy{}设置为close使Spring容器关闭同时数据源能够正常关闭，以免造成连接泄露 \PYGZhy{}\PYGZhy{}\PYGZgt{}
      \PYGZlt{}property name=\PYGZdq{}driverClassName\PYGZdq{} value=\PYGZdq{}\PYGZdl{}\PYGZob{}jdbc.driver\PYGZcb{}\PYGZdq{} /\PYGZgt{}
      \PYGZlt{}property name=\PYGZdq{}url\PYGZdq{} value=\PYGZdq{}\PYGZdl{}\PYGZob{}jdbc.url\PYGZcb{}\PYGZdq{} /\PYGZgt{}
      \PYGZlt{}property name=\PYGZdq{}username\PYGZdq{} value=\PYGZdq{}\PYGZdl{}\PYGZob{}jdbc.username\PYGZcb{}\PYGZdq{} /\PYGZgt{}
      \PYGZlt{}property name=\PYGZdq{}password\PYGZdq{} value=\PYGZdq{}\PYGZdl{}\PYGZob{}jdbc.password\PYGZcb{}\PYGZdq{} /\PYGZgt{}
\PYGZlt{}/bean\PYGZgt{}
\end{sphinxVerbatim}


\section{Apache James适配}
\label{\detokenize{interface/apache-james:apache-james}}\label{\detokenize{interface/apache-james::doc}}
环境搭建参考https://blog.csdn.net/qq\_33945246/article/details/91417413

除此外还需两项配置：

V8R3:
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
在james\sphinxhyphen{}database.properties配置连接参数，并且配置vendorAdapter.database=ORACLE；

\end{enumerate}

2. 在sqlResources.xml文件的dbMatchers节点中设置
<dbMatcher db="postgresql" databaseProductName="kingbase.*"/>
\end{quote}

V8R6：
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
在james\sphinxhyphen{}database.properties配置连接参数，并且配置vendorAdapter.database=POSTGRESQL；

\end{enumerate}

2. 在sqlResources.xml文件的dbMatchers节点中设置
<dbMatcher db="postgresql" databaseProductName="kingbase.*"/>
\end{quote}


\section{Pdo接口常见问题}
\label{\detokenize{interface/pdo:pdo}}\label{\detokenize{interface/pdo::doc}}

\subsection{导入驱动失败}
\label{\detokenize{interface/pdo:id1}}
常见如下情况:
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pdo-1}.png}
\end{figure}
\end{quote}

问题现象：
\begin{quote}

提示libkci没有找到
\end{quote}

解决方案：
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
ldd pdo\_kdb.so 文件查看是否没有找到 libkci 驱动

\end{enumerate}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pdo-2}.png}
\end{figure}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
修改环境变量，LD\_LIBRARY\_PATH 指向金仓数据的 Server/lib 目录

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{export} \PYG{n}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{o}{=}\PYG{n}{XXX}\PYG{o}{/}\PYG{n}{Server}\PYG{o}{/}\PYG{n}{lib}
\end{sphinxVerbatim}
\end{quote}


\subsection{加载 PDO\_KDB 报错}
\label{\detokenize{interface/pdo:pdo-kdb}}
PHP Warning:  PHP Startup: Unable to load dynamic library '/usr/lib64/php/modules/pdo\_kdb.so' \sphinxhyphen{} /usr/lib64/php/modules/pdo\_kdb.so: undefined symbol: pdo\_raise\_impl\_error in Unknown on line 0

解决方案：
\begin{quote}

查看 PDO\_KDB.SO 驱动在 php.ini 中加载顺序，确保PDO\_KDB.SO的驱动加载顺序在 php 的PDO.SO 模块之后
\end{quote}


\subsection{PHP的线程安全和非线程安全}
\label{\detokenize{interface/pdo:php}}
PHP发布的版本分为支持线程安全和不支持线程安全两种：

通过命令查看：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
php –i|grep –i thread
\end{sphinxVerbatim}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pdo-3}.png}
\end{figure}

PDO编译依赖于PHP的configure  所以，PDO适配的时候也需要跟随PHP的配置。即如果PHP打开了Thread  Safety则，PDO也需要提供线程安全的版本。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pdo-4}.png}
\end{figure}

例如：PHP 打开了线程安全，PDO是没打开的版本则会报错：找不到file\_globals

PHP通过在configure的时候指定\sphinxhyphen{}\sphinxhyphen{}enable\sphinxhyphen{}maintainer\sphinxhyphen{}zts来支持线程安全。PDO编译的时候需要依赖PHP的configure，来实现线程安全与否。


\subsection{使用的PDO驱动与PHP版本不匹配}
\label{\detokenize{interface/pdo:pdophp}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pdo-5}.png}
\end{figure}

此图表示PHP5.6.40使用了PHP5.3编译的PDO驱动，导致加载失败。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Module} \PYG{n}{compiled} \PYG{k}{with} \PYG{n}{module} \PYG{n}{API}
\PYG{n}{PHP} \PYG{n}{compiled} \PYG{k}{with} \PYG{n}{module} \PYG{n}{API}
\end{sphinxVerbatim}

不匹配。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{PHP5}\PYG{o}{.}\PYG{l+m+mi}{2}     \PYG{n}{API}\PYG{o}{=}\PYG{l+m+mi}{20060613}
\PYG{n}{PHP5}\PYG{o}{.}\PYG{l+m+mi}{3}     \PYG{n}{API}\PYG{o}{=}\PYG{l+m+mi}{20090626}
\PYG{n}{PHP5}\PYG{o}{.}\PYG{l+m+mi}{4}     \PYG{n}{API}\PYG{o}{=}\PYG{l+m+mi}{20100525}
\PYG{n}{PHP5}\PYG{o}{.}\PYG{l+m+mi}{5}     \PYG{n}{API}\PYG{o}{=}\PYG{l+m+mi}{20121212}
\PYG{n}{PHP5}\PYG{o}{.}\PYG{l+m+mi}{6}     \PYG{n}{API}\PYG{o}{=}\PYG{l+m+mi}{20131226}
\PYG{n}{PHP7}\PYG{o}{.}\PYG{l+m+mi}{2}     \PYG{n}{API}\PYG{o}{=}\PYG{l+m+mi}{20170718}
\end{sphinxVerbatim}


\subsection{Windows下使用PDO驱动的方法}
\label{\detokenize{interface/pdo:windowspdo}}
将解压出的php\_pdo\_kdb.dll与libkci.dll 放到php7ts.dll文件所在的目录，因为php\_pdo\_kdb.dll需要依赖php7ts.dll 。  此目录一般为php.exe所在的目录。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pdo-6}.png}
\end{figure}

修改php.ini  加入

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{extension}\PYG{o}{=}\PYG{n}{C}\PYG{p}{:}\PYGZbs{}\PYG{n}{php}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{7.2}\PYG{o}{.}\PYG{l+m+mi}{0}\PYGZbs{}\PYG{n}{x64}\PYGZbs{}\PYG{n}{Release\PYGZus{}TS}\PYGZbs{}\PYG{n}{php\PYGZus{}pdo\PYGZus{}kdb}\PYG{o}{.}\PYG{n}{dll}
\end{sphinxVerbatim}

请将C:php\sphinxhyphen{}7.2.0x64Release\_TSphp\_pdo\_kdb.dll 修改为实际的路径

执行php \sphinxhyphen{}m 可以检测驱动是否加载成功

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pdo-7}.png}
\end{figure}


\subsection{thinkphp使用过程中报函数不存在的问题}
\label{\detokenize{interface/pdo:thinkphp}}
问题描述：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pdo-8}.png}
\end{figure}

解决方案：在使用thinkphp时，用 ksql 导入kingbase.sql文件，创建框架所需函数，解决上述问题。


\subsection{通过金蝶等中间件查看驱动加载信息时，看不到pdo\_kdb或者pdo\_pgsql的信息}
\label{\detokenize{interface/pdo:pdo-kdbpdo-pgsql}}
问题描述：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pdo-9}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{pdo-10}.png}
\end{figure}

问题分析：php扩展功能的文件，一般放在/lib/php/extensions/{\color{red}\bfseries{}**}/下，在php.ini中配置是，只需要将相关功能的extension=功能名；如果配置了功能扩展文件夹，php可以识别的到该路径，所以看到使用php \sphinxhyphen{}m可以看到功能加载信息，但有些第三方代理不一定可以识别的到，所在，建议最好扩展放在默认路径下！


\section{ThinkPHP接口常见问题}
\label{\detokenize{interface/thinkPHP:thinkphp}}\label{\detokenize{interface/thinkPHP::doc}}

\subsection{如何在搭建Thinkphp+apache+kdb环境}
\label{\detokenize{interface/thinkPHP:thinkphp-apache-kdb}}

\subsubsection{apache环境搭建}
\label{\detokenize{interface/thinkPHP:apache}}

\paragraph{源码编译}
\label{\detokenize{interface/thinkPHP:id1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}tar httpd\PYGZhy{}*.tar.gz}
\PYG{c+c1}{\PYGZsh{}cd httpd\PYGZhy{}*}
\PYG{c+c1}{\PYGZsh{}configure \PYGZhy{}\PYGZhy{}prefix=`pwd`/release}
\end{sphinxVerbatim}


\paragraph{配置httpd.conf}
\label{\detokenize{interface/thinkPHP:httpd-conf}}
在conf目录中，打开httpd.conf
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
配置加载库路径

\end{enumerate}

找到LoadModule位置，增加或者修改如下配置

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{LoadModule} \PYG{n}{php5\PYGZus{}module}        \PYG{n}{modules}\PYG{o}{/}\PYG{n}{libphp5}\PYG{o}{.}\PYG{n}{so}
\PYG{n}{PHPIniDir} \PYG{o}{/}\PYG{n}{opt}\PYG{o}{/}\PYG{n}{php}\PYG{o}{/}\PYG{n}{php}\PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{5.6}\PYG{o}{.}\PYG{l+m+mi}{40}\PYG{o}{/}\PYG{n}{release}\PYG{o}{/}\PYG{n}{lib}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
AddType

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{AddType} \PYG{n}{application}\PYG{o}{/}\PYG{n}{x}\PYG{o}{\PYGZhy{}}\PYG{n}{httpd}\PYG{o}{\PYGZhy{}}\PYG{n}{php} \PYG{o}{.}\PYG{n}{php}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
配置默认访问首页

\end{enumerate}

最后需要增加首页文件，让apache支持默认首页是index.php

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZlt{}}\PYG{n}{IfModule} \PYG{n}{dir\PYGZus{}module}\PYG{o}{\PYGZgt{}}
    \PYG{n}{DirectoryIndex} \PYG{n}{index}\PYG{o}{.}\PYG{n}{html} \PYG{n}{index}\PYG{o}{.}\PYG{n}{php}
\PYG{o}{\PYGZlt{}}\PYG{o}{/}\PYG{n}{IfModule}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
配置项目路径

\end{enumerate}

在配置文件httpd.conf中，修改

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DocumentRoot} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/opt/httpd\PYGZhy{}2.2.15/release/htdocs}\PYG{l+s+s2}{\PYGZdq{}}\PYG{n}{修改DocumentRoot路径即可}
\end{sphinxVerbatim}


\subsubsection{php环境搭建}
\label{\detokenize{interface/thinkPHP:php}}

\paragraph{配置驱动}
\label{\detokenize{interface/thinkPHP:id2}}
将pdo\_kdb.so、 kdb.so驱动，放至
/php\sphinxhyphen{}5.6.40/lib/php/extensions/no\sphinxhyphen{}debug\sphinxhyphen{}non\sphinxhyphen{}zts\sphinxhyphen{}20131226修改配置文件php.ini

extension=/opt/php/php\sphinxhyphen{}5.6.40/release/lib/php/extensions/no\sphinxhyphen{}debug\sphinxhyphen{}non\sphinxhyphen{}zts\sphinxhyphen{}20131226/pdo\_pgsql.so

extension=/opt/php/php\sphinxhyphen{}5.6.40/release/lib/php/extensions/no\sphinxhyphen{}debug\sphinxhyphen{}non\sphinxhyphen{}zts\sphinxhyphen{}20131226/pgsql.so


\subsubsection{thinkphp在httpd中使用}
\label{\detokenize{interface/thinkPHP:thinkphphttpd}}

\paragraph{配置数据库连接}
\label{\detokenize{interface/thinkPHP:id3}}
下载thinkphp3.1.2完整版本，加压之后，拷贝至httpd/htdocs中，执行index.php生成工程文件

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?php
//开启调试模式
define(\PYGZsq{}APP\PYGZus{}DEBUG\PYGZsq{},true);
//定义项目名称和路径
define(\PYGZsq{}APP\PYGZus{}NAME\PYGZsq{}, \PYGZsq{}app\PYGZsq{});
define(\PYGZsq{}APP\PYGZus{}PATH\PYGZsq{}, \PYGZsq{}./app/\PYGZsq{});
// 加载框架入口文件
require( \PYGZdq{}./ThinkPHP/ThinkPHP.php\PYGZdq{});
\end{sphinxVerbatim}


\paragraph{配置数据库连接}
\label{\detokenize{interface/thinkPHP:id4}}
打开app/Conf/config.php

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?php
return array(
    \PYGZsq{}URL\PYGZus{}MODEL\PYGZsq{} =\PYGZgt{}      3, // 如果你的环境不支持PATHINFO 请设置为3
    \PYGZsq{}DB\PYGZus{}TYPE\PYGZsq{}   =\PYGZgt{}      \PYGZsq{}kdb\PYGZsq{}
    \PYGZsq{}DB\PYGZus{}HOST\PYGZsq{}   =\PYGZgt{}      \PYGZsq{}127.0.0.1\PYGZsq{},
    \PYGZsq{}DB\PYGZus{}NAME\PYGZsq{}   =\PYGZgt{}      \PYGZsq{}test\PYGZsq{},
    \PYGZsq{}DB\PYGZus{}USER\PYGZsq{}   =\PYGZgt{}      \PYGZsq{}system\PYGZsq{},
    \PYGZsq{}DB\PYGZus{}PWD\PYGZsq{}    =\PYGZgt{}      \PYGZsq{}\PYGZsq{},
    \PYGZsq{}DB\PYGZus{}PORT\PYGZsq{}   =\PYGZgt{}      \PYGZsq{}54322\PYGZsq{},
    \PYGZsq{}DB\PYGZus{}PREFIX\PYGZsq{} =\PYGZgt{}      \PYGZsq{}think\PYGZus{}\PYGZsq{},
);
\end{sphinxVerbatim}


\paragraph{修改控制文件}
\label{\detokenize{interface/thinkPHP:id5}}
打开app/Lib/Action/IndexAction.class.php

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}?php
class IndexAction extends Action \PYGZob{}
    public function index()\PYGZob{}
        \PYGZdl{}user=M(\PYGZsq{}Form\PYGZsq{});   //大M方法访问数据表
        \PYGZdl{}sql=\PYGZdl{}user\PYGZhy{}\PYGZgt{}select();  //thinkPHP 封装的SQL查询所有数据

        echo \PYGZdl{}sql[\PYGZsq{}id\PYGZsq{}];
        var\PYGZus{}dump(\PYGZdl{}sql[\PYGZsq{}id\PYGZsq{}]);
        var\PYGZus{}dump(\PYGZdl{}sql[\PYGZsq{}title\PYGZsq{}]);
        var\PYGZus{}dump(\PYGZdl{}sql[\PYGZsq{}content1\PYGZsq{}]);
        var\PYGZus{}dump(\PYGZdl{}sql[\PYGZsq{}create\PYGZus{}time\PYGZsq{}]);
​
        \PYGZdl{}data[\PYGZsq{}id\PYGZsq{}] = 10;
        \PYGZdl{}data[\PYGZsq{}title\PYGZsq{}] = \PYGZsq{}ThinkPHP@gmail.com\PYGZsq{};
        \PYGZdl{}data[\PYGZsq{}content1\PYGZsq{}] = \PYGZsq{}ThinkPHP@gmail.com\PYGZsq{};
        \PYGZdl{}data[\PYGZsq{}create\PYGZus{}time\PYGZsq{}] = 15;
        \PYGZdl{}user\PYGZhy{}\PYGZgt{}data(\PYGZdl{}data)\PYGZhy{}\PYGZgt{}add();
        \PYGZdl{}sql=\PYGZdl{}user\PYGZhy{}\PYGZgt{}select();  //thinkPHP 封装的SQL查询所有数据
        var\PYGZus{}dump(\PYGZdl{}sql);     //打印出数据
    \PYGZcb{}
\PYGZcb{}
\end{sphinxVerbatim}


\paragraph{添加html文件}
\label{\detokenize{interface/thinkPHP:html}}

\section{Perl 常见问题}
\label{\detokenize{interface/perl:perl}}\label{\detokenize{interface/perl::doc}}

\subsection{Perl 驱动pdi无法加载问题}
\label{\detokenize{interface/perl:perl-pdi}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
首先查看用户的Perl是不是支持ithreads的。

\end{enumerate}

查看方法：perl –V {\color{red}\bfseries{}|}grep use.*threads

要能看到：useithreads=define, usemultiplicity=define 就表示是支持的

如果看到的是：useithreads=undef 那就是不支持。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
查看用户的Perl的版本

\end{enumerate}

目前V8支持的Perl版本是5.16的，如果用户不是这个版本可能无法加载驱动。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
执行加载测试

\end{enumerate}

执行：perl \sphinxhyphen{}MDBI \sphinxhyphen{}e 'DBI\sphinxhyphen{}> installed\_versions;'

如果成功能看到DBD::KB         : 2.19.3

如果失败能看到报错信息：无法加载

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{perl-1}.png}
\end{figure}


\subsection{怎么在perl中配置金仓perl驱动}
\label{\detokenize{interface/perl:perlperl}}
在perl安装目录下/p5281/lib/perl5/5.28.1/x86\_64\sphinxhyphen{}linux\sphinxhyphen{}thread\sphinxhyphen{}multi/DBI.pm中添加如下内容

\begin{sphinxVerbatim}[commandchars=\\\{\}]
my \PYGZdl{}dbd\PYGZus{}prefix\PYGZus{}registry = \PYGZob{}
                                               ......
                                               kb\PYGZus{}          =\PYGZgt{} \PYGZob{} class  =\PYGZgt{} \PYGZsq{}DBD::KB\PYGZsq{},      \PYGZcb{},
                                              ......
\PYGZcb{}
\end{sphinxVerbatim}


\subsection{如何排查perl驱动加载失败步骤}
\label{\detokenize{interface/perl:id3}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
首先确认，金仓的perl的驱动是否放到了指定文件路径下：

\end{enumerate}

如：/perl/lib 下一般驱动下有三个文件夹：auto Bundle DBD，三个文件夹，以perl/lib下也有对应的单个文件夹
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
在/perl/lib/auto/DBD/KB中找到KB.so

\end{enumerate}

使用ldd KB.so，查看是否缺失，一般KB.so 依赖libkci.so以及openssl.so的库文件，只需要将依赖库的路径添加至LD\_LIBRARY\_PATH中或者拷贝至KB.so中即可。


\section{ODBC常见问题}
\label{\detokenize{interface/odbc:odbc}}\label{\detokenize{interface/odbc::doc}}

\subsection{环境依赖}
\label{\detokenize{interface/odbc:id1}}
kingbase ODBC 驱动在windows下会依赖msvc120.dll，在没有安装VS的运行环境中，通过ODBC数据源工具配置DNS时，会提示如下错误：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{odbc-1}.png}
\end{figure}

解决方法: 如果使用的是32的驱动，则通过运行安装vcredist\_x86(Microsoft Visual C++ 2013),如果是64位驱动，则运行安装vcredist\_x64(Microsoft Visual C++ 2013）即可。


\subsection{linux unixodbc通过连接串连接数据库操作，如何添加连接参数？}
\label{\detokenize{interface/odbc:linux-unixodbc}}
unixodbc通过连接串连接数据库，连接串需要指定驱动名称，数据库服务器IP地址、端口号、用户名、密码、数据库名，驱动名称是配置在odbcinst.ini中的。具体的连接示例如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{isql} \PYG{o}{\PYGZhy{}}\PYG{n}{k} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Driver=}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{kdbodbc test driver\PYGZcb{};Server=192.168.28.152;Database=TEST;Uid=SYSTEM;}
\PYG{n}{Password}\PYG{o}{=}\PYG{l+m+mi}{123456}\PYG{p}{;}\PYG{n}{Port}\PYG{o}{=}\PYG{l+m+mi}{54384}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}

Driver的赋值是odbcinst.ini中配置的驱动名称；

\sphinxhyphen{}k 为必不可少的参数，该参数制定使用SQLDriverConect作为连接函数。


\subsection{linux环境下如何开启odbc驱动的日志？}
\label{\detokenize{interface/odbc:linuxodbc}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
V7 ODBC 中添加日志打印控制项在odbc.ini中添加，如下图中

\end{enumerate}
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{odbc-2}.png}
\end{figure}

LogFile=日志位置

LogLevel=debug5(备注：debug5为日志等级，该等级从debug1\sphinxhyphen{}\sphinxhyphen{}\sphinxhyphen{}debug5,日志信息量一次增加)
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
V8 ODBC 日志打印控制项在odbcinst.ini中添加，红色部分为添加项：

\end{enumerate}
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{odbc-3}.png}
\end{figure}

Trace = on 开启日志打印

TraceFile = 日志存放位置

上述两个参数时UNIXODBC日志，kingbase odbc日志配置项通过：

Debug = 1

CommLog = 1

来设置,linux日志存放路径在/tmp路径下
\end{quote}


\subsection{linux下odbc驱动接口连接数据库失败，如何排查？}
\label{\detokenize{interface/odbc:id2}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
通过odbcinst \sphinxhyphen{}j 查看驱动所使用的配置文件所在路径，如下图：

\end{enumerate}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{odbc-4}.png}
\end{figure}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
查验上述图中路径下的配置文件odbc.ini和odbcinst.ini中的配置项，是否正确，强调的是请认真核实各配置项的名称是否正确无误，主要配置项如下：

\end{enumerate}
\begin{quote}
\begin{description}
\item[{odbcinst.ini:}] \leavevmode
Driver = 驱动所在路径

\item[{odbc.ini:}] \leavevmode
Database = TEST(备注：数据库名)
Servername = 127.0.0.1 (备注：数据库服务器IP地址)
Username = SYSTEM(备注：用户名)
Password = 123456(备注：密码)
Port=54321(备注：端口号)

\end{description}
\end{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
查看驱动是否缺少依赖，如果缺少libunixodbcinst.so.2，可以添加unixodbc相关库至环境变量中，export LD\_LIBRARY\_PATH=/usr/local/lib(备注：该路径为unixodbc相关库的路)。

\item {} 
通过isql kingbase(备注：odbc中配置的DNS名)连接测试，如果连接成功，驱动接口还是连接失败，则检查传递给接口的连接串参数是否不对；如果连接失败，排查前三步中是否有不正确的地方。

\end{enumerate}

\begin{sphinxadmonition}{note}{Note:}
ODBCINSTINI、ODBCINI为设置配置文件的环境变量。
\end{sphinxadmonition}


\subsection{linux下odbc驱动开启日志？}
\label{\detokenize{interface/odbc:id3}}
v8 ODBC一般有两种日志一种是Debug日志，一种是Commlog日志，给开发人员看的一般是Debug，设置方式有两种，一种是在odbc.ini中添加：
\begin{quote}
\begin{description}
\item[{odbc.ini:}] \leavevmode
Database = TEST(备注：数据库名)
Servername = 127.0.0.1 (备注：数据库服务器IP地址)
Username = SYSTEM(备注：用户名)
Password = 123456(备注：密码)
\begin{quote}
\begin{quote}

Port=54321(备注：端口号)
Debug=1(备注:Debug日志)
\end{quote}
\begin{description}
\item[{在连接串中添加：}] \leavevmode\begin{description}
\item[{"Driver=\{kdbodbc test driver\};Server=192.168.28.152;Database=TEST;Uid=SYSTEM;}] \leavevmode
Password=123456;Port=54384;Debug=1"

\end{description}

\end{description}
\end{quote}

\end{description}
\end{quote}


\subsection{SQLFreeStmt()函数与SQLCloseCursor()有什么不同？}
\label{\detokenize{interface/odbc:sqlfreestmt-sqlclosecursor}}
首先SQLFreeStmt通过参数控制，可以关闭句柄关联的游标和放弃的挂起结果集，    如:SQLFreeStmt(hstmt, SQL\_CLOSE),还可以释放语句句柄SQLFreeStmt(hstmt)，如：  SQLFreeStmt(hstmt, SQL\_DROP)。

其次：SQLCloseCursor函数的功能只是关闭语句句柄关联的游标。


\subsection{连接串中如何通过驱动名连接数据库，即不通过DNS连接数据库？}
\label{\detokenize{interface/odbc:dns}}
在连接传中直接配置驱动名，连接串如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Driver=}\PYG{l+s+s2}{\PYGZob{}}\PYG{l+s+s2}{kdbodbc test driver\PYGZcb{};Server=192.168.28.152;Database=TEST;Uid=SYSTEM;}
  \PYG{n}{Password}\PYG{o}{=}\PYG{l+m+mi}{123456}\PYG{p}{;}\PYG{n}{Port}\PYG{o}{=}\PYG{l+m+mi}{54384}\PYG{p}{;}\PYG{n}{Debug}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
在windows中，驱动名可以是ODBC管理工具驱动程序一栏中的值，或者注册表中的驱动名称。

\end{enumerate}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{odbc-5}.png}
\end{figure}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
linux下，该驱动名为odbc.ini中

\end{enumerate}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{odbc-6}.png}
\end{figure}


\section{C\# 常见通过问题}
\label{\detokenize{interface/C_:c}}\label{\detokenize{interface/C_::doc}}

\subsection{NDP的连接数问题}
\label{\detokenize{interface/C_:ndp}}
NDP驱动默认使用连接池连接池大小默认是20，所以如果要建立更多连接需要改连接参数。

例子：
\begin{description}
\item[{Pooling}] \leavevmode
指定是否使用连接池。可取值为 True 和 False。默认为 True

\item[{MaxPoolSize}] \leavevmode
连接池中最大连接数，超过该数字则新建连接失败。默认为 20。

\end{description}


\subsection{NDP驱动net45、net451, netcore2.0有什么不同？}
\label{\detokenize{interface/C_:ndpnet45net451-netcore2-0}}
net45，net451主要只要的.net framework 的版本号，该已net45,net451只能在指定的.net framwork 中使用，有事也可在高于指定版本的.net framework中使用，该驱动是在windows平台下使用的，而netcore2.0指的是既可以在.net framework框架中也可以在netcore框架中使用，而且netcore2.0为跨平台驱动，可以再linux中使用。(jexus中可以将net45等驱动在linux下使用)


\section{Python通过PyODBC连接Kingbase的说明}
\label{\detokenize{interface/python:pythonpyodbckingbase}}\label{\detokenize{interface/python::doc}}

\subsection{环境配置}
\label{\detokenize{interface/python:id1}}\begin{description}
\item[{\#\#\#安装 pyodbc:}] \leavevmode
推荐使用`pip`进行安装，执行`pip install pyodbc`

\item[{\#\#\#安装 unixodbc:}] \leavevmode
在终端输入并执行`sudo apt\sphinxhyphen{}get install unixodbc`

\end{description}


\subsection{KingbaseV7驱动配置}
\label{\detokenize{interface/python:kingbasev7}}\begin{description}
\item[{\#\#\#配置数据源和驱动}] \leavevmode
安装iodbc后，在终端中输入并执行`odbcinst \sphinxhyphen{}j`，可以看到配置文件的路径，然后根据本机情况进行配置。

\end{description}

在`odbcinst.ini`文件中添加以下内容：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{Kingbase\PYGZus{}v7}\PYG{p}{]}
\PYG{n}{Driver} \PYG{o}{=} \PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{kdbodbc7}\PYG{o}{.}\PYG{n}{so} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} odbc驱动库路径}
\PYG{n}{SETUP}  \PYG{o}{=} \PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{kdbodbc7S}\PYG{o}{.}\PYG{n}{so} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} odbc安装库路径}
\PYG{n}{UsageCount} \PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

在`odbc.ini`文件中添加以下内容：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{Kingbase\PYGZus{}v7}\PYG{p}{]}
\PYG{n}{Description} \PYG{o}{=} \PYG{n}{Kingbase} \PYG{n}{V7}
\PYG{n}{Trace} \PYG{o}{=} \PYG{n}{On}
\PYG{n}{TraceFile} \PYG{o}{=} \PYG{n}{stderr}
\PYG{n}{Driver} \PYG{o}{=} \PYG{n}{Kingbase\PYGZus{}v7} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} odbcinst.ini文件中的标签名}
\PYG{n}{SERVER} \PYG{o}{=} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{8.52} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 服务器地址}
\PYG{n}{USER} \PYG{o}{=} \PYG{n}{nli} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 用户名}
\PYG{n}{PASSWORD} \PYG{o}{=}  \PYG{c+c1}{\PYGZsh{}\PYGZsh{}密码}
\PYG{n}{PORT} \PYG{o}{=} \PYG{l+m+mi}{54321} \PYG{c+c1}{\PYGZsh{}\PYGZsh{}端口号}
\PYG{n}{DATABASE} \PYG{o}{=} \PYG{n}{TEST} \PYG{c+c1}{\PYGZsh{}\PYGZsh{}数据库名}
\end{sphinxVerbatim}


\subsection{KingbaseV8驱动配置}
\label{\detokenize{interface/python:kingbasev8}}\begin{description}
\item[{\#\#\#配置数据源和驱动}] \leavevmode
安装iodbc后，在终端中输入并执行`odbcinst \sphinxhyphen{}j`，可以看到配置文件的路径，然后根据本机情况进行配置。

\end{description}

在`odbcinst.ini`文件中添加以下内容：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{Kingbase\PYGZus{}v8}\PYG{p}{]}
\PYG{n}{Driver} \PYG{o}{=} \PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{kdbodbcw}\PYG{o}{.}\PYG{n}{so} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} odbc驱动库路径}
\PYG{n}{SETUP}  \PYG{o}{=} \PYG{o}{/}\PYG{n}{lib}\PYG{o}{/}\PYG{n}{kdbodbcw}\PYG{o}{.}\PYG{n}{so} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} odbc安装库路径}
\PYG{n}{UsageCount} \PYG{o}{=} \PYG{l+m+mi}{1}
\end{sphinxVerbatim}

在`odbc.ini`文件中添加以下内容：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{Kingbase\PYGZus{}v8}\PYG{p}{]}
\PYG{n}{Description} \PYG{o}{=} \PYG{n}{Kingbase} \PYG{n}{V8}
\PYG{n}{Trace} \PYG{o}{=} \PYG{n}{On}
\PYG{n}{TraceFile} \PYG{o}{=} \PYG{n}{stderr}
\PYG{n}{Driver} \PYG{o}{=} \PYG{n}{Kingbase\PYGZus{}v8} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} odbcinst.ini文件中的标签名}
\PYG{n}{SERVER} \PYG{o}{=} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{8.132} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 服务器地址}
\PYG{n}{USER} \PYG{o}{=} \PYG{n}{nli} \PYG{c+c1}{\PYGZsh{}\PYGZsh{} 用户名}
\PYG{n}{PASSWORD} \PYG{o}{=}  \PYG{c+c1}{\PYGZsh{}\PYGZsh{}密码}
\PYG{n}{PORT} \PYG{o}{=} \PYG{l+m+mi}{54321} \PYG{c+c1}{\PYGZsh{}\PYGZsh{}端口号}
\PYG{n}{DATABASE} \PYG{o}{=} \PYG{n}{TEST} \PYG{c+c1}{\PYGZsh{}\PYGZsh{}数据库名}
\end{sphinxVerbatim}


\subsection{连接测试}
\label{\detokenize{interface/python:id2}}
编写测试用python文件并执行

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pyodbc}

    \PYG{c+c1}{\PYGZsh{}非DSN方式}
    \PYG{n}{conn} \PYG{o}{=} \PYG{n}{pyodbc}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{DRIVER=}\PYG{l+s+si}{\PYGZob{}Kingbase\PYGZus{}v8\PYGZcb{}}\PYG{l+s+s2}{;SERVER=192.168.8.132;port=54321;database=TEST;UID=nli;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{}DSN方式}
    \PYG{c+c1}{\PYGZsh{}conn = pyodbc.connect(\PYGZsq{}DSN=Kingbase\PYGZus{}v7;SERVER=192.168.8.52;UID=nli\PYGZsq{})}

    \PYG{n}{cursor} \PYG{o}{=} \PYG{n}{conn}\PYG{o}{.}\PYG{n}{cursor}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{cursor}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{select * from TEST\PYGZus{}BLOB;}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{rows} \PYG{o}{=} \PYG{n}{cursor}\PYG{o}{.}\PYG{n}{fetchall}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n}{rows}\PYG{p}{:}
        \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}
    \PYG{n}{conn}\PYG{o}{.}\PYG{n}{commit}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Ruby 常见问题}
\label{\detokenize{interface/ruby:ruby}}\label{\detokenize{interface/ruby::doc}}

\subsection{如何使用ruby\sphinxhyphen{}pg驱动连接至kingbaseES V8R3数据库}
\label{\detokenize{interface/ruby:ruby-pgkingbasees-v8r3}}
分为修改驱动代码部分和表等数据库对象映射部分：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
修改驱动代码

\end{enumerate}

进入驱动源码ext 目下下，修改/ext/pg\_connection.c 871行代码,修改如下:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
/*
            static VALUE pgconn\PYGZus{}server\PYGZus{}version(VALUE self)
            \PYGZob{}
                     return INT2NUM(90600);
            \PYGZcb{}

            (备注：修改之后需要重新编译；使用修改之后如果还是报版本过低的问题，请检查是否       应用了修改过的驱动)
*/
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
在用户用户模式下创建以下视图和函数

\end{enumerate}

映射表视图如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{create} \PYG{o+ow}{or} \PYG{n}{replace} \PYG{n}{view} \PYG{n}{pg\PYGZus{}type} \PYG{k}{as} \PYG{n}{select} \PYG{n}{oid}\PYG{p}{,}\PYG{o}{*} \PYG{k+kn}{from} \PYG{n+nn}{sys\PYGZus{}type}\PYG{p}{;}
\PYG{n}{create} \PYG{o+ow}{or} \PYG{n}{replace} \PYG{n}{view} \PYG{n}{pg\PYGZus{}range} \PYG{k}{as} \PYG{n}{select} \PYG{o}{*} \PYG{k+kn}{from} \PYG{n+nn}{sys\PYGZus{}range}\PYG{p}{;}
\PYG{n}{create} \PYG{o+ow}{or} \PYG{n}{replace} \PYG{n}{view} \PYG{n}{pg\PYGZus{}class} \PYG{k}{as} \PYG{n}{select} \PYG{n}{oid}\PYG{p}{,}\PYG{o}{*} \PYG{k+kn}{from} \PYG{n+nn}{sys\PYGZus{}class}\PYG{p}{;}
\PYG{n}{create} \PYG{o+ow}{or} \PYG{n}{replace} \PYG{n}{view} \PYG{n}{pg\PYGZus{}namespace} \PYG{k}{as} \PYG{n}{select} \PYG{n}{oid}\PYG{p}{,}\PYG{o}{*} \PYG{k+kn}{from} \PYG{n+nn}{sys\PYGZus{}namespace}\PYG{p}{;}
       \PYG{n}{create} \PYG{o+ow}{or} \PYG{n}{replace} \PYG{n}{view} \PYG{n}{pg\PYGZus{}extension} \PYG{k}{as} \PYG{n}{select} \PYG{n}{oid}\PYG{p}{,}\PYG{o}{*} \PYG{k+kn}{from} \PYG{n+nn}{sys\PYGZus{}extension}\PYG{p}{;}
       \PYG{n}{create} \PYG{o+ow}{or} \PYG{n}{replace} \PYG{n}{view} \PYG{n}{pg\PYGZus{}constraint} \PYG{k}{as} \PYG{n}{select} \PYG{n}{oid}\PYG{p}{,}\PYG{o}{*} \PYG{k+kn}{from} \PYG{n+nn}{sys\PYGZus{}constraint}\PYG{p}{;}
       \PYG{n}{create} \PYG{o+ow}{or} \PYG{n}{replace} \PYG{n}{view} \PYG{n}{pg\PYGZus{}index} \PYG{k}{as} \PYG{n}{select} \PYG{o}{*} \PYG{k+kn}{from} \PYG{n+nn}{sys\PYGZus{}index}\PYG{p}{;}
\end{sphinxVerbatim}

创建函数如下：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
create or replace function pg\PYGZus{}try\PYGZus{}advisory\PYGZus{}lock(key bigint)returns boolean
       as \PYGZdl{}\PYGZdl{}
       declare
       begin
       return sys\PYGZus{}try\PYGZus{}advisory\PYGZus{}lock(\PYGZdl{}1);
       end;
       \PYGZdl{}\PYGZdl{}language plsql;

       create or replace function pg\PYGZus{}try\PYGZus{}advisory\PYGZus{}lock(key1 int,key2 int)returns boolean
       as \PYGZdl{}\PYGZdl{}
       declare
begin
 return sys\PYGZus{}try\PYGZus{}advisory\PYGZus{}lock(\PYGZdl{}1,\PYGZdl{}2);
end;
\PYGZdl{}\PYGZdl{}language plsql;
create or replace view pg\PYGZus{}attribute as select * from sys\PYGZus{}attribute;
create or replace function pg\PYGZus{}get\PYGZus{}expr(v1 sys\PYGZus{}node\PYGZus{}tree,v2  oid, v3 boolean)returns text
as \PYGZdl{}\PYGZdl{}
declare
begin
 return sys\PYGZus{}get\PYGZus{}expr(\PYGZdl{}1,\PYGZdl{}2,\PYGZdl{}3);
end;
\PYGZdl{}\PYGZdl{}language plsql;

create or replace function pg\PYGZus{}get\PYGZus{}expr(v1 sys\PYGZus{}node\PYGZus{}tree,v2  oid)returns text
as \PYGZdl{}\PYGZdl{}
declare
begin
 return sys\PYGZus{}get\PYGZus{}expr(\PYGZdl{}1,\PYGZdl{}2);
end;
\PYGZdl{}\PYGZdl{}language plsql;
create or replace view pg\PYGZus{}collation as select oid,* from sys\PYGZus{}collation;
create or replace function pg\PYGZus{}advisory\PYGZus{}unlock(key bigint)returns boolean
as \PYGZdl{}\PYGZdl{}
declare
begin
 return sys\PYGZus{}advisory\PYGZus{}unlock(\PYGZdl{}1);
end;
\PYGZdl{}\PYGZdl{}language plsql;

create or replace function pg\PYGZus{}advisory\PYGZus{}unlock(key1 int,key2 int)returns boolean
as \PYGZdl{}\PYGZdl{}
declare
begin
 return sys\PYGZus{}advisory\PYGZus{}unlock(\PYGZdl{}1,\PYGZdl{}2);
end;
\PYGZdl{}\PYGZdl{}language plsql;
\end{sphinxVerbatim}


\section{QT常见问题}
\label{\detokenize{interface/qt:qt}}\label{\detokenize{interface/qt::doc}}

\subsection{windows如何加载QT驱动}
\label{\detokenize{interface/qt:windowsqt}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
将libkci.dll的路径加至环境变量PATH中，如下图：

\end{enumerate}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{qt-1}.png}
\end{figure}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
将驱动QT数据库驱动拷贝至对应的QT安装路径pluginssqldrivers,如下图：

\end{enumerate}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{qt-2}.png}
\end{figure}


\subsection{提需求时，如何进行描述：}
\label{\detokenize{interface/qt:id1}}
首先是所需平台，如果是windows下的，就会更具编译器不同区分为mingw和msvc两个版本，平台位数，是32位还是64位，更具使用的VS版本不同，又分为vs2012,vs2015等，所以在windows下提需求因参照 位数+编译器版本(mingw或者msvc)+vs版本(2012/2013/2015)。


\subsection{SSL认证如何配置}
\label{\detokenize{interface/qt:ssl}}
参考 :ref:{\color{red}\bfseries{}`}SSL认证常见问题 `


\section{V7 KCI常见问题}
\label{\detokenize{interface/kci-v7:v7-kci}}\label{\detokenize{interface/kci-v7::doc}}

\subsection{用KCI操作大对象写到用户的表里，发现OID不是创建的OID}
\label{\detokenize{interface/kci-v7:kci-oidoid}}
原因是最后写OID到用户表的时候，需要注意类型转换问题，否则可能被当做普通字串插入，造成重新生成一个对象OID。

例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{sprintf}\PYG{p}{(}\PYG{n}{sql}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{insert into }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ values (}\PYG{l+s+si}{\PYGZpc{}ld}\PYG{l+s+s2}{::OID);}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{tbl\PYGZus{}name}\PYG{p}{,} \PYG{n}{blobid}\PYG{p}{)}\PYG{p}{;}
                   \PYG{n}{res} \PYG{o}{=} \PYG{n}{KCIStatementExecute}\PYG{p}{(}\PYG{n}{conn}\PYG{p}{,} \PYG{n}{sql}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\section{V7 OCI常见问题}
\label{\detokenize{interface/oci-v7:v7-oci}}\label{\detokenize{interface/oci-v7::doc}}

\subsection{OCI读写分离配置}
\label{\detokenize{interface/oci-v7:oci}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}打开读写分离功能，该配置项时读写分离功能的前提，必须开启后续的配置项才有意义；若未开启，则host配置项只使用第一个地址}
\PYG{n}{UseDispatch}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{c+c1}{\PYGZsh{}服务器地址（包括主机和备机，用“|”分割）}
\PYG{n}{HOST}\PYG{o}{=}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{28.21}\PYG{o}{|}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{28.20}
\PYG{c+c1}{\PYGZsh{}主机读负载率，默认为0}
\PYG{n}{HOSTLOADRATE}\PYG{o}{=}\PYG{l+m+mi}{50}
\PYG{c+c1}{\PYGZsh{}发送语句失败后的重试次数，默认为5次}
\PYG{n}{RETRYTIMES}\PYG{o}{=}\PYG{l+m+mi}{10}
\PYG{c+c1}{\PYGZsh{}发送语句失败后的重试等待时间，单位为秒，默认5秒}
\PYG{n}{RETRYINTERVAL}\PYG{o}{=}\PYG{l+m+mi}{5}
\PYG{c+c1}{\PYGZsh{}监控线程的检查等待时间，单位为秒，默认5秒}
\PYG{n}{MONITORINTERVAL}\PYG{o}{=}\PYG{l+m+mi}{5}
  \PYG{c+c1}{\PYGZsh{}写函数列表，调用该函数的sql语句将发送至主机（用“;”分割）}
\PYG{n}{BlackList}\PYG{o}{=}\PYG{n}{setData}\PYG{p}{;}\PYG{n}{setValue}\PYG{p}{;}\PYG{n}{removeData}
\end{sphinxVerbatim}

在支持读写分离的驱动版本中，useHA功能已经被弃用，后续也不再支持。


\subsection{OCI日志分析}
\label{\detokenize{interface/oci-v7:id1}}
常用的OCI日志的命令：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
比如我要看一个线程的日志，假如131 是线程ID，

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grep} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{[131}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{.}\PYG{o}{/}\PYG{n}{oci\PYGZus{}new}\PYG{o}{.}\PYG{n}{log} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{131.}\PYG{n}{log}
\end{sphinxVerbatim}

这样就能看到131线程的完整OCI日志，这样就能看到这个线程都干了什么事情，反推应用的业务逻辑。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
比如我要看 monitor线程的日志

\end{enumerate}

从全日志里搜monitor找到对应的线程ID比如是{[}32{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grep} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{[32}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{.}\PYG{o}{/}\PYG{n}{oci\PYGZus{}new}\PYG{o}{.}\PYG{n}{log} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{32.}\PYG{n}{log}
\end{sphinxVerbatim}

这样就能看到monitor不停的刷在线的主备机的IP，这样基本就能看到集群的历史和现在的状态，主备机都是谁。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
比如我要看是哪条SQL把事务设置为写事务了，从而不再分发备机。

\end{enumerate}

从日志里搜”The statement switches to write transaction”，后面的SQL就是被识别为写语句的SQL。

例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{114}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{07}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{19} \PYG{l+m+mi}{21}\PYG{p}{:}\PYG{l+m+mi}{04}\PYG{p}{:}\PYG{l+m+mf}{04.1470}\PYG{p}{]}\PYG{n}{DEBUG3}\PYG{p}{:} \PYG{n}{The} \PYG{n}{statement} \PYG{n}{switches} \PYG{n}{to} \PYG{n}{write} \PYG{n}{transaction}\PYG{p}{:} \PYG{n}{select} \PYG{n}{pk\PYGZus{}value} \PYG{k+kn}{from} \PYG{n+nn}{ecms\PYGZus{}gen\PYGZus{}pk} \PYG{n}{where} \PYG{n}{pk\PYGZus{}name} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pk\PYGZus{}web\PYGZus{}url\PYGZus{}access\PYGZus{}log}\PYG{l+s+s1}{\PYGZsq{}} \PYG{k}{for} \PYG{n}{update} \PYG{o}{.}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
查看sql语句预备发送至哪个服务器

\end{enumerate}

在日志中搜索“Dispatch pickTheConnection,”，就能看到所有的语句预备发送至哪个服务器。

例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{6512}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{22} \PYG{l+m+mi}{20}\PYG{p}{:}\PYG{l+m+mi}{46}\PYG{p}{:}\PYG{l+m+mf}{55.1700}\PYG{p}{]}\PYG{n}{DEBUG3}\PYG{p}{:}      \PYG{n}{Dispatch} \PYG{n}{pickTheConnection}\PYG{p}{,} \PYG{n}{select} \PYG{n}{count}\PYG{p}{(}\PYG{o}{*}\PYG{p}{)} \PYG{k+kn}{from} \PYG{n+nn}{sys\PYGZus{}class} \PYG{n}{send} \PYG{n}{to} \PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{28.48}
\end{sphinxVerbatim}


\subsection{OCI日志配置说明}
\label{\detokenize{interface/oci-v7:id2}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
sys\_service.conf 文件中 DCILog 指定日志文件路径，DCILogLevel 指定日志级别, 如下：

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{DCILog}\PYG{o}{=}\PYG{o}{/}\PYG{n}{tmp}\PYG{o}{/}\PYG{n}{oci}\PYG{o}{.}\PYG{n}{log}
\PYG{n}{DCILogLevel}\PYG{o}{=}\PYG{n}{DEBUG3}
\end{sphinxVerbatim}

2.sys\_service.conf 文件中第一次出现的 DCILog 和 DCILogLevel 才会生效，后续的配置不再读取。

比如 sys\_service.conf 文件中有如下配置：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{KingbaseES\PYGZus{}1}\PYG{p}{]}
\PYG{n}{DCILog}\PYG{o}{=}\PYG{o}{/}\PYG{n}{tmp}\PYG{o}{/}\PYG{n}{oci1}\PYG{o}{.}\PYG{n}{log}
\PYG{n}{DCILogLevel}\PYG{o}{=}\PYG{n}{DEBUG3}

\PYG{p}{[}\PYG{n}{KingbaseES\PYGZus{}2}\PYG{p}{]}
\PYG{n}{DCILog}\PYG{o}{=}\PYG{o}{/}\PYG{n}{tmp}\PYG{o}{/}\PYG{n}{oci2}\PYG{o}{.}\PYG{n}{log}
\PYG{n}{DCILogLevel}\PYG{o}{=}\PYG{n}{DEBUG1}
\end{sphinxVerbatim}

则生效的是：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{KingbaseES\PYGZus{}1}\PYG{p}{]}
\PYG{n}{DCILog}\PYG{o}{=}\PYG{o}{/}\PYG{n}{tmp}\PYG{o}{/}\PYG{n}{oci1}\PYG{o}{.}\PYG{n}{log}
\PYG{n}{DCILogLevel}\PYG{o}{=}\PYG{n}{DEBUG3}
\end{sphinxVerbatim}

这是因为应用程序加载DCI驱动的时候，就会来读取 sys\_service.conf 中的日志文件相关配置，  而此时还不知道应用程序使用的服务名。所以，以找到的第一个 DCILog 和 DCILogLevel 为准。


\subsection{OCI配置文件如何配置}
\label{\detokenize{interface/oci-v7:id3}}
首先设置环境变量：KINGBASE\_CONFDIR指定sys\_service.conf配置文件所在目录路径，如果是在windows下配置环境变量，需要重启应用程序，环境变量才能在环境变量中生效。

其次：配置文件信息如下

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{n}{KingbaseES\PYGZus{}R3}\PYG{p}{]}
\PYG{n}{dbname}\PYG{o}{=}\PYG{n}{TEST}
\PYG{n}{port}\PYG{o}{=}\PYG{l+m+mi}{54322}
\PYG{n}{host}\PYG{o}{=}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{28.151}
\PYG{n}{Print}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{n}{DCILog}\PYG{o}{=}\PYG{n}{oci}\PYG{o}{.}\PYG{n}{log}
\PYG{n}{DCILogLevel}\PYG{o}{=}\PYG{n}{DEBUG1}
\PYG{n}{UseExtendedProtocol}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\subsection{OCI 和DCI的头文件可以混用吗？}
\label{\detokenize{interface/oci-v7:oci-dci}}
OCI的头文件是使用的oracle相关的头文件,DCI使用的是金仓提供的，一般提供驱动时会一起提供。


\section{V7 JDBC常见问题}
\label{\detokenize{interface/jdbc-v7:v7-jdbc}}\label{\detokenize{interface/jdbc-v7::doc}}

\subsection{JDBC读写分离配置}
\label{\detokenize{interface/jdbc-v7:jdbc}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}打开读写分离功能}
\PYG{n}{USEDISPATCH}\PYG{o}{=}\PYG{n}{true}
\PYG{c+c1}{\PYGZsh{}主机负载率，范围0到100，根据当前发给主机的语句数目与总语句数目的比例与HOSTLOADRATE设置的比例进行比较，当前者大于后者时，发给备机，否则发给主机。}
\PYG{n}{HOSTLOADRATE}\PYG{o}{=}\PYG{l+m+mi}{33}
\PYG{c+c1}{\PYGZsh{}备机地址，可指定多个，用“,”隔开}
\PYG{n}{SLAVE\PYGZus{}ADD}\PYG{o}{=}\PYG{l+m+mf}{192.168}\PYG{o}{.}\PYG{l+m+mf}{28.20}
\PYG{c+c1}{\PYGZsh{}备机端口，与备机地址对应，可指定多个，用“,”隔开}
\PYG{n}{SLAVE\PYGZus{}PORT}\PYG{o}{=}\PYG{l+m+mi}{54321}
\PYG{c+c1}{\PYGZsh{}在新建连接时检查当前连接DB是不是Master,如果不是回去slave检查有没有Master,如果还是找不到Master就会向上报错}
\PYG{n}{MASTER\PYGZus{}CHECK}\PYG{o}{=}\PYG{n}{true}
\PYG{c+c1}{\PYGZsh{}开启集群备机监测线程定时监测集群备机状态}
\PYG{n}{CLUSTER\PYGZus{}MONITOR}\PYG{o}{=}\PYG{n}{true}
\PYG{c+c1}{\PYGZsh{}监测线程每次监测的间隔时间（单位：秒）}
\PYG{n}{MONITORINTERVAL}\PYG{o}{=}\PYG{l+m+mi}{5}
\PYG{c+c1}{\PYGZsh{}失败重发的最高次数}
\PYG{n}{RETRYTIMES}\PYG{o}{=}\PYG{l+m+mi}{10}
\PYG{c+c1}{\PYGZsh{}失败重发每次的间隔时间（单位：秒）}
\PYG{n}{RETRYINTERVAL}\PYG{o}{=}\PYG{l+m+mi}{5}
\PYG{c+c1}{\PYGZsh{}指定连接参数配置文件的路径，该参数需在连接串指定}
\PYG{n}{ConfigurePath}\PYG{o}{=}\PYG{n}{jdbc\PYGZus{}v7}\PYG{o}{.}\PYG{n}{conf}
\PYG{c+c1}{\PYGZsh{}黑名单，指定写函数，可指定多个，以分号分隔}
\PYG{n}{BlackList}\PYG{o}{=}\PYG{n}{writeFunction}\PYG{p}{;}\PYG{n}{updateFunction}
\PYG{c+c1}{\PYGZsh{}指定事务中的分发策略，1表示事务都不分发，2表示事务中的写语句之前的语句可以分发，默认取值为：“2”}
\PYG{n}{TransactionDispatchStrategy}\PYG{o}{=}\PYG{l+m+mi}{2}
\PYG{c+c1}{\PYGZsh{}指定底层socket receive的超时时间，单位是秒，值可以为任意正整数，“0”表示没有超时，一直等，直到返回，默认取值为：“0”。}
\PYG{n}{socketTimeout}\PYG{o}{=}\PYG{l+m+mi}{10}
\end{sphinxVerbatim}


\subsection{JDBC日志分析}
\label{\detokenize{interface/jdbc-v7:id1}}
常用的JDBC日志的命令：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
比如我要看一个线程的日志，假如131 是线程ID，

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grep} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{[131}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{.}\PYG{o}{/}\PYG{n}{jdbc\PYGZus{}new}\PYG{o}{.}\PYG{n}{log} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{131.}\PYG{n}{log}
\end{sphinxVerbatim}

这样就能看到131线程的完整JDBC日志，这样就能看到这个线程都干了什么事情，反推应用的业务逻辑。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{1}
\item {} 
比如我要看 131这个线程里的所有执行语句

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grep} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{consume time}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{.}\PYG{o}{/}\PYG{l+m+mf}{131.}\PYG{n}{log} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{131}\PYG{n}{\PYGZus{}consume}\PYG{o}{.}\PYG{n}{log}
\end{sphinxVerbatim}

这个日志就是这个线程里执行的全部的SQL是什么和SQL执行的时间。

例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{57}\PYG{p}{:}\PYG{l+m+mi}{00}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{com}\PYG{o}{.}\PYG{n}{kingbase}\PYG{o}{.}\PYG{n}{dispatcher}\PYG{o}{.}\PYG{n}{executor}\PYG{o}{.}\PYG{n}{DispatchAbstractStatement}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{executeTemplet}\PYG{p}{]} \PYG{n}{DispatchPreparedStatementV2}\PYG{o}{.}\PYG{n}{execute}\PYG{p}{(}\PYG{n}{select} \PYG{l+m+mi}{2}\PYG{p}{;}\PYG{p}{)} \PYG{n}{consume} \PYG{n}{time}\PYG{p}{:}\PYG{p}{:}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{(}\PYG{n}{ms}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{2}
\item {} 
比如我要看 monitor线程的日志

\end{enumerate}

从全日志里搜  monitor找到对应的线程ID比如是{[}32{]}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{grep} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{[32}\PYG{l+s+s2}{\PYGZbs{}}\PYG{l+s+s2}{]}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{.}\PYG{o}{/}\PYG{n}{jdbc\PYGZus{}new}\PYG{o}{.}\PYG{n}{log} \PYG{o}{\PYGZgt{}} \PYG{l+m+mf}{32.}\PYG{n}{log}
\end{sphinxVerbatim}

这样就能看到monitor不停的刷在线的主备机的IP，这样基本就能看到集群的历史和现在的状态，主备机都是谁。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
比如我要看是哪条SQL把事务设置为写事务了，从而不再分发备机。

\end{enumerate}

从日志里搜”Enter transactional state from sql”，后面的SQL就是被识别为写语句的SQL。

例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{20}\PYG{p}{:}\PYG{l+m+mi}{14}\PYG{p}{:}\PYG{l+m+mi}{41}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{com}\PYG{o}{.}\PYG{n}{kingbase}\PYG{o}{.}\PYG{n}{dispatcher}\PYG{o}{.}\PYG{n}{sqlParser}\PYG{o}{.}\PYG{n}{sql}\PYG{o}{.}\PYG{n}{SqlParser}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{parse}\PYG{p}{]} \PYG{n}{Enter} \PYG{n}{transactional} \PYG{n}{state} \PYG{k+kn}{from} \PYG{n+nn}{sql}\PYG{p}{[}\PYG{n}{create} \PYG{n}{temp} \PYG{n}{table} \PYG{n}{testk}\PYG{p}{(}\PYG{n+nb}{id} \PYG{n+nb}{int}\PYG{p}{)}\PYG{p}{]}\PYG{o}{.}
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
比如我要看看都发生了什么错误

\end{enumerate}

从日志里搜“Exception”，就能看到所有的异常信息。

例子：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{08}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{23} \PYG{l+m+mi}{20}\PYG{p}{:}\PYG{l+m+mi}{14}\PYG{p}{:}\PYG{l+m+mi}{41}\PYG{p}{]} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{p}{[}\PYG{n}{com}\PYG{o}{.}\PYG{n}{kingbase}\PYG{o}{.}\PYG{n}{dispatcher}\PYG{o}{.}\PYG{n}{executor}\PYG{o}{.}\PYG{n}{DispatchAbstractStatement}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{executeTemplet}\PYG{p}{]} \PYG{n}{failare} \PYG{n}{execute} \PYG{o+ow}{in} \PYG{n}{Master} \PYG{n+ne}{Exception}\PYG{p}{:} \PYG{p}{(}\PYG{n}{e}\PYG{o}{.}\PYG{n}{getSQLState}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{42601}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{e}\PYG{o}{.}\PYG{n}{getMessage}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{p}{[}\PYG{n}{KingbaseES} \PYG{n}{Server}\PYG{p}{]}\PYG{n}{ERROR}\PYG{p}{:} \PYG{n}{语法错误} \PYG{n}{在} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{附近} \PYG{n}{Line} \PYG{l+m+mi}{1} \PYG{n}{at} \PYG{n}{SQL} \PYG{n}{statement}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{JDBC读写分离分发策略}
\label{\detokenize{interface/jdbc-v7:id2}}
根据当前发给主机的语句数目与总语句数目的比例与HOSTLOADRATE设置的比例进行比较，当前者大于后者时，发给备机，否则发给主机。为防止语句数目统计的Integer类型溢出，当总语句数目达到Integer.MAX\_VALUE时，通过计算当前分发至主机语句的百分比，更新当前发给主机的语句数目与总语句数目。


\subsection{FastPath call returned invalid large object descriptor：0.}
\label{\detokenize{interface/jdbc-v7:fastpath-call-returned-invalid-large-object-descriptor-0}}
V7出现非法大对象操作符异常，原因是多线程操作同一个连接，默认发布版本不支持这样使用，需替换支持该使用方法的jar包。


\subsection{fetchsize功能}
\label{\detokenize{interface/jdbc-v7:fetchsize}}
通过配置连接串参数ClientCursor=false\&FetchSize=10000开启fetchsize功能，FetchSize的默认值为50，无需开启事务，但当语句里有绑定参数时，不支持使用该功能。也可通过ps.setFetchSize(int);来指定fetchsize的大小。


\subsection{mybatis一次执行多条语句时报错，错误信息为：“预置的语句中不能插入多个命令”}
\label{\detokenize{interface/jdbc-v7:mybatis}}
原因是V7不支持多语句。


\section{SSL认证常见问题}
\label{\detokenize{interface/SSL:ssl}}\label{\detokenize{interface/SSL:id1}}\label{\detokenize{interface/SSL::doc}}

\subsection{证书生成}
\label{\detokenize{interface/SSL:id2}}
\sphinxstylestrong{服务器：}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
确保安装openssl

\item {} 
在数据库data目录下，创建自签名的证书

为服务器创建一个快速的自签名的证书，填充那些openssl要求的信息。确保把本地主机名当做"Common Name"输入；挑战密码可以留空。该程序将生成一个用口令保护的密钥，它不会接受小于四字符的口令。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{new} \PYG{o}{\PYGZhy{}}\PYG{n}{text} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{req}
\end{sphinxVerbatim}

要移去密钥（如果你想自动启动服务器就必须这样），运行下面的命令：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{rsa} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{privkey}\PYG{o}{.}\PYG{n}{pem} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key}
\PYG{n}{rm} \PYG{n}{privkey}\PYG{o}{.}\PYG{n}{pem}
\end{sphinxVerbatim}

将一个证书变成自签名的证书并复制密钥和证书到服务器将要查找它们的地方

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{x509} \PYG{o}{\PYGZhy{}}\PYG{n}{days} \PYG{l+m+mi}{3650} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{server}\PYG{o}{.}\PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{text} \PYG{o}{\PYGZhy{}}\PYG{n}{key} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{server}\PYG{o}{.}\PYG{n}{crt}
\end{sphinxVerbatim}

修改文件权限，如果文件的权限比这个更自由，服务器将拒绝该文件。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chmod} \PYG{n}{og}\PYG{o}{\PYGZhy{}}\PYG{n}{rwx} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key}
\end{sphinxVerbatim}

生成根证书

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cp} \PYG{n}{server}\PYG{o}{.}\PYG{n}{crt} \PYG{n}{root}\PYG{o}{.}\PYG{n}{crt}
\end{sphinxVerbatim}

\item {} 
配置kingbase.conf文件

打开文件 找到如下属性 放开注释并修改值

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ssl} \PYG{o}{=} \PYG{n}{on}                                                  \PYG{c+c1}{\PYGZsh{} (change requires restart)}
\PYG{n}{ssl\PYGZus{}ca\PYGZus{}file} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ root.crt }\PYG{l+s+s1}{\PYGZsq{}}                       \PYG{c+c1}{\PYGZsh{} (change requires restart)}
\end{sphinxVerbatim}

\item {} 
配置sys\_hba.conf文件

打开文件，修改ipv4连接host\sphinxhyphen{}>hostssl, METHOD一栏增加clientcert=1，原有密码认证方式不变，如下所示

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} IPv4 local connections:}
\PYG{n}{hostssl}    \PYG{n+nb}{all}             \PYG{n+nb}{all}             \PYG{l+m+mf}{0.0}\PYG{o}{.}\PYG{l+m+mf}{0.0}\PYG{o}{/}\PYG{l+m+mi}{0}               \PYG{n}{md5}  \PYG{n}{clientcert}\PYG{o}{=}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}

\end{enumerate}

5.重启数据库服务器

6.为客户端创建所需证书
\begin{quote}

生成kingbase8.key

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{genrsa} \PYG{o}{\PYGZhy{}}\PYG{n}{des3} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key} \PYG{l+m+mi}{1024}
\PYG{n}{openssl} \PYG{n}{rsa} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key}
\PYG{n}{chmod} \PYG{l+m+mi}{400} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key}
\end{sphinxVerbatim}

生成kingbase8.csr，CN需要指定为要连接数据库的用户名，如需匹配不同的用户，可指定为*

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{new} \PYG{o}{\PYGZhy{}}\PYG{n}{key} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{csr} \PYG{o}{\PYGZhy{}}\PYG{n}{subj} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{/C=GB/ST=Berkshire/L=Newbury/O=Kingbase/CN=SYSTEM}\PYG{l+s+s1}{\PYGZsq{}}
\end{sphinxVerbatim}

生成kingbase8.crt

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{x509} \PYG{o}{\PYGZhy{}}\PYG{n}{req} \PYG{o}{\PYGZhy{}}\PYG{n}{days} \PYG{l+m+mi}{3650} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{csr} \PYG{o}{\PYGZhy{}}\PYG{n}{CA} \PYG{n}{root}\PYG{o}{.}\PYG{n}{crt} \PYG{o}{\PYGZhy{}}\PYG{n}{CAkey} \PYG{n}{server}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{crt} \PYG{o}{\PYGZhy{}}\PYG{n}{CAcreateserial}
\end{sphinxVerbatim}

JDBC额外步骤 其他请省略此步骤 私钥转pkcs格式

生成kingbase8.pk8

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{pkcs8} \PYG{o}{\PYGZhy{}}\PYG{n}{topk8} \PYG{o}{\PYGZhy{}}\PYG{n}{outform} \PYG{n}{DER} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{key} \PYG{o}{\PYGZhy{}}\PYG{n}{out} \PYG{n}{kingbase8}\PYG{o}{.}\PYG{n}{pk8} \PYG{o}{\PYGZhy{}}\PYG{n}{nocrypt}
\end{sphinxVerbatim}
\end{quote}


\subsection{证书配置}
\label{\detokenize{interface/SSL:id3}}
拷贝出客户端证书文件kingbase8.crt/kingbase8.key及root.crt放到客户端相应目录。
通过参数sslmode配置证书验证方式，该参数支持四个值：disable（禁用SSL）、require、verify\sphinxhyphen{}ca、verify\sphinxhyphen{}full。使用verify\sphinxhyphen{}ca和verify\sphinxhyphen{}full时，需配置证书位置，支持如下三种方式。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
默认路径。windows默认路径位置为\%APPDATA\%kingbase,linux下为\textasciitilde{}/.kingbase/，将客户端证书文件放入，系统会自动查找。只需指定"sslmode=verify\sphinxhyphen{}ca";

\item {} 
环境变量。通过设置环境变量PGSSLROOTCERT、PGSSLCERT 、PGSSLKEY指定证书位置。连接参数同默认路径。

\end{enumerate}

3. 绝对路径。通过设置sslrootcert、sslcert、sslkey参数指定。
使用verify\sphinxhyphen{}ca常常就可以提供足够的保护。只有verify\sphinxhyphen{}full模式会对主机名进行验证。
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\setcounter{enumi}{3}
\item {} 
绝对路径连接参数示例

\end{enumerate}

gorm:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dsn} \PYG{p}{:}\PYG{o}{=} \PYG{n}{fmt}\PYG{o}{.}\PYG{n}{Sprintf}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{host=}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ port=}\PYG{l+s+si}{\PYGZpc{}d}\PYG{l+s+s2}{ user=}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ password=}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ dbname=}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ sslmode=verify\PYGZhy{}ca sslrootcert=C:}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{Users}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{GBJ\PYGZhy{}0256}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{AppData}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{Roaming}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{kingbase8}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{root.crt sslcert=C:}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{Users}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{GBJ\PYGZhy{}0256}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{AppData}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{Roaming}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{kingbase8}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{kingbase8.crt sslkey=C:}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{Users}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{GBJ\PYGZhy{}0256}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{AppData}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{Roaming}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{kingbase8}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{kingbase8.key}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{n}{host}\PYG{p}{,} \PYG{n}{port}\PYG{p}{,} \PYG{n}{user}\PYG{p}{,} \PYG{n}{password}\PYG{p}{,} \PYG{n}{dbname}\PYG{p}{)}
\end{sphinxVerbatim}

QT:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{QString} \PYG{n}{connOption}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{sslmode=verify\PYGZhy{}ca;sslrootcert=/home/wli/cert/root.crt;sslcert=/home/wli/cert/kingbase8.crt;sslkey=/home/wli/cert/kingbase8.key}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{conn}\PYG{o}{.}\PYG{n}{setConnectOptions}\PYG{p}{(}\PYG{n}{connOption}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{证书有效期}
\label{\detokenize{interface/SSL:id4}}
\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics{{ssl-1}.png}
\end{figure}

openssl默认生成的证书有效期为30天，通过\sphinxhyphen{}days 参数指定证书有效时间，单位为天。
查看证书文件有效期

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{openssl} \PYG{n}{x509} \PYG{o}{\PYGZhy{}}\PYG{o+ow}{in} \PYG{n}{server}\PYG{o}{.}\PYG{n}{crt} \PYG{o}{\PYGZhy{}}\PYG{n}{noout} \PYG{o}{\PYGZhy{}}\PYG{n}{dates}
\end{sphinxVerbatim}


\chapter{Docker环境相关问题}
\label{\detokenize{docker:docker}}\label{\detokenize{docker::doc}}

\section{【exit code 137】错误信息}
\label{\detokenize{docker:exit-code-137}}
Docker环境中，在sys\_dump 或其他操作时，如果报错“exit colde 137”，通常表示内存问题。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=92\sphinxpxdimen]{{FAQ34211}.png}
\end{figure}


\section{Docker 环境下license机制}
\label{\detokenize{docker:docker-license}}
KES 是通过网卡的MAC确定license，但是在Docker环境下没有mac，无法通过原有的mac机制绑定license。Docker环境下，目前采用license版本没有与任何硬件信息绑定，但需要专门申请。


\chapter{读写分离}
\label{\detokenize{high-availability:id1}}\label{\detokenize{high-availability::doc}}

\section{读写分离分发机制}
\label{\detokenize{high-availability:id2}}
1、对于只读事务，如果事务内有多条SQL，会将每条SQL发至不同的节点（primary节点按比例，standby节点轮询）

2、对于读写混合事务，在第一个写操作之前，分发机制按读事务处理，包括写之后的所有SQL都在主节点执行

3、读写分离下，如果在备机报错ERROR或者FATAL的SQL，包括备机失败包括进程退出的错误，会把它自动再发送到主机重跑一遍。备机失败转发主机，主机如果也出现错误，并且是非IO错误，就会退出。


\section{如何测试一下现场的备机失败，转发主机的场景？}
\label{\detokenize{high-availability:id3}}
问题描述：
\begin{quote}

如何测试一下现场的备机失败，转发主机的场景？
\end{quote}

解决方案：
\begin{quote}

将HOSTLOADRATE设置成0，然后执行一个长查询，比如select sys\_sleep(20)，然后杀掉备机。
\end{quote}


\section{失败重发机制}
\label{\detokenize{high-availability:id4}}
1、参数RETRYTIMES控制失败重试的次数，默认是10。

2、所有的重发都是重发主机

3、备机任意错误失败转发主机，主机失败是IO错误才会失败重发，socket超时是IO错误，但IO错误并不只有socket超时


\section{ssh 引发的相关问题}
\label{\detokenize{high-availability:ssh}}
1) 集群在启停时，需要ssh 到远程主机，修改crontab , 运行 sys\_ctl 等。

2) 在启停集群时，如果主机间的免密认证有问题，会要求输入操作系统用户密码（通常是kingbase用户），只需重配主机间的信任关系。

3) sshd 服务只在集群启停时需要用到，暂时停止ssh服务不影响数据库使用。


\section{读写分离备机备份报错}
\label{\detokenize{high-availability:id5}}
适用版本：V8R3 , V8R6

问题描述：
\begin{quote}

在备机执行Sys\_dump时，报错“canceling statement due to conflict with recovery” “User was holding a relation lock for to long”
\end{quote}

问题分析：
\begin{quote}

备机一直处于recovery模式，在恢复过程中，会中断与恢复冲突的相关操作。比如：同步主机的vacuum 操作，而备机上的Select操作可能需要访问“旧版本”记录，阻止了vacuum操作在备机上的执行。当备机上的查询时间过长是，备机的Recovery操作会终止查询操作（sys\_dump本质也是个查询操作）。
\end{quote}


\section{读写分离集群Hash索引老是出问题}
\label{\detokenize{high-availability:hash}}
适用版本：V8R3

问题描述：
\begin{quote}

hash索引在备机不同步。对于异常宕机的情况，也需要重建hash索引。
\end{quote}

问题分析：
\begin{quote}

由于R3版本hash 索引不记录wal日志，不能用于流复制。

\begin{sphinxadmonition}{note}{Note:}
R6 版本已支持hash 索引记录wal日志
\end{sphinxadmonition}
\end{quote}


\chapter{高可用集群}
\label{\detokenize{cluster_faq:id1}}\label{\detokenize{cluster_faq::doc}}

\section{libssl 问题}
\label{\detokenize{cluster_faq:libssl}}
适用版本：V8R3

系统环境：飞腾+银河

数据库版本：kingbaseES V8

问题现象：通过部署工具部署HA成功后，通过命令启动集群服务失败；通过ssh ip访问node失败。

解决方案：修改 V8/lib库下ssl和crypto两个文件，改名即可：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}mv     libssl.so.1.0.0        libssl.so.1.0.0.bak}
\PYG{c+c1}{\PYGZsh{}mv    libcrypto.so.1.0.0  libcrypto.so.1.0.0.bak}
\end{sphinxVerbatim}

附件：

1、查看ssh库函数信息

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen,height=184\sphinxpxdimen]{{cluster_FAQ266}.png}
\end{figure}


\section{if\_up\_cmd faild}
\label{\detokenize{cluster_faq:if-up-cmd-faild}}
适用版本：V8R3

系统环境：鲲鹏+中标麒麟V7

数据库版本：kingbaseES V008R003C002B0100

问题现象：集群通过部署工具部署成功，kingbasecluster启动失败，故障提示“if\_up\_cmd faild”

故障日志：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{910408}\PYG{p}{:} \PYG{n}{LOG}\PYG{p}{:}  \PYG{n}{createing} \PYG{n}{watchdog} \PYG{n}{heartbeat} \PYG{n}{receive} \PYG{n}{socket}\PYG{o}{.}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{910408}\PYG{p}{:} \PYG{n}{DETAIL}\PYG{p}{:}  \PYG{n}{bind} \PYG{n}{receive} \PYG{n}{socket} \PYG{n}{to} \PYG{n}{device}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{enp4s0f1}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{910408}\PYG{p}{:} \PYG{n}{LOG}\PYG{p}{:}  \PYG{n+nb}{set} \PYG{n}{SO\PYGZus{}REUSEPORT} \PYG{n}{option} \PYG{n}{to} \PYG{n}{the} \PYG{n}{socket}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{910408}\PYG{p}{:} \PYG{n}{LOG}\PYG{p}{:}  \PYG{n}{creating} \PYG{n}{watchdog} \PYG{n}{heartbeat} \PYG{n}{receive} \PYG{n}{socket}\PYG{o}{.}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{910408}\PYG{p}{:} \PYG{n}{DETAIL}\PYG{p}{:}  \PYG{n+nb}{set} \PYG{n}{SO\PYGZus{}REUSEPORT}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{910405}\PYG{p}{:} \PYG{n}{LOG}\PYG{p}{:}  \PYG{n}{failed} \PYG{n}{to} \PYG{n}{acquire} \PYG{n}{the} \PYG{n}{delegate} \PYG{n}{IP} \PYG{n}{address}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{910405}\PYG{p}{:} \PYG{n}{DETAIL}\PYG{p}{:}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{if\PYGZus{}cmd}\PYG{l+s+s1}{\PYGZsq{}} \PYG{n}{failed}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{910405}\PYG{p}{:} \PYG{n}{WARNING}\PYG{p}{:}  \PYG{n}{watchdog} \PYG{n}{escalation} \PYG{n}{failed} \PYG{n}{to} \PYG{n}{acquire} \PYG{n}{delegate} \PYG{n}{IP}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{910405}\PYG{p}{:} \PYG{n}{LOG}\PYG{p}{:}  \PYG{n}{send} \PYG{n}{the} \PYG{n}{node} \PYG{n}{status} \PYG{n}{change} \PYG{n}{to} \PYG{n}{watchdog}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{910405}\PYG{p}{:} \PYG{n}{DETAIL}\PYG{p}{:}  \PYG{n}{node} \PYG{n+nb}{id} \PYG{p}{:}\PYG{l+m+mi}{0} \PYG{n}{status} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NODE DEAD}\PYG{l+s+s2}{\PYGZdq{}} \PYG{n}{message}\PYG{p}{:}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{failed to acuqire delegate IP, set node down}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{909801}\PYG{p}{:} \PYG{n}{LOG}\PYG{p}{:}  \PYG{n}{new} \PYG{n}{IPC} \PYG{n}{connection} \PYG{n}{received}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{909801}\PYG{p}{:} \PYG{n}{LOG}\PYG{p}{:}  \PYG{n}{received} \PYG{n}{node} \PYG{n}{status} \PYG{n}{change} \PYG{n}{ipc} \PYG{n}{message}

\PYG{l+m+mi}{2020}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{09}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{01} \PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{19}\PYG{p}{:}\PYG{l+m+mi}{21}\PYG{p}{:} \PYG{n}{pid} \PYG{l+m+mi}{909801}\PYG{p}{:} \PYG{n}{DETAIL}\PYG{p}{:}  \PYG{n}{failed} \PYG{n}{to} \PYG{n}{acuqire} \PYG{n}{delegate} \PYG{n}{IP}\PYG{p}{,} \PYG{n+nb}{set} \PYG{n}{node} \PYG{n}{down}
\end{sphinxVerbatim}

问题现象：哈尔滨市委BMJ三期，BMJ 部署集群cluster VIP一直做切换，集群异常

问题发生时间：2020\sphinxhyphen{}10\sphinxhyphen{}21

产品版本：KingbaseES V8 R7 0070

运行平台：飞腾2000+ 麒麟

问题分析人: 胡全、赵显平

ims号：2020\sphinxhyphen{}10\sphinxhyphen{}2100640

解决方案：
\begin{quote}

1、查看arping版本：s20190709

2、利用公司提供的arping替换现有的arping

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[kingbase@master kingbasecluster]\PYGZdl{} arping \PYGZhy{}V
arping utility, iputils\PYGZhy{}s20160308
\end{sphinxVerbatim}
\end{quote}


\section{arping问题}
\label{\detokenize{cluster_faq:arping}}
适用版本：V8R3

系统环境：鲲鹏920+统信V20（服务器版）

数据库版本：kingbaseES V008R003

问题现象：部署工具部署三节点集群，在启动数据库时启动超时，启动失败。

故障日志：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen,height=184\sphinxpxdimen]{{cluster_FAQ1846}.png}
\end{figure}

解决方案：

   1、查看arping版本信息：arping \sphinxhyphen{}v

   2、在arping的版本信息中包含：“iputils”字样

   3、需要从公司获取专用的arping版本


\section{arping\_path版本不正确}
\label{\detokenize{cluster_faq:arping-path}}
适用版本：V8R3

系统环境：飞腾2000+麒麟v10（服务器版）

数据库版本：kingbaseES V008R003

问题现象：部署工具部署集群，在启动集群后，集群两个node宕机

故障日志：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen,height=300\sphinxpxdimen]{{cluster_FAQ2048}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen,height=200\sphinxpxdimen]{{cluster_FAQ2050}.png}
\end{figure}

解决方案：

   1、查看arping版本信息：arping \sphinxhyphen{}v

   2、在arping的版本信息中包含：“iputils”字样

   3、需要从公司获取专用的arping版本


\section{esHAmodel.sh脚本错误}
\label{\detokenize{cluster_faq:eshamodel-sh}}
适用版本：V8R3

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen,height=33\sphinxpxdimen]{{cluster_FAQ2163}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen,height=33\sphinxpxdimen]{{cluster_FAQ2164}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen,height=31\sphinxpxdimen]{{cluster_FAQ2165}.png}
\end{figure}

系统环境：海光+中科方德SVS2.16.2

数据库版本：V008R007C003B0070

问题现象：BMJ部署集群时，执行esHAmodel.sh脚本报错

故障现象：

查找crond可执行文件：（crond文件存在，但是which无法查找到）

查看crontab service：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=400\sphinxpxdimen,height=203\sphinxpxdimen]{{cluster_FAQ2313}.png}
\end{figure}

解决方案：
\begin{quote}

1、首先查看crontab service服务是否正常启动。

2、查看crontab service对应的可执行文件crond是否正常（which crond）

3、如果crond文件存在（如/usr/sbin/crond）但是which无法查看，PATH路径设置正常。

4、将/usr/sbin/crond文件拷贝到/usr/bin下，which crond可以查看到。

5、启动esHAmodule.sh start正常，问题解决。

6、发现中科方德保密机系统也存在这个问题，可以用相同的方法解决。
\end{quote}


\section{集群名称不能使用cluster}
\label{\detokenize{cluster_faq:cluster}}
适用版本：V8R3

系统环境：统信服务器操作系统uos 20 SP1,鲲鹏cpu

数据库版本：V008R003C002B0160\_Aarch64

问题现象：部署集群时报错，重新部署成功。

故障现象：

解决方案：

 1、在此集群部署中，集群名称使用了“cluster”，导致文件访问错误。

 2、在集群部署中，不要使用“cluster”作为集群名称。


\section{网络问题导致备机无法加入集群}
\label{\detokenize{cluster_faq:id2}}
适用版本：V8R3

项目描述：中组部

问题时间： 2020/10/29

问题分析及结果：集群故障处理，备机db节点持续重启，无法加入集群。

数据库版本：专用机V8R7C003B0070

问题现象描述：主机故障后，恢复成备机节点，此后每分钟该节点数据库不断启动，停止，一直无法加入集群

问题分析：备节点不断重启，通过日志观察，是因为在备库节点判断自己并没有按照期望连接到主数据。没有连接的主数据库的原因，是因为期望的备数据库IP地址并没有出现在主数据库列表内，通过现场人员一些操作命令结果来看，主数据库的列表显示的备库IP为Cluster组件的VIP。操作系统的默认路由会根据不同子网的metric优先级来排序（各OS不一致），来决定归属多个IP连接服务器端时，服务器端获得的source IP，获取IP异常，导致的这一问题。那么接下来查询网络IP问题，通过执行ip addr命令查看到，集群VIP和主备数据库的网络地址均不一致，VIP为/24，主数据库为/16，备数据库为/15。

得出根本原因：
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
主备数据库IP问题，/15和/16不在一个网络地址内

\item {} 
现场配置问题，VIP的子网掩码必须和数据库一致例如/16

\end{enumerate}

解决方案：
\begin{quote}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
测试和实际生产环境子网IP必须一致，例如均在/16的子网掩码内。

\item {} 
现场配置的子网掩码保持和上述主备数据库相同，例如/16。

\end{enumerate}

按照上述步骤重新部署即可解决
\end{quote}


\section{kingbasecluster服务启动失败}
\label{\detokenize{cluster_faq:kingbasecluster}}
适用版本：V8R3

项目信息：GAW

问题现象：修复集群，cluster起不来，两端数据库进程正常

问题现象：
\begin{quote}

1.主节执行kingbase\_monitor. sh start

主机cluster. log里面报错提示：detected while reading pid file "/opt/Kingbase/ES/V8/log/kingbase/kingbasecluster.pid"

主机对应路径下有.pid文件。

备机kingbasecluster下面没有pid文件

2、主、备两端lsof:9999端口没有相关程序的进程；

3、注释备机定时任务里network\_rewind.sh ，手工执行，没有报错
\end{quote}

问题发生时间：2020/12/08

平台环境：中科方德

数据库版本： V008R007C003B0070

故障现象：

问题分析：

原因就是可能是某次启动出问题了，创建了一个有问题的pid文件，然后之后每次定时任务启动的时候会去读取一下pid文件防止启动多个kingbaseclsuter，但是读取pid文件的时候错误了，文件结尾有问题报EOF，所以后面定时任务的每分钟的启动就全部失败了，把那个pid文件删了之后就好了。

解决方案：

删除kingbasecluster.pid文件后，重启kingbasecluster服务，服务正常启动。


\section{集群sys\_md5生成错误密码}
\label{\detokenize{cluster_faq:sys-md5}}
适用版本：V8R3

问题现象：

项目描述：福州57S项目

问题现象：集群密码设置为Huawei12\#\$进行部署的时候，54321数据库可以通过ksql登录，9999cluster无法通过ksql登录。

问题时间： 2020/12/09

数据库版本：V008R003C001B0160

问题分析：

这个问题是 工具使用sys\_md5将数据库用户密码以md5加密方式存放到kingbasecluster/etc/cluster\_passwd的命令不对，之前是 ./sys\_md5 密码用户 例如 ./sys\_md5 123456SYSTEM。当密码有特殊字符，会出现特殊情况 例如 ./sys\_md5 HuaWei\#\$SYSTEM。此时\$和后面的用户结合起来变成了一个变量，而不是实际的字符，导致真正sys\_md5生成的加密密码等于是./sys\_md5 HuaWei\#

问题解决：

只需要用单引号将密码括起来就可以解决该问题

./sys\_md5 'HuaWei\#\$'SYSTEM就可以得到正确的md5加密密码


\section{两节点读写分离集群，集群无法创建主备，两个node都是主}
\label{\detokenize{cluster_faq:node}}
适用版本：V8R3

问题现象：
\begin{quote}

集群两个cluster都认为自己是主，两台上都有cluster vip，这种情况要怎么处理？
\end{quote}

问题分析：
\begin{quote}

主备流复制正常，但在两个node上都有cluster vip，查看cluster.log日志，两个node都不能和对方通讯，怀疑是防火墙导致。
\end{quote}

问题解决：
\begin{quote}

客户启动了防火墙，导致cluster两个节点不能通讯，从而使两个node都认为自己是cluster中的主。
\end{quote}


\section{集群无法修改max\_connections参数}
\label{\detokenize{cluster_faq:max-connections}}
适用版本：V8R3

问题现象：读写分离集群搭建完成后，发现无法将主节点max\_connections调小，调小后，备库无法启动。

问题分析：集群的max\_connection只能增大，不能减小。如果需要减小，只能重做备机


\section{软连接配置错误，导致集群启动报缺少磁盘空间}
\label{\detokenize{cluster_faq:id3}}
适用版本：V8R3

\sphinxstylestrong{“No Space left on device”}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=416\sphinxpxdimen]{{cluster_FAQ4862}.png}
\end{figure}


\section{未配置root用户ssh互信，部署集群时，添加节点“auth fail”}
\label{\detokenize{cluster_faq:rootssh-auth-fail}}
适用版本：V8R3

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=416\sphinxpxdimen]{{cluster_FAQ4907}.png}
\end{figure}

在配置root用户的ssh互信时，需要做以下配置：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=378\sphinxpxdimen,height=800\sphinxpxdimen]{{cluster_FAQ4935}.png}
\end{figure}


\section{防火墙导致集群show pool\_nodes信息错误}
\label{\detokenize{cluster_faq:show-pool-nodes}}
适用版本：V8R3

系统环境： 鲲鹏920 + kylin V10

故障现象：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=345\sphinxpxdimen]{{cluster_FAQ5000}.png}
\end{figure}

解决步骤：
\begin{quote}

在show pool\_nodes下备库的状态信息显示为“down”，而从sys\_stat\_replication中，主备流复制状态正常，备库数据库进程启动正常。通过kingbasecluster \sphinxhyphen{}C \sphinxhyphen{}D处理，仍然不能改变备库状态。

后经查看集群主机防火墙，因主机系统被重启后，防火墙启动，导致集群通讯故障，从而show pool\_nodes查看到的备库状态为“down”，后关闭防火墙后恢复正常。
\end{quote}


\section{ V8R3集群部署工具“auth fail”错误}
\label{\detokenize{cluster_faq:v8r3auth-fail}}
适用版本：V8R3

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=416\sphinxpxdimen]{{cluster_FAQ5256}.png}
\end{figure}

平台：aarch+centos7.4

故障现象：用集群部署工具部署集群时，添加节点时，出现“auth fail”故障。

解决方案：

  在 /etc/ssh/sshd\_config修改参数：
\begin{quote}
\end{quote}

    UseDNS no
    GSSAPIAuthentication no


\section{集群通过kingbase\_monitor.sh启动后“There are no 1 standbys in sys\_stat\_replication......"}
\label{\detokenize{cluster_faq:kingbase-monitor-shthere-are-no-1-standbys-in-sys-stat-replication}}
适用版本：V8R3

故障现象：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=233\sphinxpxdimen]{{cluster_FAQ5498}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=256\sphinxpxdimen]{{cluster_FAQ5501}.png}
\end{figure}

系统环境：

产品版本： V008R003C002B0140

操作系统：麒麟v10

cpu:海光

解决方案：
\begin{quote}

先重做备机 记得之前的data备份一下这个问题之前出现过，但是概率极低，是pg原生的问题，已经在跟进社区的修复代码，你先使用临时方案解决一下。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=308\sphinxpxdimen,height=134\sphinxpxdimen]{{cluster_FAQ5635}.png}
\end{figure}
\end{quote}


\section{KES V8R2集群kingbasecluster服务9999端口无法连接}
\label{\detokenize{cluster_faq:kes-v8r2kingbasecluster9999}}
适用版本：V8R3

故障现象：

连接集群9999端口失败，提示“所有数据库服务down”，但是可以连接54321端口，说明数据库服务正常。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=256\sphinxpxdimen]{{cluster_FAQ5745}.png}
\end{figure}

查看故障原因：
\begin{quote}

1、查看数据库和集群进程状态

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=256\sphinxpxdimen]{{cluster_FAQ5772}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=256\sphinxpxdimen]{{cluster_FAQ5775}.png}
\end{figure}

2、主库cluster.log日志

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=196\sphinxpxdimen]{{cluster_FAQ5797}.png}
\end{figure}

从上可知，数据库服务和cluster进程从系统层面正常，但是从日志看cluster服务拒绝连接。
\end{quote}

解决方案：

 1）用pkill \sphinxhyphen{}9 kingbasecluster 停止主备库cluster进程

 2）bin/kingbasecluser \sphinxhyphen{}n \sphinxhyphen{}d >cluter.log 2>\&1 重启主备库cluster服务

连接测试：
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=138\sphinxpxdimen]{{cluster_FAQ5974}.png}
\end{figure}

\# kingbasecluster 9999 端口连接成功。
\end{quote}


\section{R3集群部署工具部署时，出现sys\_md5的错误}
\label{\detokenize{cluster_faq:r3-sys-md5}}
适用版本：V8R3

数据库版本：V8R003C002B0270

故障现象：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=416\sphinxpxdimen]{{cluster_FAQ6067}.png}
\end{figure}

解决问题：
\begin{quote}

手工执行sys\_md5命令

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=29\sphinxpxdimen]{{cluster_FAQ6096}.png}
\end{figure}
\end{quote}

故障原因：在用部署工具部署时，db.zip和cluster.zip包选择错误，导致。


\section{R3集群BMJ启动esHAmodel.sh失败问题}
\label{\detokenize{cluster_faq:r3bmjeshamodel-sh}}
适用版本：V8R3

故障现象：
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=312\sphinxpxdimen]{{cluster_FAQ6185}.png}
\end{figure}

在BMJ R3集群下启动esHAmodel.sh失败，shell脚本无法找到相应的外部命令。
\end{quote}

问题查看：
\begin{quote}

查看/etc/profile环境变量PATH的设置

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=108\sphinxpxdimen]{{cluster_FAQ6269}.png}
\end{figure}
\end{quote}

问题原因：在配置java环境变量时，修改了PATH变量，缺少了读取系统可执行文件的路径。BMJ的脚本在执行时，shell脚本需要调用profile来设置环境变量。

解决问题：
\begin{quote}

修改profile环境变量：

PATH=\$PATH:\$JAVA\_HOME/bin:\$JRE\_HOME/bin，应用profile

source /etc/profile后重启esHAmodel.sh问题解决。
\end{quote}


\section{BMJ R3集群切换后es\_client无法和es\_server通讯问题}
\label{\detokenize{cluster_faq:bmj-r3es-clientes-server}}
适用版本：V8R3

故障现象：
\begin{quote}

银河麒麟专用机在起集群的时候，报错找不到备节点的es\_server，但是我在主节点执行es\_client那条命令是可以返回值的，两边的es\_server服务也都起着呢，这种情况得怎么处理？

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=179\sphinxpxdimen]{{cluster_FAQ6606}.png}
\end{figure}
\end{quote}

问题诊断：
\begin{quote}

“faild to connect to es\_server....怀疑是防火墙故障，但是通过telnet和es\_client都能通过8890和es\_server通讯。
\end{quote}

问题原因：
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=430\sphinxpxdimen,height=931\sphinxpxdimen]{{cluster_FAQ6710}.png}
\end{figure}
\end{quote}


\section{kingbaseES R3集群启动后“无standby”问题}
\label{\detokenize{cluster_faq:kingbasees-r3standby}}
适用版本：V8R3

问题现象：
\begin{quote}

一主二备的架构，通过kingbase\_monitor.sh启动后，出现以下故障信息。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=39\sphinxpxdimen]{{cluster_FAQ6806}.png}
\end{figure}
\end{quote}

集群日志信息：
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=116\sphinxpxdimen]{{cluster_FAQ6818}.png}
\end{figure}
\end{quote}

问题诊断：
\begin{quote}

根据日志提示“没有到主机的路由”判断，是在系统上有防火墙拦截导致。经过检查，在主库启动了防火墙，并且没有通过规则开放指定的端口。
\end{quote}

问题解决：
\begin{quote}

在系统配置了防火墙规则，开放指定的端口后，问题解决。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=200\sphinxpxdimen]{{cluster_FAQ6935}.png}
\end{figure}
\end{quote}


\section{kingbaseES R3集群kingbasecluster无法正确识别备库状态}
\label{\detokenize{cluster_faq:kingbasees-r3kingbasecluster}}
适用版本：V8R3

故障现象：
\begin{quote}

读写分离集群，测试主备切机后，show pool\_nodes备机状态为down。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=311\sphinxpxdimen]{{cluster_FAQ7031}.png}
\end{figure}
\end{quote}

解决方案：

1） 查看主备流复制状态正常，复制槽状态正常。

2） cluster.log日志提示备库的数据库服务错误。

复制槽状态：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=312\sphinxpxdimen]{{cluster_FAQ7097}.png}
\end{figure}

cluster.log：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=130\sphinxpxdimen]{{cluster_FAQ7114}.png}
\end{figure}

\sphinxstylestrong{初步判断kingbasecluster读取后台数据库状态信息错误：}

1）先用kingbase\_monitor.sh关闭集群。

2）手工启动kingbasecluster

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{bin}\PYG{o}{/}\PYG{n}{kingbasecluster} \PYG{o}{\PYGZhy{}}\PYG{n}{C} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{o}{\PYGZgt{}}\PYG{n}{cluster}\PYG{o}{.}\PYG{n}{log} \PYG{l+m+mi}{2}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{l+m+mi}{1} \PYG{o}{\PYGZam{}}
\end{sphinxVerbatim}

3）再手工启动数据库服务sys\_ctl。

仍然识别为备库\sphinxstylestrong{“down”}状态。

最后经过检查，发现用户部署集群后修改了数据库的端口号，主库修改为55321，备库忘记在kingbase.conf配置文件中修改，导致备库数据库启动端口号仍为54321；导致kingbasecluster不能访问到备库的数据库服务，判断其状态为“down”，在备库kingbase.conf文件中修改端口为55321后，重启集群，备库状态正常。


\section{kingbaseES R3 集群无法加载db VIP 和cluster VIP案例}
\label{\detokenize{cluster_faq:kingbasees-r3-db-vip-cluster-vip}}
适用版本：V8R3

故障现象：
\begin{quote}

通过kingbase\_monitor.sh启动提示“无法加载db VIP”

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=130\sphinxpxdimen]{{cluster_FAQ7114}.png}
\end{figure}
\end{quote}

解决方案：
\begin{quote}

1）查看数据库服务正常，并且主备流复制状态正常，集群kingbasecluster服务无法启动。

2）手工启动kingbasecluster服务，发现提示“不能加载cluster VIP”。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=173\sphinxpxdimen]{{cluster_FAQ7560}.png}
\end{figure}

3）检查arping版本正常，kingbasecluster.conf文件发现加载vip语句有错误。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=164\sphinxpxdimen]{{cluster_FAQ7669}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=326\sphinxpxdimen,height=83\sphinxpxdimen]{{cluster_FAQ7721}.png}
\end{figure}

4）修改kingbasecluster.conf配置后，手工启动kingbasecluster服务正常。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=488\sphinxpxdimen,height=149\sphinxpxdimen]{{cluster_FAQ7723}.png}
\end{figure}

5）通过kingbase\_monitor.sh启动仍然报错，提示“无法加载db VIP”。

6）手工执行sh \sphinxhyphen{}x change\_vip.sh，发现错误“DEV”变量为空值。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=540\sphinxpxdimen,height=168\sphinxpxdimen]{{cluster_FAQ7776}.png}
\end{figure}

7） 检查HAmodule.conf文件，发现“DEV"变量赋值为空。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=486\sphinxpxdimen,height=297\sphinxpxdimen]{{cluster_FAQ7862}.png}
\end{figure}

8） 在所有的HAmodule.conf文件中，给”DEV“变量指定网卡名称后，重新通过kingbase\_monitor.sh启动集群正常。

9） 以上问题有可能实施人员部署中操作有误，或者是版本bug，需要进一步验证。
\end{quote}


\section{网关无法连通，导致集群down，手工启动数据库服务}
\label{\detokenize{cluster_faq:down}}
适用版本：V8R3

故障现象：
\begin{quote}

整个集群在测试网关连通时，无法ping通网关，导致整个集群宕机。在此期间network\_rewind尝试recovery，但是不能恢复数据库服务，kingbasecluster服务被计划任务重启。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=513\sphinxpxdimen,height=97\sphinxpxdimen]{{cluster_FAQ7898}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=299\sphinxpxdimen]{{cluster_FAQ8150}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=146\sphinxpxdimen]{{cluster_FAQ8153}.png}
\end{figure}
\end{quote}

问题分析：
\begin{quote}

在8:39分后，人工干预下，手工重新启动所有节点的数据库服务后，集群恢复正常。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=165\sphinxpxdimen]{{cluster_FAQ8204}.png}
\end{figure}
\end{quote}

问题总结：
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=292\sphinxpxdimen]{{cluster_FAQ8213}.png}
\end{figure}
\end{quote}


\section{备库kingbasecluster服务通过kingbase\_monitor.sh启动失败，手工启动kingbasecluster服务解决}
\label{\detokenize{cluster_faq:kingbaseclusterkingbase-monitor-sh-kingbasecluster}}
适用版本：V8R3

案例应用环境：
\begin{quote}

飞腾+麒麟v10组合  通用机 KES R3 220集群
\end{quote}

故障现象：
\begin{quote}

备库kingbasecluster服务进程和端口（9999）启动正常，但通过ksql连接9999端口访问失败，telnet访问9999端口正常。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=84\sphinxpxdimen]{{cluster_FAQ8414}.png}
\end{figure}

kingbasecluster进程和端口：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=377\sphinxpxdimen]{{cluster_FAQ8439}.png}
\end{figure}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=116\sphinxpxdimen]{{cluster_FAQ8442}.png}
\end{figure}

9999端口socket文件不存在：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=212\sphinxpxdimen]{{cluster_FAQ8464}.png}
\end{figure}

telnet连接9999端口：

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=169\sphinxpxdimen]{{cluster_FAQ8483}.png}
\end{figure}
\end{quote}

解决方法：
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=422\sphinxpxdimen,height=169\sphinxpxdimen]{{cluster_FAQ8492}.png}
\end{figure}

手工启动备库kingbasecluster服务后，问题解决。
\end{quote}


\section{KES V8R3集群通过kingbase\_monitor.sh启动失败，提示“pam\_nologin(8)"错误}
\label{\detokenize{cluster_faq:kes-v8r3kingbase-monitor-sh-pam-nologin-8}}
适用版本：V8R3

案例环境：
\begin{quote}

操作系统： 银河麒麟（通用机）

数据库版本：KES V8R3C2B120
\end{quote}

故障现象：
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=163\sphinxpxdimen]{{cluster_FAQ8643}.png}
\end{figure}

集群通过kingbase\_monitor.sh脚本启动后，身份认证失败。
\end{quote}

解决思路：
\begin{quote}

因为kingbase\_monitor.sh启动，会通过ssh远程连接node做集群服务的检测，怀疑和ssh连接的身份认证有关系。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=136\sphinxpxdimen]{{cluster_FAQ8760}.png}
\end{figure}
\end{quote}

解决方法：
\begin{quote}

如下图所示，需要将/etc/pam.d/sshd文件中的标识的行注释后，重新启动集群后，问题解决。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=234\sphinxpxdimen]{{cluster_FAQ8820}.png}
\end{figure}
\end{quote}


\section{conflict with recovery问题}
\label{\detokenize{cluster_faq:conflict-with-recovery}}
适用版本：V8R6

数据库日志报错：
\begin{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{FATAL}\PYG{p}{:} \PYG{n}{terminating} \PYG{n}{connection} \PYG{n}{due} \PYG{n}{to} \PYG{n}{conflict} \PYG{k}{with} \PYG{n}{recovery}
\PYG{n}{Detail}\PYG{p}{:} \PYG{n}{User} \PYG{n}{was} \PYG{n}{holding} \PYG{n}{shared} \PYG{n}{buffer} \PYG{n}{pin} \PYG{k}{for} \PYG{n}{to} \PYG{n}{long}
\end{sphinxVerbatim}
\end{quote}

问题分析：
\begin{quote}

这个报错是说备机恢复vacuum时（vaccum操作在备机进行同步），有个页面正在被使用。恢复进程会等待，如果等待超过了max\_standby\_streaming\_delay就会报错。
\end{quote}


\section{sys\_dump备份问题}
\label{\detokenize{cluster_faq:sys-dump}}
适用版本：V8R6

故障现象：
\begin{quote}

V8R6 sys\_dump备份成dump格式可以正常备份，备份成sql格式报错。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=301\sphinxpxdimen]{{cluster_FAQ9139}.png}
\end{figure}
\end{quote}

问题分析：
\begin{quote}

在同一主机安装了不同版本的V8R6的数据库软件，在使用sys\_dump备份时，使用了其他版本，导致错误。
\end{quote}


\section{sys\_restore 恢复数据错误}
\label{\detokenize{cluster_faq:sys-restore}}
适用版本：V8R6

运行环境：

产品版本：V008R006M009B0011

操作系统：红帽8.7

错误现象：
\begin{quote}

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=312\sphinxpxdimen]{{cluster_FAQ9267}.png}
\end{figure}
\end{quote}

故障原因：
\begin{quote}

操作人员在手工输入命令行时，没有区分英文和中文字符，导致命令行执行错误。
\end{quote}


\section{kingbaseES R6集群部署“open files”问题}
\label{\detokenize{cluster_faq:kingbasees-r6open-files}}
适用版本：V8R6

问题现象：
\begin{quote}

BMJ环境，kingbaseES R6集群部署时，es\_client连接远程服务器检测环境，“open files”参数配置错误，但是通过查看远程主机（ulimit\sphinxhyphen{}n结果为655360），符合部署要求。

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=358\sphinxpxdimen]{{cluster_FAQ9467}.png}
\end{figure}
\end{quote}

检查问题原因：
\begin{quote}

1、手工执行出错信息的命令

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=160\sphinxpxdimen]{{cluster_FAQ9494}.png}
\end{figure}

2、查看远程机器的open files

\begin{figure}[htbp]
\centering

\noindent\sphinxincludegraphics[width=554\sphinxpxdimen,height=301\sphinxpxdimen]{{cluster_FAQ9516}.png}
\end{figure}
\end{quote}

解决方案：
\begin{quote}

在126的远程主机上执行：

1、编辑/etc/profile 增加

   ulimit \sphinxhyphen{}HSn 102400

2、执行source /etc/profile后，重新部署，问题解决。
\end{quote}

\appendix
\phantomsection\label{\detokenize{legalnotice::doc}}

\chapter{版权声明}
\label{\detokenize{legalnotice:id1}}
人大金仓版权所有，并保留对本手册及本声明的一切权利。
未得到人大金仓的书面许可，任何人不得以任何方式或形式对本手册内的任何部分进行复制、摘录、备份、修改、传播、翻译成其他语言、将其全部或部分用于商业用途。

\sphinxstyleemphasis{免责声明}

本手册内容依据现有信息制作，由于产品版本升级或其他原因，其内容有可能变更。人大金仓保留在没有任何通知或者提示的情况下对手册内容进行修改的权利。
本手册仅作为使用指导，人大金仓在编写本手册时已尽力保证其内容准确可靠，但并不确保手册内容完全没有错误或遗漏，本手册中的所有信息也不构成任何明示或暗示的担保。

\sphinxstyleemphasis{技术支持}
\begin{itemize}
\item {} 
人大金仓官方网站：\sphinxurl{http://www.kingbase.com.cn/}
您可以在官网中获得人大金仓所有产品的资讯信息，销售联系方式。

\item {} 
金仓数据库子网站：\sphinxurl{http://kes.kingbase.com.cn/}
您可以在产品子网站中获得最新的产品技术资料、产品故障原因及问题分析、产品的应用解决方案、软件升级资料等等。

\item {} 
全国服务热线：400\sphinxhyphen{}601\sphinxhyphen{}1188

\item {} 
人大金仓技术支持与反馈信箱：\sphinxhref{mailto:support@kingbase.com.cn}{support@kingbase.com.cn}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}